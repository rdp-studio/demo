/*
 * handtracking.io Library for hand tracking in the browser. https://github.com/handtracking-io/yoha
 * Copyright (C) 2021 Benjamin Mularczyk.  
 */
// "module name","license","repository"
// "@tensorflow/tfjs-backend-cpu@3.9.0","Apache-2.0","https://github.com/tensorflow/tfjs"
// "@tensorflow/tfjs-backend-wasm@3.9.0","Apache-2.0",""
// "@tensorflow/tfjs-backend-webgl@3.9.0","Apache-2.0","https://github.com/tensorflow/tfjs"
// "@tensorflow/tfjs-converter@3.9.0","Apache-2.0","https://github.com/tensorflow/tfjs-converter"
// "@tensorflow/tfjs-core@3.9.0","Apache-2.0","https://github.com/tensorflow/tfjs-core"
// "long@4.0.0","Apache-2.0","https://github.com/dcodeIO/long.js"
// "node-fetch@2.6.1","MIT","https://github.com/bitinn/node-fetch"
// "seedrandom@2.4.3","MIT","https://github.com/davidbau/seedrandom"
(()=>{var HR=Object.create,hl=Object.defineProperty,jR=Object.getPrototypeOf,qR=Object.prototype.hasOwnProperty,KR=Object.getOwnPropertyNames,XR=Object.getOwnPropertyDescriptor;var YR=r=>hl(r,"__esModule",{value:!0});var ot=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),Ie=(r,e)=>{for(var t in e)hl(r,t,{get:e[t],enumerable:!0})},JR=(r,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of KR(e))!qR.call(r,n)&&n!=="default"&&hl(r,n,{get:()=>e[n],enumerable:!(t=XR(e,n))||t.enumerable});return r},gl=r=>JR(YR(hl(r!=null?HR(jR(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var Jb=ot((dH,Wb)=>{Wb.exports=$e;var Vt=null;try{Vt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(r){}function $e(r,e,t){this.low=r|0,this.high=e|0,this.unsigned=!!t}$e.prototype.__isLong__;Object.defineProperty($e.prototype,"__isLong__",{value:!0});function Rt(r){return(r&&r.__isLong__)===!0}$e.isLong=Rt;var Vb={},Gb={};function Zo(r,e){var t,n,o;return e?(r>>>=0,(o=0<=r&&r<256)&&(n=Gb[r],n)?n:(t=De(r,(r|0)<0?-1:0,!0),o&&(Gb[r]=t),t)):(r|=0,(o=-128<=r&&r<128)&&(n=Vb[r],n)?n:(t=De(r,r<0?-1:0,!1),o&&(Vb[r]=t),t))}$e.fromInt=Zo;function Gt(r,e){if(isNaN(r))return e?es:zt;if(e){if(r<0)return es;if(r>=zb)return qb}else{if(r<=-Hb)return $t;if(r+1>=Hb)return jb}return r<0?Gt(-r,e).neg():De(r%Pa|0,r/Pa|0,e)}$e.fromNumber=Gt;function De(r,e,t){return new $e(r,e,t)}$e.fromBits=De;var Cc=Math.pow;function Qf(r,e,t){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return zt;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var n;if((n=r.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return Qf(r.substring(1),e,t).neg();for(var o=Gt(Cc(t,8)),s=zt,i=0;i<r.length;i+=8){var a=Math.min(8,r.length-i),u=parseInt(r.substring(i,i+a),t);if(a<8){var l=Gt(Cc(t,a));s=s.mul(l).add(Gt(u))}else s=s.mul(o),s=s.add(Gt(u))}return s.unsigned=e,s}$e.fromString=Qf;function Qt(r,e){return typeof r=="number"?Gt(r,e):typeof r=="string"?Qf(r,e):De(r.low,r.high,typeof e=="boolean"?e:r.unsigned)}$e.fromValue=Qt;var Kb=1<<16,M2=1<<24,Pa=Kb*Kb,zb=Pa*Pa,Hb=zb/2,Xb=Zo(M2),zt=Zo(0);$e.ZERO=zt;var es=Zo(0,!0);$e.UZERO=es;var La=Zo(1);$e.ONE=La;var Yb=Zo(1,!0);$e.UONE=Yb;var Zf=Zo(-1);$e.NEG_ONE=Zf;var jb=De(4294967295|0,2147483647|0,!1);$e.MAX_VALUE=jb;var qb=De(4294967295|0,4294967295|0,!0);$e.MAX_UNSIGNED_VALUE=qb;var $t=De(0,2147483648|0,!1);$e.MIN_VALUE=$t;var K=$e.prototype;K.toInt=function(){return this.unsigned?this.low>>>0:this.low};K.toNumber=function(){return this.unsigned?(this.high>>>0)*Pa+(this.low>>>0):this.high*Pa+(this.low>>>0)};K.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq($t)){var t=Gt(e),n=this.div(t),o=n.mul(t).sub(this);return n.toString(e)+o.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=Gt(Cc(e,6),this.unsigned),i=this,a="";;){var u=i.div(s),l=i.sub(u.mul(s)).toInt()>>>0,c=l.toString(e);if(i=u,i.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};K.getHighBits=function(){return this.high};K.getHighBitsUnsigned=function(){return this.high>>>0};K.getLowBits=function(){return this.low};K.getLowBitsUnsigned=function(){return this.low>>>0};K.getNumBitsAbs=function(){if(this.isNegative())return this.eq($t)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};K.isZero=function(){return this.high===0&&this.low===0};K.eqz=K.isZero;K.isNegative=function(){return!this.unsigned&&this.high<0};K.isPositive=function(){return this.unsigned||this.high>=0};K.isOdd=function(){return(this.low&1)==1};K.isEven=function(){return(this.low&1)==0};K.equals=function(e){return Rt(e)||(e=Qt(e)),this.unsigned!==e.unsigned&&this.high>>>31==1&&e.high>>>31==1?!1:this.high===e.high&&this.low===e.low};K.eq=K.equals;K.notEquals=function(e){return!this.eq(e)};K.neq=K.notEquals;K.ne=K.notEquals;K.lessThan=function(e){return this.comp(e)<0};K.lt=K.lessThan;K.lessThanOrEqual=function(e){return this.comp(e)<=0};K.lte=K.lessThanOrEqual;K.le=K.lessThanOrEqual;K.greaterThan=function(e){return this.comp(e)>0};K.gt=K.greaterThan;K.greaterThanOrEqual=function(e){return this.comp(e)>=0};K.gte=K.greaterThanOrEqual;K.ge=K.greaterThanOrEqual;K.compare=function(e){if(Rt(e)||(e=Qt(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};K.comp=K.compare;K.negate=function(){return!this.unsigned&&this.eq($t)?$t:this.not().add(La)};K.neg=K.negate;K.add=function(e){Rt(e)||(e=Qt(e));var t=this.high>>>16,n=this.high&65535,o=this.low>>>16,s=this.low&65535,i=e.high>>>16,a=e.high&65535,u=e.low>>>16,l=e.low&65535,c=0,p=0,m=0,f=0;return f+=s+l,m+=f>>>16,f&=65535,m+=o+u,p+=m>>>16,m&=65535,p+=n+a,c+=p>>>16,p&=65535,c+=t+i,c&=65535,De(m<<16|f,c<<16|p,this.unsigned)};K.subtract=function(e){return Rt(e)||(e=Qt(e)),this.add(e.neg())};K.sub=K.subtract;K.multiply=function(e){if(this.isZero())return zt;if(Rt(e)||(e=Qt(e)),Vt){var t=Vt.mul(this.low,this.high,e.low,e.high);return De(t,Vt.get_high(),this.unsigned)}if(e.isZero())return zt;if(this.eq($t))return e.isOdd()?$t:zt;if(e.eq($t))return this.isOdd()?$t:zt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Xb)&&e.lt(Xb))return Gt(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=e.high>>>16,u=e.high&65535,l=e.low>>>16,c=e.low&65535,p=0,m=0,f=0,d=0;return d+=i*c,f+=d>>>16,d&=65535,f+=s*c,m+=f>>>16,f&=65535,f+=i*l,m+=f>>>16,f&=65535,m+=o*c,p+=m>>>16,m&=65535,m+=s*l,p+=m>>>16,m&=65535,m+=i*u,p+=m>>>16,m&=65535,p+=n*c+o*l+s*u+i*a,p&=65535,De(f<<16|d,p<<16|m,this.unsigned)};K.mul=K.multiply;K.divide=function(e){if(Rt(e)||(e=Qt(e)),e.isZero())throw Error("division by zero");if(Vt){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?Vt.div_u:Vt.div_s)(this.low,this.high,e.low,e.high);return De(t,Vt.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?es:zt;var n,o,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return es;if(e.gt(this.shru(1)))return Yb;s=es}else{if(this.eq($t)){if(e.eq(La)||e.eq(Zf))return $t;if(e.eq($t))return La;var i=this.shr(1);return n=i.div(e).shl(1),n.eq(zt)?e.isNegative()?La:Zf:(o=this.sub(e.mul(n)),s=n.add(o.div(e)),s)}else if(e.eq($t))return this.unsigned?es:zt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=zt}for(o=this;o.gte(e);){n=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),u=a<=48?1:Cc(2,a-48),l=Gt(n),c=l.mul(e);c.isNegative()||c.gt(o);)n-=u,l=Gt(n,this.unsigned),c=l.mul(e);l.isZero()&&(l=La),s=s.add(l),o=o.sub(c)}return s};K.div=K.divide;K.modulo=function(e){if(Rt(e)||(e=Qt(e)),Vt){var t=(this.unsigned?Vt.rem_u:Vt.rem_s)(this.low,this.high,e.low,e.high);return De(t,Vt.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};K.mod=K.modulo;K.rem=K.modulo;K.not=function(){return De(~this.low,~this.high,this.unsigned)};K.and=function(e){return Rt(e)||(e=Qt(e)),De(this.low&e.low,this.high&e.high,this.unsigned)};K.or=function(e){return Rt(e)||(e=Qt(e)),De(this.low|e.low,this.high|e.high,this.unsigned)};K.xor=function(e){return Rt(e)||(e=Qt(e)),De(this.low^e.low,this.high^e.high,this.unsigned)};K.shiftLeft=function(e){return Rt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?De(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):De(0,this.low<<e-32,this.unsigned)};K.shl=K.shiftLeft;K.shiftRight=function(e){return Rt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?De(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):De(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};K.shr=K.shiftRight;K.shiftRightUnsigned=function(e){if(Rt(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var n=this.low;return De(n>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?De(t,0,this.unsigned):De(t>>>e-32,0,this.unsigned)};K.shru=K.shiftRightUnsigned;K.shr_u=K.shiftRightUnsigned;K.toSigned=function(){return this.unsigned?De(this.low,this.high,!1):this};K.toUnsigned=function(){return this.unsigned?this:De(this.low,this.high,!0)};K.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};K.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};K.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};$e.fromBytes=function(e,t,n){return n?$e.fromBytesLE(e,t):$e.fromBytesBE(e,t)};$e.fromBytesLE=function(e,t){return new $e(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};$e.fromBytesBE=function(e,t){return new $e(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}});var Fw=ot(()=>{});var Pw=ot(()=>{});var xv=ot((gv,Mh)=>{(function(r,e,t){function n(a){var u=this,l=i();u.next=function(){var c=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=c-(u.c=c|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(a),u.s0<0&&(u.s0+=1),u.s1-=l(a),u.s1<0&&(u.s1+=1),u.s2-=l(a),u.s2<0&&(u.s2+=1),l=null}function o(a,u){return u.c=a.c,u.s0=a.s0,u.s1=a.s1,u.s2=a.s2,u}function s(a,u){var l=new n(a),c=u&&u.state,p=l.next;return p.int32=function(){return l.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,l),p.state=function(){return o(l,{})}),p}function i(){var a=4022871197,u=function(l){l=l.toString();for(var c=0;c<l.length;c++){a+=l.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return u}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.alea=s})(gv,typeof Mh=="object"&&Mh,typeof define=="function"&&define)});var yv=ot((_v,Bh)=>{(function(r,e,t){function n(i){var a=this,u="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor128=s})(_v,typeof Bh=="object"&&Bh,typeof define=="function"&&define)});var wv=ot((bv,Uh)=>{(function(r,e,t){function n(i){var a=this,u="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,l==u.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorwow=s})(bv,typeof Uh=="object"&&Uh,typeof define=="function"&&define)});var Iv=ot((vv,Wh)=>{(function(r,e,t){function n(i){var a=this;a.next=function(){var l=a.x,c=a.i,p,m,f;return p=l[c],p^=p>>>7,m=p^p<<24,p=l[c+1&7],m^=p^p>>>10,p=l[c+3&7],m^=p^p>>>3,p=l[c+4&7],m^=p^p<<7,p=l[c+7&7],p=p^p<<13,m^=p^p<<9,l[c]=m,a.i=c+1&7,m};function u(l,c){var p,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?m=f[7]=-1:m=f[p],l.x=f,l.i=0,p=256;p>0;--p)l.next()}u(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.x&&o(l,u),c.state=function(){return o(u,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorshift7=s})(vv,typeof Wh=="object"&&Wh,typeof define=="function"&&define)});var Tv=ot((Cv,Vh)=>{(function(r,e,t){function n(i){var a=this;a.next=function(){var l=a.w,c=a.X,p=a.i,m,f;return a.w=l=l+1640531527|0,f=c[p+34&127],m=c[p=p+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[p]=f^m,a.i=p,f+(l^l>>>16)|0};function u(l,c){var p,m,f,d,h,g=[],y=128;for(c===(c|0)?(m=c,c=null):(c=c+"\0",m=0,y=Math.max(y,c.length)),f=0,d=-32;d<y;++d)c&&(m^=c.charCodeAt((d+32)%c.length)),d===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,d>=0&&(h=h+1640531527|0,p=g[d&127]^=m+h,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,d=4*128;d>0;--d)m=g[f+34&127],p=g[f=f+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,g[f]=m^p;l.w=h,l.X=g,l.i=f}u(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.X&&o(l,u),c.state=function(){return o(u,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor4096=s})(Cv,typeof Vh=="object"&&Vh,typeof define=="function"&&define)});var kv=ot((Sv,Gh)=>{(function(r,e,t){function n(i){var a=this,u="";a.next=function(){var c=a.b,p=a.c,m=a.d,f=a.a;return c=c<<25^c>>>7^p,p=p-m|0,m=m<<24^m>>>8^f,f=f-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-m|0,a.d=m<<16^p>>>16^f,a.a=f-c|0},a.a=0,a.b=0,a.c=2654435769|0,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):u+=i;for(var l=0;l<u.length+20;l++)a.b^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.tychei=s})(Sv,typeof Gh=="object"&&Gh,typeof define=="function"&&define)});var Nv=ot(()=>{});var Ev=ot((xee,jc)=>{(function(r,e){var t=this,n=256,o=6,s=52,i="random",a=e.pow(n,o),u=e.pow(2,s),l=u*2,c=n-1,p;function m(_,N,R){var F=[];N=N==!0?{entropy:!0}:N||{};var D=g(h(N.entropy?[_,I(r)]:_??y(),3),F),O=new f(F),U=function(){for(var M=O.g(o),G=a,j=0;M<u;)M=(M+j)*n,G*=n,j=O.g(1);for(;M>=l;)M/=2,G/=2,j>>>=1;return(M+j)/G};return U.int32=function(){return O.g(4)|0},U.quick=function(){return O.g(4)/4294967296},U.double=U,g(I(O.S),r),(N.pass||R||function(M,G,j,ee){return ee&&(ee.S&&d(ee,O),M.state=function(){return d(O,{})}),j?(e[i]=M,G):M})(U,D,"global"in N?N.global:this==e,N.state)}e["seed"+i]=m;function f(_){var N,R=_.length,F=this,D=0,O=F.i=F.j=0,U=F.S=[];for(R||(_=[R++]);D<n;)U[D]=D++;for(D=0;D<n;D++)U[D]=U[O=c&O+_[D%R]+(N=U[D])],U[O]=N;(F.g=function(M){for(var G,j=0,ee=F.i,Q=F.j,ie=F.S;M--;)G=ie[ee=c&ee+1],j=j*n+ie[c&(ie[ee]=ie[Q=c&Q+G])+(ie[Q]=G)];return F.i=ee,F.j=Q,j})(n)}function d(_,N){return N.i=_.i,N.j=_.j,N.S=_.S.slice(),N}function h(_,N){var R=[],F=typeof _,D;if(N&&F=="object")for(D in _)try{R.push(h(_[D],N-1))}catch(O){}return R.length?R:F=="string"?_:_+"\0"}function g(_,N){for(var R=_+"",F,D=0;D<R.length;)N[c&D]=c&(F^=N[c&D]*19)+R.charCodeAt(D++);return I(N)}function y(){try{var _;return p&&(_=p.randomBytes)?_=_(n):(_=new Uint8Array(n),(t.crypto||t.msCrypto).getRandomValues(_)),I(_)}catch(F){var N=t.navigator,R=N&&N.plugins;return[+new Date,t,R,t.screen,I(r)]}}function I(_){return String.fromCharCode.apply(0,_)}if(g(e.random(),r),typeof jc=="object"&&jc.exports){jc.exports=m;try{p=Nv()}catch(_){}}else typeof define=="function"&&define.amd&&define(function(){return m})})([],Math)});var Rv=ot((_ee,Av)=>{var HO=xv(),jO=yv(),qO=wv(),KO=Iv(),XO=Tv(),YO=kv(),_s=Ev();_s.alea=HO;_s.xor128=jO;_s.xorwow=qO;_s.xorshift7=KO;_s.xor4096=XO;_s.tychei=YO;Av.exports=_s});var oi=ot(()=>{});var sp=ot(()=>{});var _0=ot(()=>{});var y0=ot(()=>{});var b0=ot((ap,Mg)=>{var Bg=function(){var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(e){e=e||{};function t(){return se.buffer!=pt&&Er(se.buffer),xi}function n(){return se.buffer!=pt&&Er(se.buffer),_i}function o(){return se.buffer!=pt&&Er(se.buffer),Vu}function s(){return se.buffer!=pt&&Er(se.buffer),Gu}function i(){return se.buffer!=pt&&Er(se.buffer),zu}var a=typeof e!="undefined"?e:{},u,l;a.ready=new Promise(function(b,T){u=b,l=T});var c={},p;for(p in a)a.hasOwnProperty(p)&&(c[p]=a[p]);var m=[],f="./this.program",d=function(b,T){throw T},h=!1,g=!1,y=!1,I=!1;h=typeof window=="object",g=typeof importScripts=="function",y=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",I=!h&&!y&&!g;var _=a.ENVIRONMENT_IS_PTHREAD||!1;_&&(pt=a.buffer);var N="";function R(b){return a.locateFile?a.locateFile(b,N):N+b}var F,D,O,U,M,G;if(y){g?N=oi().dirname(N)+"/":N=__dirname+"/",F=function(T,A){return M||(M=sp()),G||(G=oi()),T=G.normalize(T),M.readFileSync(T,A?null:"utf8")},O=function(T){var A=F(T,!0);return A.buffer||(A=new Uint8Array(A)),_t(A.buffer),A},process.argv.length>1&&(f=process.argv[1].replace(/\\/g,"/")),m=process.argv.slice(2),process.on("uncaughtException",function(b){if(!(b instanceof Ei))throw b}),process.on("unhandledRejection",Rr),d=function(b){process.exit(b)},a.inspect=function(){return"[Emscripten Module object]"};var j;try{j=_0()}catch(b){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),b}global.Worker=j.Worker}else I?(typeof read!="undefined"&&(F=function(T){return read(T)}),O=function(T){var A;return typeof readbuffer=="function"?new Uint8Array(readbuffer(T)):(A=read(T,"binary"),_t(typeof A=="object"),A)},typeof scriptArgs!="undefined"?m=scriptArgs:typeof arguments!="undefined"&&(m=arguments),typeof quit=="function"&&(d=function(b){quit(b)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(h||g)&&(g?N=self.location.href:typeof document!="undefined"&&document.currentScript&&(N=document.currentScript.src),typeof r!="undefined"&&r&&(N=r),N.indexOf("blob:")!==0?N=N.substr(0,N.lastIndexOf("/")+1):N="",y?(F=function(T,A){return M||(M=sp()),G||(G=oi()),T=G.normalize(T),M.readFileSync(T,A?null:"utf8")},O=function(T){var A=F(T,!0);return A.buffer||(A=new Uint8Array(A)),_t(A.buffer),A}):(F=function(b){var T=new XMLHttpRequest;return T.open("GET",b,!1),T.send(null),T.responseText},g&&(O=function(b){var T=new XMLHttpRequest;return T.open("GET",b,!1),T.responseType="arraybuffer",T.send(null),new Uint8Array(T.response)}),D=function(b,T,A){var P=new XMLHttpRequest;P.open("GET",b,!0),P.responseType="arraybuffer",P.onload=function(){if(P.status==200||P.status==0&&P.response){T(P.response);return}A()},P.onerror=A,P.send(null)}),U=function(b){document.title=b});y&&typeof performance=="undefined"&&(global.performance=y0().performance);var ee=a.print||console.log.bind(console),Q=a.printErr||console.warn.bind(console);for(p in c)c.hasOwnProperty(p)&&(a[p]=c[p]);c=null,a.arguments&&(m=a.arguments),a.thisProgram&&(f=a.thisProgram),a.quit&&(d=a.quit);var ie=Atomics.load,le=Atomics.store,Ce=Atomics.compareExchange,de;a.wasmBinary&&(de=a.wasmBinary);var Qe=a.noExitRuntime||!0;typeof WebAssembly!="object"&&Rr("no native wasm support detected");var se,it,rt=!1,We;function _t(b,T){b||Rr("Assertion failed: "+T)}function lr(b){var T=a["_"+b];return _t(T,"Cannot call unknown function "+b+", make sure it is exported"),T}function Nt(b,T,A,P,q){var z={string:function(mt){var ta=0;if(mt!=null&&mt!==0){var Xy=(mt.length<<2)+1;ta=Qs(Xy),Bu(mt,ta,Xy)}return ta},array:function(mt){var ta=Qs(mt.length);return Uu(mt,ta),ta}};function H(mt){return T==="string"?yt(mt):T==="boolean"?Boolean(mt):mt}var J=lr(b),ve=[],Ze=0;if(P)for(var Ke=0;Ke<P.length;Ke++){var ln=z[A[Ke]];ln?(Ze===0&&(Ze=Ni()),ve[Ke]=ln(P[Ke])):ve[Ke]=P[Ke]}var ea=J.apply(null,ve);return ea=H(ea),Ze!==0&&Js(Ze),ea}function rn(b,T,A,P){A=A||[];var q=A.every(function(H){return H==="number"}),z=T!=="string";return z&&q&&!P?lr(b):function(){return Nt(b,T,A,arguments,P)}}function zs(b,T,A){for(var P=T+A,q="";!(T>=P);){var z=b[T++];if(!z)return q;if(!(z&128)){q+=String.fromCharCode(z);continue}var H=b[T++]&63;if((z&224)==192){q+=String.fromCharCode((z&31)<<6|H);continue}var J=b[T++]&63;if((z&240)==224?z=(z&15)<<12|H<<6|J:z=(z&7)<<18|H<<12|J<<6|b[T++]&63,z<65536)q+=String.fromCharCode(z);else{var ve=z-65536;q+=String.fromCharCode(55296|ve>>10,56320|ve&1023)}}return q}function yt(b,T){return b?zs(n(),b,T):""}function Qp(b,T,A,P){if(!(P>0))return 0;for(var q=A,z=A+P-1,H=0;H<b.length;++H){var J=b.charCodeAt(H);if(J>=55296&&J<=57343){var ve=b.charCodeAt(++H);J=65536+((J&1023)<<10)|ve&1023}if(J<=127){if(A>=z)break;T[A++]=J}else if(J<=2047){if(A+1>=z)break;T[A++]=192|J>>6,T[A++]=128|J&63}else if(J<=65535){if(A+2>=z)break;T[A++]=224|J>>12,T[A++]=128|J>>6&63,T[A++]=128|J&63}else{if(A+3>=z)break;T[A++]=240|J>>18,T[A++]=128|J>>12&63,T[A++]=128|J>>6&63,T[A++]=128|J&63}}return T[A]=0,A-q}function Bu(b,T,A){return Qp(b,n(),T,A)}function Zp(b){for(var T=0,A=0;A<b.length;++A){var P=b.charCodeAt(A);P>=55296&&P<=57343&&(P=65536+((P&1023)<<10)|b.charCodeAt(++A)&1023),P<=127?++T:P<=2047?T+=2:P<=65535?T+=3:T+=4}return T}function Uu(b,T){t().set(b,T)}function Ly(b,T){return b%T>0&&(b+=T-b%T),b}var pt,xi,_i,em,Wu,Vu,Gu,tm,zu;function Er(b){pt=b,a.HEAP8=xi=new Int8Array(b),a.HEAP16=em=new Int16Array(b),a.HEAP32=Vu=new Int32Array(b),a.HEAPU8=_i=new Uint8Array(b),a.HEAPU16=Wu=new Uint16Array(b),a.HEAPU32=Gu=new Uint32Array(b),a.HEAPF32=tm=new Float32Array(b),a.HEAPF64=zu=new Float64Array(b)}var Hu=a.INITIAL_MEMORY||16777216;if(_)se=a.wasmMemory,pt=a.buffer;else if(a.wasmMemory)se=a.wasmMemory;else if(se=new WebAssembly.Memory({initial:Hu/65536,maximum:2147483648/65536,shared:!0}),!(se.buffer instanceof SharedArrayBuffer))throw Q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),y&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");se&&(pt=se.buffer),Hu=pt.byteLength,Er(pt);var eo,cr=[],Hs=[],to=[],rm=[],ju=[],nn=!1,qu=!1;_||Hs.push({func:function(){ul()}});function nm(){if(!_){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)Xu(a.preRun.shift());qs(cr)}}function yi(){nn=!0,!_&&qs(Hs)}function om(){_||qs(to)}function Ku(){_||(qu=!0)}function bt(){if(!_){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;)sm(a.postRun.shift());qs(ju)}}function Xu(b){cr.unshift(b)}function sm(b){ju.unshift(b)}var Ar=0,on=null,ro=null;function am(b){_t(!_,"addRunDependency cannot be used in a pthread worker"),Ar++,a.monitorRunDependencies&&a.monitorRunDependencies(Ar)}function im(b){if(Ar--,a.monitorRunDependencies&&a.monitorRunDependencies(Ar),Ar==0&&(on!==null&&(clearInterval(on),on=null),ro)){var T=ro;ro=null,T()}}a.preloadedImages={},a.preloadedAudios={};function Rr(b){a.onAbort&&a.onAbort(b),_&&console.error("Pthread aborting at "+new Error().stack),b+="",Q(b),rt=!0,We=1,b="abort("+b+"). Build with -s ASSERTIONS=1 for more info.";var T=new WebAssembly.RuntimeError(b);throw l(T),T}function Yu(b,T){return String.prototype.startsWith?b.startsWith(T):b.indexOf(T)===0}var js="data:application/octet-stream;base64,";function Ju(b){return Yu(b,js)}var um="file://";function Qu(b){return Yu(b,um)}var wt="tfjs-backend-wasm-threaded-simd.wasm";Ju(wt)||(wt=R(wt));function Zu(b){try{if(b==wt&&de)return new Uint8Array(de);if(O)return O(b);throw"both async and sync fetching of the wasm failed"}catch(T){Rr(T)}}function lm(){if(!de&&(h||g)){if(typeof fetch=="function"&&!Qu(wt))return fetch(wt,{credentials:"same-origin"}).then(function(b){if(!b.ok)throw"failed to load wasm binary file at '"+wt+"'";return b.arrayBuffer()}).catch(function(){return Zu(wt)});if(D)return new Promise(function(b,T){D(wt,function(A){b(new Uint8Array(A))},T)})}return Promise.resolve().then(function(){return Zu(wt)})}function cm(){var b={a:ef};function T(H,J){var ve=H.exports;if(a.asm=ve,eo=a.asm.F,it=J,!_){var Ze=te.unusedWorkers.length;te.unusedWorkers.forEach(function(Ke){te.loadWasmModuleToWorker(Ke,function(){--Ze||im("wasm-instantiate")})})}}_||am("wasm-instantiate");function A(H){T(H.instance,H.module)}function P(H){return lm().then(function(J){return WebAssembly.instantiate(J,b)}).then(H,function(J){Q("failed to asynchronously prepare wasm: "+J),Rr(J)})}function q(){return!de&&typeof WebAssembly.instantiateStreaming=="function"&&!Ju(wt)&&!Qu(wt)&&typeof fetch=="function"?fetch(wt,{credentials:"same-origin"}).then(function(H){var J=WebAssembly.instantiateStreaming(H,b);return J.then(A,function(ve){return Q("wasm streaming compile failed: "+ve),Q("falling back to ArrayBuffer instantiation"),P(A)})}):P(A)}if(a.instantiateWasm)try{var z=a.instantiateWasm(b,T);return z}catch(H){return Q("Module.instantiateWasm callback failed with error: "+H),!1}return q().catch(l),{}}var pm={10024:function(){throw"Canceled!"},10042:function(b,T){setTimeout(function(){Gy(b,T)},0)}};function el(){te.initRuntime()}function qs(b){for(;b.length>0;){var T=b.shift();if(typeof T=="function"){T(a);continue}var A=T.func;typeof A=="number"?T.arg===void 0?eo.get(A)():eo.get(A)(T.arg):A(T.arg===void 0?null:T.arg)}}function bi(b,T){if(b<=0||b>t().length||b&!0||T<0)return-28;if(T==0)return 0;T>=2147483647&&(T=Infinity);var A=Atomics.load(o(),Zs>>2),P=0;if(A==b){var q=Atomics.compareExchange(o(),Zs>>2,A,0);if(q==A&&(--T,P=1,T<=0))return 1}var z=Atomics.notify(o(),b>>2,T);if(z>=0)return z+P;throw"Atomics.notify returned an unexpected value "+z}a._emscripten_futex_wake=bi;function mm(b){if(_)throw"Internal Error! killThread() can only ever be called from main application thread!";if(!b)throw"Internal Error! Null pthread_ptr in killThread!";o()[b+12>>2]=0;var T=te.pthreads[b];T.worker.terminate(),te.freeThreadData(T),te.runningWorkers.splice(te.runningWorkers.indexOf(T.worker),1),T.worker.pthread=void 0}function fm(b){if(_)throw"Internal Error! cancelThread() can only ever be called from main application thread!";if(!b)throw"Internal Error! Null pthread_ptr in cancelThread!";var T=te.pthreads[b];T.worker.postMessage({cmd:"cancel"})}function dm(b){if(_)throw"Internal Error! cleanupThread() can only ever be called from main application thread!";if(!b)throw"Internal Error! Null pthread_ptr in cleanupThread!";var T=te.pthreads[b];if(T){o()[b+12>>2]=0;var A=T.worker;te.returnWorkerToPool(A)}}var te={unusedWorkers:[],runningWorkers:[],initMainThreadBlock:function(){for(var b=Math.min(4,Math.max(1,(navigator.hardwareConcurrency||1)/2)),T=0;T<b;++T)te.allocateUnusedWorker()},initRuntime:function(){for(var b=oo(228),T=0;T<228/4;++T)s()[b/4+T]=0;o()[b+12>>2]=b;var A=b+152;o()[A>>2]=A;for(var P=oo(512),T=0;T<128;++T)s()[P/4+T]=0;Atomics.store(s(),b+100>>2,P),Atomics.store(s(),b+40>>2,b),Nf(b,!g,1),Vy(b)},initWorker:function(){},pthreads:{},threadExitHandlers:[],setThreadStatus:function(){},runExitHandlers:function(){for(;te.threadExitHandlers.length>0;)te.threadExitHandlers.pop()();_&&Ys()&&Wy()},runExitHandlersAndDeinitThread:function(b,T){Atomics.store(s(),b+56>>2,1),Atomics.store(s(),b+60>>2,0),te.runExitHandlers(),Atomics.store(s(),b+4>>2,T),Atomics.store(s(),b+0>>2,1),bi(b+0,2147483647),Nf(0,0,0)},threadExit:function(b){var T=Ys();T&&(te.runExitHandlersAndDeinitThread(T,b),_&&postMessage({cmd:"exit"}))},threadCancel:function(){te.runExitHandlersAndDeinitThread(Ys(),-1),postMessage({cmd:"cancelDone"})},terminateAllThreads:function(){for(var b in te.pthreads){var T=te.pthreads[b];T&&T.worker&&te.returnWorkerToPool(T.worker)}te.pthreads={};for(var A=0;A<te.unusedWorkers.length;++A){var P=te.unusedWorkers[A];P.terminate()}te.unusedWorkers=[];for(var A=0;A<te.runningWorkers.length;++A){var P=te.runningWorkers[A],T=P.pthread;te.freeThreadData(T),P.terminate()}te.runningWorkers=[]},freeThreadData:function(b){if(!!b){if(b.threadInfoStruct){var T=o()[b.threadInfoStruct+100>>2];o()[b.threadInfoStruct+100>>2]=0,ki(T),ki(b.threadInfoStruct)}b.threadInfoStruct=0,b.allocatedOwnStack&&b.stackBase&&ki(b.stackBase),b.stackBase=0,b.worker&&(b.worker.pthread=null)}},returnWorkerToPool:function(b){te.runWithoutMainThreadQueuedCalls(function(){delete te.pthreads[b.pthread.threadInfoStruct],te.unusedWorkers.push(b),te.runningWorkers.splice(te.runningWorkers.indexOf(b),1),te.freeThreadData(b.pthread),b.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(b){o()[Ky>>2]=0;try{b()}finally{o()[Ky>>2]=1}},receiveObjectTransfer:function(b){},loadWasmModuleToWorker:function(b,T){b.onmessage=function(A){var P=A.data,q=P.cmd;if(b.pthread&&(te.currentProxiedOperationCallerThread=b.pthread.threadInfoStruct),P.targetThread&&P.targetThread!=Ys()){var z=te.pthreads[P.targetThread];z?z.worker.postMessage(A.data,P.transferList):console.error('Internal error! Worker sent a message "'+q+'" to target pthread '+P.targetThread+", but that thread no longer exists!"),te.currentProxiedOperationCallerThread=void 0;return}if(q==="processQueuedMainThreadWork")Sf();else if(q==="spawnThread")al(A.data);else if(q==="cleanupThread")dm(P.thread);else if(q==="killThread")mm(P.thread);else if(q==="cancelThread")fm(P.thread);else if(q==="loaded")b.loaded=!0,T&&T(b),b.runPthread&&(b.runPthread(),delete b.runPthread);else if(q==="print")ee("Thread "+P.threadId+": "+P.text);else if(q==="printErr")Q("Thread "+P.threadId+": "+P.text);else if(q==="alert")alert("Thread "+P.threadId+": "+P.text);else if(q==="exit"){var H=b.pthread&&Atomics.load(s(),b.pthread.threadInfoStruct+64>>2);H&&te.returnWorkerToPool(b)}else if(q==="exitProcess")try{zR(P.returnCode)}catch(J){if(J instanceof Ei)return;throw J}else q==="cancelDone"?te.returnWorkerToPool(b):q==="objectTransfer"?te.receiveObjectTransfer(A.data):A.data.target==="setimmediate"?b.postMessage(A.data):Q("worker sent an unknown command "+q);te.currentProxiedOperationCallerThread=void 0},b.onerror=function(A){Q("pthread sent an error! "+A.filename+":"+A.lineno+": "+A.message)},y&&(b.on("message",function(A){b.onmessage({data:A})}),b.on("error",function(A){b.onerror(A)}),b.on("exit",function(A){})),b.postMessage({cmd:"load",urlOrBlob:a.mainScriptUrlOrBlob||r,wasmMemory:se,wasmModule:it})},allocateUnusedWorker:function(){var b=R("tfjs-backend-wasm-threaded-simd.worker.js");te.unusedWorkers.push(new Worker(b))},getNewWorker:function(){return te.unusedWorkers.length==0&&(te.allocateUnusedWorker(),te.loadWasmModuleToWorker(te.unusedWorkers[0])),te.unusedWorkers.length>0?te.unusedWorkers.pop():null},busySpinWait:function(b){for(var T=performance.now()+b;performance.now()<T;);}};function hm(b,T){jy(b,T),Js(b)}a.establishStackSpace=hm;function gm(){return Qe}a.getNoExitRuntime=gm;function xm(b,T){return eo.get(b)(T)}a.invokeEntryPoint=xm;function _m(b,T,A,P){Rr("Assertion failed: "+yt(b)+", at: "+[T?yt(T):"unknown filename",A,P?yt(P):"unknown function"])}function ym(b,T){var A=_main(b,T)}var no;y?no=function(){var b=process.hrtime();return b[0]*1e3+b[1]/1e6}:_?no=function(){return performance.now()-a.__performance_now_clock_drift}:typeof dateNow!="undefined"?no=dateNow:no=function(){return performance.now()};function bm(b){return o()[By()>>2]=b,b}function wm(b,T){if(_)return sn(1,1,b,T)}function vm(b,T){if(b==T)postMessage({cmd:"processQueuedMainThreadWork"});else if(_)postMessage({targetThread:b,cmd:"processThreadQueue"});else{var A=te.pthreads[b],P=A&&A.worker;if(!P)return;P.postMessage({cmd:"processThreadQueue"})}return 1}function Im(){Rr()}function Cm(b,T,A){var P=Em(T,A);return pm[b].apply(null,P)}function Tm(b,T){}function Sm(b,T,A){if(b<=0||b>t().length||b&!0)return-28;if(h){if(Atomics.load(o(),b>>2)!=T)return-6;for(var q=performance.now(),z=q+A,H=Atomics.exchange(o(),Zs>>2,b);;){if(q=performance.now(),q>z)return H=Atomics.exchange(o(),Zs>>2,0),-73;if(H=Atomics.exchange(o(),Zs>>2,0),H==0)break;if(Sf(),Atomics.load(o(),b>>2)!=T)return-6;H=Atomics.exchange(o(),Zs>>2,b)}return 0}else{var P=Atomics.wait(o(),b>>2,T,A);if(P==="timed-out")return-73;if(P==="not-equal")return-6;if(P==="ok")return 0;throw"Atomics.wait returned an unexpected value "+P}}function km(b,T,A){n().copyWithin(b,T,T+A)}function Nm(){return y?require("os").cpus().length:navigator.hardwareConcurrency}function sn(b,T){for(var A=arguments.length-2,P=Ni(),q=A,z=Qs(q*8),H=z>>3,J=0;J<A;J++){var ve=arguments[2+J];i()[H+J]=ve}var Ze=Hy(b,q,z,T);return Js(P),Ze}var wi=[],vi=[];function Em(b,T){vi.length=0;var A;for(T>>=2;A=n()[b++];){var P=A<105;P&&T&1&&T++,vi.push(P?i()[T++>>1]:o()[T]),++T}return vi}function Am(b,T,A){wi.length=T;for(var P=A>>3,q=0;q<T;q++)wi[q]=i()[P+q];var z=b<0,H=z?pm[-b-1]:Zm[b];return H.apply(null,wi)}function Rm(){return n().length}function $m(b){try{return se.grow(b-pt.byteLength+65535>>>16),Er(se.buffer),1}catch(T){}}function Dm(b){var T=Rm();if(b<=T)return!1;var A=2147483648;if(b>A)return!1;for(var P=1;P<=4;P*=2){var q=T*(1+.2/P);q=Math.min(q,b+100663296);var z=Math.min(A,Ly(Math.max(b,q),65536)),H=$m(z);if(H)return!0}return!1}var ue={inEventHandler:0,removeAllEventListeners:function(){for(var b=ue.eventHandlers.length-1;b>=0;--b)ue._removeHandler(b);ue.eventHandlers=[],ue.deferredCalls=[]},registerRemoveEventListeners:function(){ue.removeEventListenersRegistered||(rm.push(ue.removeAllEventListeners),ue.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(b,T,A){function P(H,J){if(H.length!=J.length)return!1;for(var ve in H)if(H[ve]!=J[ve])return!1;return!0}for(var q in ue.deferredCalls){var z=ue.deferredCalls[q];if(z.targetFunction==b&&P(z.argsList,A))return}ue.deferredCalls.push({targetFunction:b,precedence:T,argsList:A}),ue.deferredCalls.sort(function(H,J){return H.precedence<J.precedence})},removeDeferredCalls:function(b){for(var T=0;T<ue.deferredCalls.length;++T)ue.deferredCalls[T].targetFunction==b&&(ue.deferredCalls.splice(T,1),--T)},canPerformEventHandlerRequests:function(){return ue.inEventHandler&&ue.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!!ue.canPerformEventHandlerRequests())for(var b=0;b<ue.deferredCalls.length;++b){var T=ue.deferredCalls[b];ue.deferredCalls.splice(b,1),--b,T.targetFunction.apply(null,T.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(b,T){for(var A=0;A<ue.eventHandlers.length;++A)ue.eventHandlers[A].target==b&&(!T||T==ue.eventHandlers[A].eventTypeString)&&ue._removeHandler(A--)},_removeHandler:function(b){var T=ue.eventHandlers[b];T.target.removeEventListener(T.eventTypeString,T.eventListenerFunc,T.useCapture),ue.eventHandlers.splice(b,1)},registerOrRemoveHandler:function(b){var T=function(q){++ue.inEventHandler,ue.currentEventHandler=b,ue.runDeferredCalls(),b.handlerFunc(q),ue.runDeferredCalls(),--ue.inEventHandler};if(b.callbackfunc)b.eventListenerFunc=T,b.target.addEventListener(b.eventTypeString,T,b.useCapture),ue.eventHandlers.push(b),ue.registerRemoveEventListeners();else for(var A=0;A<ue.eventHandlers.length;++A)ue.eventHandlers[A].target==b.target&&ue.eventHandlers[A].eventTypeString==b.eventTypeString&&ue._removeHandler(A--)},queueEventHandlerOnThread_iiii:function(b,T,A,P,q){var z=Ni(),H=Qs(12);o()[H>>2]=A,o()[H+4>>2]=P,o()[H+8>>2]=q,kf(0,b,637534208,T,P,H),Js(z)},getTargetThreadForEventCallback:function(b){switch(b){case 1:return 0;case 2:return te.currentProxiedOperationCallerThread;default:return b}},getNodeNameForTarget:function(b){return b?b==window?"#window":b==screen?"#screen":b&&b.nodeName?b.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function Om(b){var T=Zp(b)+1,A=oo(T);return Bu(b,A,T),A}function Fm(b,T,A,P){var q=Ni(),z=Qs(12),H=0;T&&(H=Om(T)),o()[z>>2]=H,o()[z+4>>2]=A,o()[z+8>>2]=P,kf(0,b,657457152,0,H,z),Js(q)}function Pm(b,T,A,P){T=T?yt(T):"",Fm(b,T,A,P)}function Lm(b){return b>2?yt(b):b}var Mm=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function Bm(b){b=Lm(b);var T=Mm[b]||(typeof document!="undefined"?document.querySelector(b):void 0);return T}function Ii(b){return Bm(b)}function tl(b,T,A){var P=Ii(b);if(!P)return-4;if(P.canvasSharedPtr&&(o()[P.canvasSharedPtr>>2]=T,o()[P.canvasSharedPtr+4>>2]=A),P.offscreenCanvas||!P.controlTransferredOffscreen){P.offscreenCanvas&&(P=P.offscreenCanvas);var q=!1;if(P.GLctxObject&&P.GLctxObject.GLctx){var z=P.GLctxObject.GLctx.getParameter(2978);q=z[0]===0&&z[1]===0&&z[2]===P.width&&z[3]===P.height}P.width=T,P.height=A,q&&P.GLctxObject.GLctx.viewport(0,0,T,A)}else if(P.canvasSharedPtr){var H=o()[P.canvasSharedPtr+8>>2];return Pm(H,b,T,A),1}else return-4;return 0}function rl(b,T,A){return _?sn(2,1,b,T,A):tl(b,T,A)}function Um(b,T,A){var P=Ii(b);return P?tl(b,T,A):rl(b,T,A)}function Wm(b){}function Vm(b,T){}function Gm(b){var T=b.getExtension("ANGLE_instanced_arrays");if(T)return b.vertexAttribDivisor=function(A,P){T.vertexAttribDivisorANGLE(A,P)},b.drawArraysInstanced=function(A,P,q,z){T.drawArraysInstancedANGLE(A,P,q,z)},b.drawElementsInstanced=function(A,P,q,z,H){T.drawElementsInstancedANGLE(A,P,q,z,H)},1}function zm(b){var T=b.getExtension("OES_vertex_array_object");if(T)return b.createVertexArray=function(){return T.createVertexArrayOES()},b.deleteVertexArray=function(A){T.deleteVertexArrayOES(A)},b.bindVertexArray=function(A){T.bindVertexArrayOES(A)},b.isVertexArray=function(A){return T.isVertexArrayOES(A)},1}function Hm(b){var T=b.getExtension("WEBGL_draw_buffers");if(T)return b.drawBuffers=function(A,P){T.drawBuffersWEBGL(A,P)},1}function jm(b){return!!(b.multiDrawWebgl=b.getExtension("WEBGL_multi_draw"))}var _e={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},timerQueriesEXT:[],programInfos:{},stringCache:{},unpackAlignment:4,recordError:function(T){_e.lastError||(_e.lastError=T)},getNewId:function(b){for(var T=_e.counter++,A=b.length;A<T;A++)b[A]=null;return T},getSource:function(b,T,A,P){for(var q="",z=0;z<T;++z){var H=P?o()[P+z*4>>2]:-1;q+=yt(o()[A+z*4>>2],H<0?void 0:H)}return q},createContext:function(b,T){var A=b.getContext("webgl",T);if(!A)return 0;var P=_e.registerContext(A,T);return P},registerContext:function(b,T){var A=oo(8);o()[A+4>>2]=Ys();var P={handle:A,attributes:T,version:T.majorVersion,GLctx:b};return b.canvas&&(b.canvas.GLctxObject=P),_e.contexts[A]=P,(typeof T.enableExtensionsByDefault=="undefined"||T.enableExtensionsByDefault)&&_e.initExtensions(P),A},makeContextCurrent:function(b){return _e.currentContext=_e.contexts[b],a.ctx=an=_e.currentContext&&_e.currentContext.GLctx,!(b&&!an)},getContext:function(b){return _e.contexts[b]},deleteContext:function(b){_e.currentContext===_e.contexts[b]&&(_e.currentContext=null),typeof ue=="object"&&ue.removeAllHandlersOnTarget(_e.contexts[b].GLctx.canvas),_e.contexts[b]&&_e.contexts[b].GLctx.canvas&&(_e.contexts[b].GLctx.canvas.GLctxObject=void 0),ki(_e.contexts[b].handle),_e.contexts[b]=null},initExtensions:function(b){if(b||(b=_e.currentContext),!b.initExtensionsDone){b.initExtensionsDone=!0;var T=b.GLctx;Gm(T),zm(T),Hm(T),T.disjointTimerQueryExt=T.getExtension("EXT_disjoint_timer_query"),jm(T);var A=T.getSupportedExtensions()||[];A.forEach(function(P){P.indexOf("lose_context")<0&&P.indexOf("debug")<0&&T.getExtension(P)})}},populateUniformTable:function(b){for(var T=_e.programs[b],A=_e.programInfos[b]={uniforms:{},maxUniformLength:0,maxAttributeLength:-1,maxUniformBlockNameLength:-1},P=A.uniforms,q=an.getProgramParameter(T,35718),z=0;z<q;++z){var H=an.getActiveUniform(T,z),J=H.name;A.maxUniformLength=Math.max(A.maxUniformLength,J.length+1),J.slice(-1)=="]"&&(J=J.slice(0,J.lastIndexOf("[")));var ve=an.getUniformLocation(T,J);if(ve){var Ze=_e.getNewId(_e.uniforms);P[J]=[H.size,Ze],_e.uniforms[Ze]=ve;for(var Ke=1;Ke<H.size;++Ke){var ln=J+"["+Ke+"]";ve=an.getUniformLocation(T,ln),Ze=_e.getNewId(_e.uniforms),_e.uniforms[Ze]=ve}}}}},qm=["default","low-power","high-performance"];function Km(b,T){var A=T>>2,P=o()[A+(24>>2)],q={alpha:!!o()[A+(0>>2)],depth:!!o()[A+(4>>2)],stencil:!!o()[A+(8>>2)],antialias:!!o()[A+(12>>2)],premultipliedAlpha:!!o()[A+(16>>2)],preserveDrawingBuffer:!!o()[A+(20>>2)],powerPreference:qm[P],failIfMajorPerformanceCaveat:!!o()[A+(28>>2)],majorVersion:o()[A+(32>>2)],minorVersion:o()[A+(36>>2)],enableExtensionsByDefault:o()[A+(40>>2)],explicitSwapControl:o()[A+(44>>2)],proxyContextToMainThread:o()[A+(48>>2)],renderViaOffscreenBackBuffer:o()[A+(52>>2)]},z=Ii(b);if(!z||q.explicitSwapControl)return 0;var H=_e.createContext(z,q);return H}function Xm(b,T){return Km(b,T)}var Ks={mappings:{},buffers:[null,[],[]],printChar:function(b,T){var A=Ks.buffers[b];T===0||T===10?((b===1?ee:Q)(zs(A,0)),A.length=0):A.push(T)},varargs:void 0,get:function(){Ks.varargs+=4;var b=o()[Ks.varargs-4>>2];return b},getStr:function(b){var T=yt(b);return T},get64:function(b,T){return b}};function nl(b){return _?sn(3,1,b):0}function ol(b,T,A,P,q){if(_)return sn(4,1,b,T,A,P,q)}function sl(b,T,A,P){if(_)return sn(5,1,b,T,A,P);for(var q=0,z=0;z<A;z++){for(var H=o()[T+z*8>>2],J=o()[T+(z*8+4)>>2],ve=0;ve<J;ve++)Ks.printChar(b,n()[H+ve]);q+=J}return o()[P>>2]=q,0}function Ym(b){var T=te.threadExitHandlers.pop();b&&T()}function Jm(b,T){te.threadExitHandlers.push(function(){eo.get(b)(T)})}function al(b){if(_)throw"Internal Error! spawnThread() can only ever be called from main application thread!";var T=te.getNewWorker();if(T.pthread!==void 0)throw"Internal error!";if(!b.pthread_ptr)throw"Internal error, no pthread ptr!";te.runningWorkers.push(T);for(var A=oo(128*4),P=0;P<128;++P)o()[A+P*4>>2]=0;var q=b.stackBase+b.stackSize,z=te.pthreads[b.pthread_ptr]={worker:T,stackBase:b.stackBase,stackSize:b.stackSize,allocatedOwnStack:b.allocatedOwnStack,threadInfoStruct:b.pthread_ptr},H=z.threadInfoStruct>>2;Atomics.store(s(),H+(64>>2),b.detached),Atomics.store(s(),H+(100>>2),A),Atomics.store(s(),H+(40>>2),z.threadInfoStruct),Atomics.store(s(),H+(80>>2),b.stackSize),Atomics.store(s(),H+(76>>2),q),Atomics.store(s(),H+(104>>2),b.stackSize),Atomics.store(s(),H+(104+8>>2),q),Atomics.store(s(),H+(104+12>>2),b.detached);var J=Uy(),ve=J+40;Atomics.store(s(),H+(172>>2),ve),T.pthread=z;var Ze={cmd:"run",start_routine:b.startRoutine,arg:b.arg,threadInfoStruct:b.pthread_ptr,stackBase:b.stackBase,stackSize:b.stackSize};T.runPthread=function(){Ze.time=performance.now(),T.postMessage(Ze,b.transferList)},T.loaded&&(T.runPthread(),delete T.runPthread)}function Qm(b,T,A,P){if(typeof SharedArrayBuffer=="undefined")return Q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;if(!b)return Q("pthread_create called with a null thread pointer!"),28;var q=[],z=0;if(_&&(q.length===0||z))return zy(687865856,b,T,A,P);if(z)return z;var H=0,J=0,ve=0;T&&T!=-1?(H=o()[T>>2],H+=81920,J=o()[T+8>>2],ve=o()[T+12>>2]!==0):H=2097152;var Ze=J==0;Ze?J=qy(16,H):(J-=H,_t(J>0));for(var Ke=oo(228),ln=0;ln<228>>2;++ln)s()[(Ke>>2)+ln]=0;o()[b>>2]=Ke,o()[Ke+12>>2]=Ke;var ea=Ke+152;o()[ea>>2]=ea;var mt={stackBase:J,stackSize:H,allocatedOwnStack:Ze,detached:ve,startRoutine:A,pthread_ptr:Ke,arg:P,transferList:q};return _?(mt.cmd="spawnThread",postMessage(mt,q)):al(mt),0}function il(b){if(_)return sn(6,1,b);switch(b){case 30:return 16384;case 85:var T=2147483648;return T/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return bm(28),-1}_||te.initMainThreadBlock();var an,Zm=[null,wm,rl,nl,ol,sl,il],ef={e:_m,r:ym,x:vm,b:Im,y:Cm,j:Tm,c:Sm,d:bi,f:no,p:km,z:Nm,u:Am,q:Dm,v:Um,i:Wm,t:Vm,w:Xm,m:nl,n:ol,g:sl,o:el,a:se||a.wasmMemory,k:Ym,l:Jm,h:Qm,s:il},My=cm(),ul=a.___wasm_call_ctors=function(){return(ul=a.___wasm_call_ctors=a.asm.A).apply(null,arguments)},tf=a._init=function(){return(tf=a._init=a.asm.B).apply(null,arguments)},rf=a._register_tensor=function(){return(rf=a._register_tensor=a.asm.C).apply(null,arguments)},nf=a._dispose_data=function(){return(nf=a._dispose_data=a.asm.D).apply(null,arguments)},of=a._dispose=function(){return(of=a._dispose=a.asm.E).apply(null,arguments)},sf=a._Abs=function(){return(sf=a._Abs=a.asm.G).apply(null,arguments)},af=a._Add=function(){return(af=a._Add=a.asm.H).apply(null,arguments)},uf=a._AddN=function(){return(uf=a._AddN=a.asm.I).apply(null,arguments)},lf=a._All=function(){return(lf=a._All=a.asm.J).apply(null,arguments)},cf=a._Any=function(){return(cf=a._Any=a.asm.K).apply(null,arguments)},pf=a._ArgMax=function(){return(pf=a._ArgMax=a.asm.L).apply(null,arguments)},mf=a._AvgPool=function(){return(mf=a._AvgPool=a.asm.M).apply(null,arguments)},ff=a._BatchMatMul=function(){return(ff=a._BatchMatMul=a.asm.N).apply(null,arguments)},df=a._Ceil=function(){return(df=a._Ceil=a.asm.O).apply(null,arguments)},hf=a._ClipByValue=function(){return(hf=a._ClipByValue=a.asm.P).apply(null,arguments)},gf=a._Conv2D=function(){return(gf=a._Conv2D=a.asm.Q).apply(null,arguments)},xf=a._Conv2DBackpropInput=function(){return(xf=a._Conv2DBackpropInput=a.asm.R).apply(null,arguments)},_f=a._Cos=function(){return(_f=a._Cos=a.asm.S).apply(null,arguments)},yf=a._Cosh=function(){return(yf=a._Cosh=a.asm.T).apply(null,arguments)},bf=a._CropAndResize=function(){return(bf=a._CropAndResize=a.asm.U).apply(null,arguments)},wf=a._Cumsum=function(){return(wf=a._Cumsum=a.asm.V).apply(null,arguments)},vf=a._DepthToSpace=function(){return(vf=a._DepthToSpace=a.asm.W).apply(null,arguments)},If=a._DepthwiseConv2dNative=function(){return(If=a._DepthwiseConv2dNative=a.asm.X).apply(null,arguments)},Cf=a._Elu=function(){return(Cf=a._Elu=a.asm.Y).apply(null,arguments)},ll=a._Equal=function(){return(ll=a._Equal=a.asm.Z).apply(null,arguments)},cl=a._Exp=function(){return(cl=a._Exp=a.asm._).apply(null,arguments)},pl=a._FlipLeftRight=function(){return(pl=a._FlipLeftRight=a.asm.$).apply(null,arguments)},Ci=a._Floor=function(){return(Ci=a._Floor=a.asm.aa).apply(null,arguments)},Xs=a._FloorDiv=function(){return(Xs=a._FloorDiv=a.asm.ba).apply(null,arguments)},Tf=a._FusedBatchNorm=function(){return(Tf=a._FusedBatchNorm=a.asm.ca).apply(null,arguments)},Ti=a._FusedConv2D=function(){return(Ti=a._FusedConv2D=a.asm.da).apply(null,arguments)},L=a._FusedDepthwiseConv2D=function(){return(L=a._FusedDepthwiseConv2D=a.asm.ea).apply(null,arguments)},B=a._Gather=function(){return(B=a._Gather=a.asm.fa).apply(null,arguments)},Y=a._GatherNd=function(){return(Y=a._GatherNd=a.asm.ga).apply(null,arguments)},he=a._Greater=function(){return(he=a._Greater=a.asm.ha).apply(null,arguments)},Ve=a._GreaterEqual=function(){return(Ve=a._GreaterEqual=a.asm.ia).apply(null,arguments)},Pe=a._LeakyRelu=function(){return(Pe=a._LeakyRelu=a.asm.ja).apply(null,arguments)},ce=a._Less=function(){return(ce=a._Less=a.asm.ka).apply(null,arguments)},pe=a._LessEqual=function(){return(pe=a._LessEqual=a.asm.la).apply(null,arguments)},nt=a._Log=function(){return(nt=a._Log=a.asm.ma).apply(null,arguments)},$r=a._LogicalAnd=function(){return($r=a._LogicalAnd=a.asm.na).apply(null,arguments)},Dr=a._Max=function(){return(Dr=a._Max=a.asm.oa).apply(null,arguments)},ml=a._MaxPool=function(){return(ml=a._MaxPool=a.asm.pa).apply(null,arguments)},Si=a._Maximum=function(){return(Si=a._Maximum=a.asm.qa).apply(null,arguments)},Et=a._Mean=function(){return(Et=a._Mean=a.asm.ra).apply(null,arguments)},un=a._Min=function(){return(un=a._Min=a.asm.sa).apply(null,arguments)},fl=a._Minimum=function(){return(fl=a._Minimum=a.asm.ta).apply(null,arguments)},nR=a._MirrorPad=function(){return(nR=a._MirrorPad=a.asm.ua).apply(null,arguments)},oR=a._Multiply=function(){return(oR=a._Multiply=a.asm.va).apply(null,arguments)},sR=a._Neg=function(){return(sR=a._Neg=a.asm.wa).apply(null,arguments)},aR=a._NonMaxSuppressionV3=function(){return(aR=a._NonMaxSuppressionV3=a.asm.xa).apply(null,arguments)},iR=a._NonMaxSuppressionV4=function(){return(iR=a._NonMaxSuppressionV4=a.asm.ya).apply(null,arguments)},uR=a._NonMaxSuppressionV5=function(){return(uR=a._NonMaxSuppressionV5=a.asm.za).apply(null,arguments)},lR=a._NotEqual=function(){return(lR=a._NotEqual=a.asm.Aa).apply(null,arguments)},cR=a._OneHot=function(){return(cR=a._OneHot=a.asm.Ba).apply(null,arguments)},pR=a._PadV2=function(){return(pR=a._PadV2=a.asm.Ca).apply(null,arguments)},mR=a._Pow=function(){return(mR=a._Pow=a.asm.Da).apply(null,arguments)},fR=a._Prelu=function(){return(fR=a._Prelu=a.asm.Ea).apply(null,arguments)},dR=a._Prod=function(){return(dR=a._Prod=a.asm.Fa).apply(null,arguments)},hR=a._RealDiv=function(){return(hR=a._RealDiv=a.asm.Ga).apply(null,arguments)},gR=a._Relu=function(){return(gR=a._Relu=a.asm.Ha).apply(null,arguments)},xR=a._Relu6=function(){return(xR=a._Relu6=a.asm.Ia).apply(null,arguments)},_R=a._ResizeBilinear=function(){return(_R=a._ResizeBilinear=a.asm.Ja).apply(null,arguments)},yR=a._Reverse=function(){return(yR=a._Reverse=a.asm.Ka).apply(null,arguments)},bR=a._RotateWithOffset=function(){return(bR=a._RotateWithOffset=a.asm.La).apply(null,arguments)},wR=a._Round=function(){return(wR=a._Round=a.asm.Ma).apply(null,arguments)},vR=a._Rsqrt=function(){return(vR=a._Rsqrt=a.asm.Na).apply(null,arguments)},IR=a._ScatterNd=function(){return(IR=a._ScatterNd=a.asm.Oa).apply(null,arguments)},CR=a._SelectV2=function(){return(CR=a._SelectV2=a.asm.Pa).apply(null,arguments)},TR=a._Sigmoid=function(){return(TR=a._Sigmoid=a.asm.Qa).apply(null,arguments)},SR=a._Sin=function(){return(SR=a._Sin=a.asm.Ra).apply(null,arguments)},kR=a._Softmax=function(){return(kR=a._Softmax=a.asm.Sa).apply(null,arguments)},NR=a._Sqrt=function(){return(NR=a._Sqrt=a.asm.Ta).apply(null,arguments)},ER=a._Square=function(){return(ER=a._Square=a.asm.Ua).apply(null,arguments)},AR=a._SquaredDifference=function(){return(AR=a._SquaredDifference=a.asm.Va).apply(null,arguments)},RR=a._Step=function(){return(RR=a._Step=a.asm.Wa).apply(null,arguments)},$R=a._StridedSlice=function(){return($R=a._StridedSlice=a.asm.Xa).apply(null,arguments)},DR=a._Sub=function(){return(DR=a._Sub=a.asm.Ya).apply(null,arguments)},OR=a._Sum=function(){return(OR=a._Sum=a.asm.Za).apply(null,arguments)},FR=a._Tan=function(){return(FR=a._Tan=a.asm._a).apply(null,arguments)},PR=a._Tanh=function(){return(PR=a._Tanh=a.asm.$a).apply(null,arguments)},LR=a._Tile=function(){return(LR=a._Tile=a.asm.ab).apply(null,arguments)},MR=a._TopK=function(){return(MR=a._TopK=a.asm.bb).apply(null,arguments)},BR=a._Transform=function(){return(BR=a._Transform=a.asm.cb).apply(null,arguments)},UR=a._Transpose=function(){return(UR=a._Transpose=a.asm.db).apply(null,arguments)},WR=a.__FusedMatMul=function(){return(WR=a.__FusedMatMul=a.asm.eb).apply(null,arguments)},oo=a._malloc=function(){return(oo=a._malloc=a.asm.fb).apply(null,arguments)},ki=a._free=function(){return(ki=a._free=a.asm.gb).apply(null,arguments)},By=a.___errno_location=function(){return(By=a.___errno_location=a.asm.hb).apply(null,arguments)},Uy=a._emscripten_get_global_libc=function(){return(Uy=a._emscripten_get_global_libc=a.asm.ib).apply(null,arguments)},Ys=a._pthread_self=function(){return(Ys=a._pthread_self=a.asm.jb).apply(null,arguments)},Wy=a.___pthread_tsd_run_dtors=function(){return(Wy=a.___pthread_tsd_run_dtors=a.asm.kb).apply(null,arguments)},Sf=a._emscripten_main_thread_process_queued_calls=function(){return(Sf=a._emscripten_main_thread_process_queued_calls=a.asm.lb).apply(null,arguments)},VR=a._emscripten_current_thread_process_queued_calls=function(){return(VR=a._emscripten_current_thread_process_queued_calls=a.asm.mb).apply(null,arguments)},Vy=a._emscripten_register_main_browser_thread_id=function(){return(Vy=a._emscripten_register_main_browser_thread_id=a.asm.nb).apply(null,arguments)},Gy=a.__emscripten_do_dispatch_to_thread=function(){return(Gy=a.__emscripten_do_dispatch_to_thread=a.asm.ob).apply(null,arguments)},zy=a._emscripten_sync_run_in_main_thread_4=function(){return(zy=a._emscripten_sync_run_in_main_thread_4=a.asm.pb).apply(null,arguments)},Hy=a._emscripten_run_in_main_runtime_thread_js=function(){return(Hy=a._emscripten_run_in_main_runtime_thread_js=a.asm.qb).apply(null,arguments)},kf=a.__emscripten_call_on_thread=function(){return(kf=a.__emscripten_call_on_thread=a.asm.rb).apply(null,arguments)},GR=a._emscripten_tls_init=function(){return(GR=a._emscripten_tls_init=a.asm.sb).apply(null,arguments)},Nf=a.__emscripten_thread_init=function(){return(Nf=a.__emscripten_thread_init=a.asm.tb).apply(null,arguments)},Ni=a.stackSave=function(){return(Ni=a.stackSave=a.asm.ub).apply(null,arguments)},Js=a.stackRestore=function(){return(Js=a.stackRestore=a.asm.vb).apply(null,arguments)},Qs=a.stackAlloc=function(){return(Qs=a.stackAlloc=a.asm.wb).apply(null,arguments)},jy=a._emscripten_stack_set_limits=function(){return(jy=a._emscripten_stack_set_limits=a.asm.xb).apply(null,arguments)},qy=a._memalign=function(){return(qy=a._memalign=a.asm.yb).apply(null,arguments)},Ky=a.__emscripten_allow_main_runtime_queued_calls=10016,Zs=a.__emscripten_main_thread_futex=11652;a.cwrap=rn,a.PThread=te,a.PThread=te,a.wasmMemory=se,a.ExitStatus=Ei;var dl;function Ei(b){this.name="ExitStatus",this.message="Program terminated with exit("+b+")",this.status=b}ro=function b(){dl||Ef(),dl||(ro=b)};function Ef(b){if(b=b||m,Ar>0)return;if(_){u(a),yi(),postMessage({cmd:"loaded"});return}if(nm(),Ar>0)return;function T(){dl||(dl=!0,a.calledRun=!0,!rt&&(yi(),om(),u(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),bt()))}a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),T()},1)):T()}a.run=Ef;function zR(b,T){if(!(T&&Qe&&b===0)){if(!T&&_)throw postMessage({cmd:"exitProcess",returnCode:b}),new Ei(b);Qe||(te.terminateAllThreads(),We=b,Ku(),a.onExit&&a.onExit(b),rt=!0),d(b,new Ei(b))}}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();return _&&(Qe=!1,te.initWorker()),Ef(),e.ready}}();typeof ap=="object"&&typeof Mg=="object"?Mg.exports=Bg:typeof define=="function"&&define.amd?define([],function(){return Bg}):typeof ap=="object"&&(ap.WasmBackendModuleThreadedSimd=Bg)});var v0=ot((ip,Ug)=>{var Wg=function(){var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(e){e=e||{};var t=typeof e!="undefined"?e:{},n,o;t.ready=new Promise(function(L,B){n=L,o=B});var s={},i;for(i in t)t.hasOwnProperty(i)&&(s[i]=t[i]);var a=[],u="./this.program",l=function(L,B){throw B},c=!1,p=!1,m=!1,f=!1;c=typeof window=="object",p=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f=!c&&!m&&!p;var d="";function h(L){return t.locateFile?t.locateFile(L,d):d+L}var g,y,I,_,N,R;m?(p?d=oi().dirname(d)+"/":d=__dirname+"/",g=function(B,Y){return N||(N=sp()),R||(R=oi()),B=R.normalize(B),N.readFileSync(B,Y?null:"utf8")},I=function(B){var Y=g(B,!0);return Y.buffer||(Y=new Uint8Array(Y)),ee(Y.buffer),Y},process.argv.length>1&&(u=process.argv[1].replace(/\\/g,"/")),a=process.argv.slice(2),process.on("uncaughtException",function(L){if(!(L instanceof Tf))throw L}),process.on("unhandledRejection",nn),l=function(L){process.exit(L)},t.inspect=function(){return"[Emscripten Module object]"}):f?(typeof read!="undefined"&&(g=function(B){return read(B)}),I=function(B){var Y;return typeof readbuffer=="function"?new Uint8Array(readbuffer(B)):(Y=read(B,"binary"),ee(typeof Y=="object"),Y)},typeof scriptArgs!="undefined"?a=scriptArgs:typeof arguments!="undefined"&&(a=arguments),typeof quit=="function"&&(l=function(L){quit(L)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(c||p)&&(p?d=self.location.href:typeof document!="undefined"&&document.currentScript&&(d=document.currentScript.src),r&&(d=r),d.indexOf("blob:")!==0?d=d.substr(0,d.lastIndexOf("/")+1):d="",g=function(L){var B=new XMLHttpRequest;return B.open("GET",L,!1),B.send(null),B.responseText},p&&(I=function(L){var B=new XMLHttpRequest;return B.open("GET",L,!1),B.responseType="arraybuffer",B.send(null),new Uint8Array(B.response)}),y=function(L,B,Y){var he=new XMLHttpRequest;he.open("GET",L,!0),he.responseType="arraybuffer",he.onload=function(){if(he.status==200||he.status==0&&he.response){B(he.response);return}Y()},he.onerror=Y,he.send(null)},_=function(L){document.title=L});var F=t.print||console.log.bind(console),D=t.printErr||console.warn.bind(console);for(i in s)s.hasOwnProperty(i)&&(t[i]=s[i]);s=null,t.arguments&&(a=t.arguments),t.thisProgram&&(u=t.thisProgram),t.quit&&(l=t.quit);var O;t.wasmBinary&&(O=t.wasmBinary);var U=t.noExitRuntime||!0;typeof WebAssembly!="object"&&nn("no native wasm support detected");var M,G=!1,j;function ee(L,B){L||nn("Assertion failed: "+B)}function Q(L){var B=t["_"+L];return ee(B,"Cannot call unknown function "+L+", make sure it is exported"),B}function ie(L,B,Y,he,Ve){var Pe={string:function(Et){var un=0;if(Et!=null&&Et!==0){var fl=(Et.length<<2)+1;un=Ci(fl),it(Et,un,fl)}return un},array:function(Et){var un=Ci(Et.length);return rt(Et,un),un}};function ce(Et){return B==="string"?Qe(Et):B==="boolean"?Boolean(Et):Et}var pe=Q(L),nt=[],$r=0;if(he)for(var Dr=0;Dr<he.length;Dr++){var ml=Pe[Y[Dr]];ml?($r===0&&($r=cl()),nt[Dr]=ml(he[Dr])):nt[Dr]=he[Dr]}var Si=pe.apply(null,nt);return Si=ce(Si),$r!==0&&pl($r),Si}function le(L,B,Y,he){Y=Y||[];var Ve=Y.every(function(ce){return ce==="number"}),Pe=B!=="string";return Pe&&Ve&&!he?Q(L):function(){return ie(L,B,Y,arguments,he)}}var Ce=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function de(L,B,Y){for(var he=B+Y,Ve=B;L[Ve]&&!(Ve>=he);)++Ve;if(Ve-B>16&&L.subarray&&Ce)return Ce.decode(L.subarray(B,Ve));for(var Pe="";B<Ve;){var ce=L[B++];if(!(ce&128)){Pe+=String.fromCharCode(ce);continue}var pe=L[B++]&63;if((ce&224)==192){Pe+=String.fromCharCode((ce&31)<<6|pe);continue}var nt=L[B++]&63;if((ce&240)==224?ce=(ce&15)<<12|pe<<6|nt:ce=(ce&7)<<18|pe<<12|nt<<6|L[B++]&63,ce<65536)Pe+=String.fromCharCode(ce);else{var $r=ce-65536;Pe+=String.fromCharCode(55296|$r>>10,56320|$r&1023)}}return Pe}function Qe(L,B){return L?de(Nt,L,B):""}function se(L,B,Y,he){if(!(he>0))return 0;for(var Ve=Y,Pe=Y+he-1,ce=0;ce<L.length;++ce){var pe=L.charCodeAt(ce);if(pe>=55296&&pe<=57343){var nt=L.charCodeAt(++ce);pe=65536+((pe&1023)<<10)|nt&1023}if(pe<=127){if(Y>=Pe)break;B[Y++]=pe}else if(pe<=2047){if(Y+1>=Pe)break;B[Y++]=192|pe>>6,B[Y++]=128|pe&63}else if(pe<=65535){if(Y+2>=Pe)break;B[Y++]=224|pe>>12,B[Y++]=128|pe>>6&63,B[Y++]=128|pe&63}else{if(Y+3>=Pe)break;B[Y++]=240|pe>>18,B[Y++]=128|pe>>12&63,B[Y++]=128|pe>>6&63,B[Y++]=128|pe&63}}return B[Y]=0,Y-Ve}function it(L,B,Y){return se(L,Nt,B,Y)}function rt(L,B){lr.set(L,B)}function We(L,B){return L%B>0&&(L+=B-L%B),L}var _t,lr,Nt,rn,zs,yt,Qp,Bu,Zp;function Uu(L){_t=L,t.HEAP8=lr=new Int8Array(L),t.HEAP16=rn=new Int16Array(L),t.HEAP32=yt=new Int32Array(L),t.HEAPU8=Nt=new Uint8Array(L),t.HEAPU16=zs=new Uint16Array(L),t.HEAPU32=Qp=new Uint32Array(L),t.HEAPF32=Bu=new Float32Array(L),t.HEAPF64=Zp=new Float64Array(L)}var Ly=t.INITIAL_MEMORY||16777216,pt,xi=[],_i=[],em=[],Wu=[],Vu=!1;_i.push({func:function(){el()}});function Gu(){if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)Hu(t.preRun.shift());on(xi)}function tm(){Vu=!0,on(_i)}function zu(){on(em)}function Er(){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;)eo(t.postRun.shift());on(Wu)}function Hu(L){xi.unshift(L)}function eo(L){Wu.unshift(L)}var cr=0,Hs=null,to=null;function rm(L){cr++,t.monitorRunDependencies&&t.monitorRunDependencies(cr)}function ju(L){if(cr--,t.monitorRunDependencies&&t.monitorRunDependencies(cr),cr==0&&(Hs!==null&&(clearInterval(Hs),Hs=null),to)){var B=to;to=null,B()}}t.preloadedImages={},t.preloadedAudios={};function nn(L){t.onAbort&&t.onAbort(L),L+="",D(L),G=!0,j=1,L="abort("+L+"). Build with -s ASSERTIONS=1 for more info.";var B=new WebAssembly.RuntimeError(L);throw o(B),B}function qu(L,B){return String.prototype.startsWith?L.startsWith(B):L.indexOf(B)===0}var nm="data:application/octet-stream;base64,";function yi(L){return qu(L,nm)}var om="file://";function Ku(L){return qu(L,om)}var bt="tfjs-backend-wasm.wasm";yi(bt)||(bt=h(bt));function Xu(L){try{if(L==bt&&O)return new Uint8Array(O);if(I)return I(L);throw"both async and sync fetching of the wasm failed"}catch(B){nn(B)}}function sm(){if(!O&&(c||p)){if(typeof fetch=="function"&&!Ku(bt))return fetch(bt,{credentials:"same-origin"}).then(function(L){if(!L.ok)throw"failed to load wasm binary file at '"+bt+"'";return L.arrayBuffer()}).catch(function(){return Xu(bt)});if(y)return new Promise(function(L,B){y(bt,function(Y){L(new Uint8Array(Y))},B)})}return Promise.resolve().then(function(){return Xu(bt)})}function Ar(){var L={a:cm};function B(ce,pe){var nt=ce.exports;t.asm=nt,M=t.asm.i,Uu(M.buffer),pt=t.asm.o,ju("wasm-instantiate")}rm("wasm-instantiate");function Y(ce){B(ce.instance)}function he(ce){return sm().then(function(pe){return WebAssembly.instantiate(pe,L)}).then(ce,function(pe){D("failed to asynchronously prepare wasm: "+pe),nn(pe)})}function Ve(){return!O&&typeof WebAssembly.instantiateStreaming=="function"&&!yi(bt)&&!Ku(bt)&&typeof fetch=="function"?fetch(bt,{credentials:"same-origin"}).then(function(ce){var pe=WebAssembly.instantiateStreaming(ce,L);return pe.then(Y,function(nt){return D("wasm streaming compile failed: "+nt),D("falling back to ArrayBuffer instantiation"),he(Y)})}):he(Y)}if(t.instantiateWasm)try{var Pe=t.instantiateWasm(L,B);return Pe}catch(ce){return D("Module.instantiateWasm callback failed with error: "+ce),!1}return Ve().catch(o),{}}function on(L){for(;L.length>0;){var B=L.shift();if(typeof B=="function"){B(t);continue}var Y=B.func;typeof Y=="number"?B.arg===void 0?pt.get(Y)():pt.get(Y)(B.arg):Y(B.arg===void 0?null:B.arg)}}function ro(){nn()}function am(L,B,Y){Nt.copyWithin(L,B,B+Y)}function im(){return Nt.length}function Rr(L){try{return M.grow(L-_t.byteLength+65535>>>16),Uu(M.buffer),1}catch(B){}}function Yu(L){var B=im(),Y=2147483648;if(L>Y)return!1;for(var he=1;he<=4;he*=2){var Ve=B*(1+.2/he);Ve=Math.min(Ve,L+100663296);var Pe=Math.min(Y,We(Math.max(L,Ve),65536)),ce=Rr(Pe);if(ce)return!0}return!1}var js={mappings:{},buffers:[null,[],[]],printChar:function(L,B){var Y=js.buffers[L];B===0||B===10?((L===1?F:D)(de(Y,0)),Y.length=0):Y.push(B)},varargs:void 0,get:function(){js.varargs+=4;var L=yt[js.varargs-4>>2];return L},getStr:function(L){var B=Qe(L);return B},get64:function(L,B){return L}};function Ju(L){return 0}function um(L,B,Y,he,Ve){}function Qu(L,B,Y,he){for(var Ve=0,Pe=0;Pe<Y;Pe++){for(var ce=yt[B+Pe*8>>2],pe=yt[B+(Pe*8+4)>>2],nt=0;nt<pe;nt++)js.printChar(L,Nt[ce+nt]);Ve+=pe}return yt[he>>2]=Ve,0}function wt(){return 6}function Zu(L){return yt[ll()>>2]=L,L}function lm(L){switch(L){case 30:return 16384;case 85:var B=2147483648;return B/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return Zu(28),-1}var cm={a:ro,d:am,e:Yu,f:Ju,c:um,b:Qu,g:wt,h:lm},pm=Ar(),el=t.___wasm_call_ctors=function(){return(el=t.___wasm_call_ctors=t.asm.j).apply(null,arguments)},qs=t._init=function(){return(qs=t._init=t.asm.k).apply(null,arguments)},bi=t._register_tensor=function(){return(bi=t._register_tensor=t.asm.l).apply(null,arguments)},mm=t._dispose_data=function(){return(mm=t._dispose_data=t.asm.m).apply(null,arguments)},fm=t._dispose=function(){return(fm=t._dispose=t.asm.n).apply(null,arguments)},dm=t._Abs=function(){return(dm=t._Abs=t.asm.p).apply(null,arguments)},te=t._Add=function(){return(te=t._Add=t.asm.q).apply(null,arguments)},hm=t._AddN=function(){return(hm=t._AddN=t.asm.r).apply(null,arguments)},gm=t._All=function(){return(gm=t._All=t.asm.s).apply(null,arguments)},xm=t._Any=function(){return(xm=t._Any=t.asm.t).apply(null,arguments)},_m=t._ArgMax=function(){return(_m=t._ArgMax=t.asm.u).apply(null,arguments)},ym=t._AvgPool=function(){return(ym=t._AvgPool=t.asm.v).apply(null,arguments)},no=t._BatchMatMul=function(){return(no=t._BatchMatMul=t.asm.w).apply(null,arguments)},bm=t._Ceil=function(){return(bm=t._Ceil=t.asm.x).apply(null,arguments)},wm=t._ClipByValue=function(){return(wm=t._ClipByValue=t.asm.y).apply(null,arguments)},vm=t._Conv2D=function(){return(vm=t._Conv2D=t.asm.z).apply(null,arguments)},Im=t._Conv2DBackpropInput=function(){return(Im=t._Conv2DBackpropInput=t.asm.A).apply(null,arguments)},Cm=t._Cos=function(){return(Cm=t._Cos=t.asm.B).apply(null,arguments)},Tm=t._Cosh=function(){return(Tm=t._Cosh=t.asm.C).apply(null,arguments)},Sm=t._CropAndResize=function(){return(Sm=t._CropAndResize=t.asm.D).apply(null,arguments)},km=t._Cumsum=function(){return(km=t._Cumsum=t.asm.E).apply(null,arguments)},Nm=t._DepthToSpace=function(){return(Nm=t._DepthToSpace=t.asm.F).apply(null,arguments)},sn=t._DepthwiseConv2dNative=function(){return(sn=t._DepthwiseConv2dNative=t.asm.G).apply(null,arguments)},wi=t._Elu=function(){return(wi=t._Elu=t.asm.H).apply(null,arguments)},vi=t._Equal=function(){return(vi=t._Equal=t.asm.I).apply(null,arguments)},Em=t._Exp=function(){return(Em=t._Exp=t.asm.J).apply(null,arguments)},Am=t._FlipLeftRight=function(){return(Am=t._FlipLeftRight=t.asm.K).apply(null,arguments)},Rm=t._Floor=function(){return(Rm=t._Floor=t.asm.L).apply(null,arguments)},$m=t._FloorDiv=function(){return($m=t._FloorDiv=t.asm.M).apply(null,arguments)},Dm=t._FusedBatchNorm=function(){return(Dm=t._FusedBatchNorm=t.asm.N).apply(null,arguments)},ue=t._FusedConv2D=function(){return(ue=t._FusedConv2D=t.asm.O).apply(null,arguments)},Om=t._FusedDepthwiseConv2D=function(){return(Om=t._FusedDepthwiseConv2D=t.asm.P).apply(null,arguments)},Fm=t._Gather=function(){return(Fm=t._Gather=t.asm.Q).apply(null,arguments)},Pm=t._GatherNd=function(){return(Pm=t._GatherNd=t.asm.R).apply(null,arguments)},Lm=t._Greater=function(){return(Lm=t._Greater=t.asm.S).apply(null,arguments)},Mm=t._GreaterEqual=function(){return(Mm=t._GreaterEqual=t.asm.T).apply(null,arguments)},Bm=t._LeakyRelu=function(){return(Bm=t._LeakyRelu=t.asm.U).apply(null,arguments)},Ii=t._Less=function(){return(Ii=t._Less=t.asm.V).apply(null,arguments)},tl=t._LessEqual=function(){return(tl=t._LessEqual=t.asm.W).apply(null,arguments)},rl=t._Log=function(){return(rl=t._Log=t.asm.X).apply(null,arguments)},Um=t._LogicalAnd=function(){return(Um=t._LogicalAnd=t.asm.Y).apply(null,arguments)},Wm=t._Max=function(){return(Wm=t._Max=t.asm.Z).apply(null,arguments)},Vm=t._MaxPool=function(){return(Vm=t._MaxPool=t.asm._).apply(null,arguments)},Gm=t._Maximum=function(){return(Gm=t._Maximum=t.asm.$).apply(null,arguments)},zm=t._Mean=function(){return(zm=t._Mean=t.asm.aa).apply(null,arguments)},Hm=t._Min=function(){return(Hm=t._Min=t.asm.ba).apply(null,arguments)},jm=t._Minimum=function(){return(jm=t._Minimum=t.asm.ca).apply(null,arguments)},_e=t._MirrorPad=function(){return(_e=t._MirrorPad=t.asm.da).apply(null,arguments)},qm=t._Multiply=function(){return(qm=t._Multiply=t.asm.ea).apply(null,arguments)},Km=t._Neg=function(){return(Km=t._Neg=t.asm.fa).apply(null,arguments)},Xm=t._NonMaxSuppressionV3=function(){return(Xm=t._NonMaxSuppressionV3=t.asm.ga).apply(null,arguments)},Ks=t._NonMaxSuppressionV4=function(){return(Ks=t._NonMaxSuppressionV4=t.asm.ha).apply(null,arguments)},nl=t._NonMaxSuppressionV5=function(){return(nl=t._NonMaxSuppressionV5=t.asm.ia).apply(null,arguments)},ol=t._NotEqual=function(){return(ol=t._NotEqual=t.asm.ja).apply(null,arguments)},sl=t._OneHot=function(){return(sl=t._OneHot=t.asm.ka).apply(null,arguments)},Ym=t._PadV2=function(){return(Ym=t._PadV2=t.asm.la).apply(null,arguments)},Jm=t._Pow=function(){return(Jm=t._Pow=t.asm.ma).apply(null,arguments)},al=t._Prelu=function(){return(al=t._Prelu=t.asm.na).apply(null,arguments)},Qm=t._Prod=function(){return(Qm=t._Prod=t.asm.oa).apply(null,arguments)},il=t._RealDiv=function(){return(il=t._RealDiv=t.asm.pa).apply(null,arguments)},an=t._Relu=function(){return(an=t._Relu=t.asm.qa).apply(null,arguments)},Zm=t._Relu6=function(){return(Zm=t._Relu6=t.asm.ra).apply(null,arguments)},ef=t._ResizeBilinear=function(){return(ef=t._ResizeBilinear=t.asm.sa).apply(null,arguments)},My=t._Reverse=function(){return(My=t._Reverse=t.asm.ta).apply(null,arguments)},ul=t._RotateWithOffset=function(){return(ul=t._RotateWithOffset=t.asm.ua).apply(null,arguments)},tf=t._Round=function(){return(tf=t._Round=t.asm.va).apply(null,arguments)},rf=t._Rsqrt=function(){return(rf=t._Rsqrt=t.asm.wa).apply(null,arguments)},nf=t._ScatterNd=function(){return(nf=t._ScatterNd=t.asm.xa).apply(null,arguments)},of=t._SelectV2=function(){return(of=t._SelectV2=t.asm.ya).apply(null,arguments)},sf=t._Sigmoid=function(){return(sf=t._Sigmoid=t.asm.za).apply(null,arguments)},af=t._Sin=function(){return(af=t._Sin=t.asm.Aa).apply(null,arguments)},uf=t._Softmax=function(){return(uf=t._Softmax=t.asm.Ba).apply(null,arguments)},lf=t._Sqrt=function(){return(lf=t._Sqrt=t.asm.Ca).apply(null,arguments)},cf=t._Square=function(){return(cf=t._Square=t.asm.Da).apply(null,arguments)},pf=t._SquaredDifference=function(){return(pf=t._SquaredDifference=t.asm.Ea).apply(null,arguments)},mf=t._Step=function(){return(mf=t._Step=t.asm.Fa).apply(null,arguments)},ff=t._StridedSlice=function(){return(ff=t._StridedSlice=t.asm.Ga).apply(null,arguments)},df=t._Sub=function(){return(df=t._Sub=t.asm.Ha).apply(null,arguments)},hf=t._Sum=function(){return(hf=t._Sum=t.asm.Ia).apply(null,arguments)},gf=t._Tan=function(){return(gf=t._Tan=t.asm.Ja).apply(null,arguments)},xf=t._Tanh=function(){return(xf=t._Tanh=t.asm.Ka).apply(null,arguments)},_f=t._Tile=function(){return(_f=t._Tile=t.asm.La).apply(null,arguments)},yf=t._TopK=function(){return(yf=t._TopK=t.asm.Ma).apply(null,arguments)},bf=t._Transform=function(){return(bf=t._Transform=t.asm.Na).apply(null,arguments)},wf=t._Transpose=function(){return(wf=t._Transpose=t.asm.Oa).apply(null,arguments)},vf=t.__FusedMatMul=function(){return(vf=t.__FusedMatMul=t.asm.Pa).apply(null,arguments)},If=t._malloc=function(){return(If=t._malloc=t.asm.Qa).apply(null,arguments)},Cf=t._free=function(){return(Cf=t._free=t.asm.Ra).apply(null,arguments)},ll=t.___errno_location=function(){return(ll=t.___errno_location=t.asm.Sa).apply(null,arguments)},cl=t.stackSave=function(){return(cl=t.stackSave=t.asm.Ta).apply(null,arguments)},pl=t.stackRestore=function(){return(pl=t.stackRestore=t.asm.Ua).apply(null,arguments)},Ci=t.stackAlloc=function(){return(Ci=t.stackAlloc=t.asm.Va).apply(null,arguments)};t.cwrap=le;var Xs;function Tf(L){this.name="ExitStatus",this.message="Program terminated with exit("+L+")",this.status=L}to=function L(){Xs||Ti(),Xs||(to=L)};function Ti(L){if(L=L||a,cr>0||(Gu(),cr>0))return;function B(){Xs||(Xs=!0,t.calledRun=!0,!G&&(tm(),zu(),n(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),Er()))}t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),B()},1)):B()}if(t.run=Ti,t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();return Ti(),e.ready}}();typeof ip=="object"&&typeof Ug=="object"?Ug.exports=Wg:typeof define=="function"&&define.amd?define([],function(){return Wg}):typeof ip=="object"&&(ip.WasmBackendModule=Wg)});var so=null,Yy,QR=new Promise(r=>{Yy=r});async function Jy(){return so||QR}function Xe(){if(!so)throw"Flags are not yet set";return so}function Ai(r){if(so)throw"Can not set flags twice.";so=r,Yy(so)}function xl(){return typeof module!="undefined"&&module.exports}function Qy(){return!xl()&&(typeof self!="undefined"||typeof window!="undefined")}function _l(){return Qy()&&typeof window!="undefined"}function Yt(){return Qy()&&typeof window=="undefined"}function Zy(){return!xl()&&!!window.Worker}var Or;(function(r){r.ENGINE_FLAGS="ENGINE_FLAGS",r.RESTRICTED="RESTRICTED",r.UNRESTRICTED="UNRESTRICTED"})(Or||(Or={}));var ZR="/dist/engine.min.js";function eb(){let r=Or.RESTRICTED;typeof RESTRICTED!="undefined"&&(r=RESTRICTED);let e="none";e="0.0.7";let t=_l()?window:null,n=t?t.__q2_OVERWRITE_BACKEND_URL:null,o="NONE",s="NONE",i=r===Or.UNRESTRICTED?o:s,a;Yt()||(xl()?a="":a=n||i);let u=n?null:"sdk/"+e,l=u?a+"/"+u:a,c={IMAGES_URL:l+"/dist/pose_images",MODEL_URL:l+"/dist/models",EXPRESS_MODEL_URL:!0,BUNDLE_URL:l+ZR,WASM_URL:l+"/dist/tfjs_wasm",RESTRICTION_MODE:r,VERSION:e};Yt()||Ai(c)}eb();var Le={FOCUS_GAIN:"FOCUS_GAIN",FOCUS_LOSS:"FOCUS_LOSS",LATENCY:"LATENCY",TBR:"TBR",WARMUP_FINISHED:"WARMUP_FINISHED",RESULT:"RESULT",LOST:"LOST",INITIALIZATION_COMPLETE:"INITIALIZATION_COMPLETE"},e2={RESULT:"RESULT",LOST:"LOST",LATENCY:"LATENCY"};function tb(r){switch(r.type){case Le.RESULT:case Le.LOST:case Le.LATENCY:return!0;default:return!1}}var rb={CONFIDENCE:"CONFIDENCE",DISTANCE:"DISTANCE",MISC:"MISC",__NONE:"__NONE"};var Ri=class{constructor(){this.cbs_=[],this.Initialize_()}IsVisible(){return document.visibilityState==="visible"}SubscribeVisibilityChange(e){return this.cbs_.push(e),this.cbs_.length-1}Unsubscribe(e){this.cbs_[e]=null}Initialize_(){document.addEventListener("visibilitychange",()=>{let e=this.IsVisible();for(let t of this.cbs_)t&&t(e)})}};var Af=class{constructor(e,t,n){this.focusChecker_=new Ri,this.dispatcher_=e,this.gainCb_=n,this.lossCb_=t,this.Start_()}Start_(){this.dispatcher_.Subscribe(e=>{e.type===Le.INITIALIZATION_COMPLETE&&(this.focusChecker_.IsVisible()?this.gainCb_({type:Le.FOCUS_GAIN}):this.lossCb_({type:Le.FOCUS_LOSS}),this.focusChecker_.SubscribeVisibilityChange(t=>{t?this.gainCb_({type:Le.FOCUS_GAIN}):this.lossCb_({type:Le.FOCUS_LOSS})}))})}};var Rf=class{constructor(e,t){this.cb_=t,this.dispatcher_=e,this.dispatcher_.Subscribe(n=>this.HandleEvent_(n)),this.disabled_=!1,this.lastDate_=null}HandleEvent_(e){switch(e.type){case Le.FOCUS_LOSS:{this.disabled_=!0,this.lastDate_=null;break}case Le.FOCUS_GAIN:{this.disabled_=!1;break}case Le.LATENCY:{if(this.disabled_)break;if(!this.lastDate_){this.lastDate_=performance.now();return}let t=this.lastDate_;this.lastDate_=performance.now();let n=+this.lastDate_-+t;this.cb_({type:Le.TBR,tbrMS:n})}}}};var $f=class{constructor(e){this.dispatcher_=e,this.dispatcher_.Subscribe(t=>this.HandleEvent_(t)),this.finished_=!1}HandleEvent_(e){e.type===Le.WARMUP_FINISHED&&(this.finished_=!0)}IsWarmup(){return!this.finished_}},Df=class{constructor(e,t,n){this.n_=t.n,this.cb_=n,this.dispatcher_=e,this.dispatcher_.Subscribe(o=>this.HandleEvent_(o)),this.numProcessed_=0,this.n_===0&&this.EmitEvent_()}EmitEvent_(){this.cb_({type:Le.WARMUP_FINISHED})}HandleEvent_(e){switch(e.type){case Le.LATENCY:this.numProcessed_+=1,this.numProcessed_===this.n_&&this.EmitEvent_()}}};var nb=class{constructor(){this.subscribers_=[]}Add(e){let t=this.subscribers_.length;return this.subscribers_.push(e),()=>{this.subscribers_[t]=null}}Publish(e){for(let t of this.subscribers_)t!==null&&t(e)}},Of=class{constructor(){this.pool_=new nb,this.cbs_=[],this.queuedEvents_=0}Subscribe(e){this.pool_.Add(e)}Publish(e){this.queuedEvents_+=1,Promise.resolve().then(()=>{this.pool_.Publish(e),this.queuedEvents_-=1,this.queuedEvents_===0&&this.NotifyEmptyQueueSubscribers_()})}OnEmptyQueue(e){this.cbs_.push(e),this.queuedEvents_===0&&this.NotifyEmptyQueueSubscribers_()}NotifyEmptyQueueSubscribers_(){for(let e of this.cbs_)e();this.cbs_=[]}};var t2={ENGINE_ALREADY_RUNNING:"EngineAlreadyRunning"},Ff=class extends Error{constructor(){super("Tried to start an engine while another one is still running.");this.name=t2.ENGINE_ALREADY_RUNNING}};var r2=0,n2=1,je;(function(r){r.CANVAS="CANVAS",r.TYPED_ARRAY="TYPED_ARRAY",r.ARRAY="ARRAY",r.BITMAP="BITMAP"})(je||(je={}));function ob(r,e){let t=r;return{coords:e.coords,confidence:e.confidence,flip:1-e.classes[r2]>=t.flipProb,containsHand:1-e.classes[n2]>=t.containsHandProb}}function sb(r,e){let t=r;return{poses:{pinch:!e.restricted&&e.classes[0]>=t.pinchClosedProb,fist:!e.restricted&&e.classes[1]>=t.fistProb},coords:e.coords,confidence:e.confidence,containsHand:1-e.classes[2]>=t.containsHandProb,flip:e.classes[3]>=t.flipProb}}var Fr=class{Init(e,t,n,o,s){this.originalWidth_=e,this.originalHeight_=t,this.resizeWidth_=n,this.resizeHeight_=o,this.pad_=s,this.canvas_=document.createElement("canvas"),this.canvas_.transferControlToOffscreen&&(this.canvas_=this.canvas_.transferControlToOffscreen()),this.canvas_.width=n,this.canvas_.height=o,this.canvas_.getContext("2d")}async Preprocess(e,t){let n=this.canvas_,o={type:je.CANVAS,canvas:n};if(this.pad_){let s=JSON.parse(JSON.stringify(t)),i=this.originalWidth_*(s.bottomRight[0]-s.topLeft[0]),a=this.originalHeight_*(s.bottomRight[1]-s.topLeft[1]),u=Math.abs(i-a);i>a?(s.topLeft[1]-=u/2/this.originalHeight_,s.bottomRight[1]+=u/2/this.originalHeight_):i<a&&(s.topLeft[0]-=u/2/this.originalWidth_,s.bottomRight[0]+=u/2/this.originalWidth_),this.ProcessInternal_(e,n,s);let l=n.getContext("2d");if(l.setTransform(1,0,0,1,0,0),i>a){let c=1-a/i;l.clearRect(0,0,this.resizeWidth_,c/2*this.resizeHeight_),l.clearRect(0,this.resizeHeight_-this.resizeHeight_*c/2,this.resizeWidth_,c/2*this.resizeHeight_)}else if(i<a){let c=1-i/a;l.clearRect(0,0,c/2*this.resizeWidth_,this.resizeHeight_),l.clearRect(this.resizeWidth_-this.resizeWidth_*c/2,0,c/2*this.resizeWidth_,this.resizeHeight_)}return o}else return this.ProcessInternal_(e,n,t),o}Reset_(e){let t=e.getContext("2d");t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,this.resizeWidth_,this.resizeHeight_)}ProcessInternal_(e,t,n){let o=t.getContext("2d");this.Reset_(t);let{topLeft:s,bottomRight:i,rotationCenter:a,rotationInRadians:u,flip:l}=n,c=(i[0]-s[0])*this.originalWidth_+1,p=(i[1]-s[1])*this.originalHeight_+1,m=this.resizeWidth_/c,f=this.resizeHeight_/p;o.scale(m,f);let d=[s[0]*this.originalWidth_,s[1]*this.originalHeight_];o.translate(-d[0],-d[1]);let h=[a[0]*this.originalWidth_,a[1]*this.originalHeight_];o.translate(h[0],h[1]),o.rotate(u),o.translate(-h[0],-h[1]),l&&o.scale(-1,1);let g=0,y=0,I=this.originalWidth_,_=this.originalHeight_;l&&(g=-(g+I)),o.drawImage(e,0,0,this.originalWidth_,this.originalHeight_,g,y,I,_)}};var Jt;(function(r){r.CANVAS_API="CANVAS_API",r.NATIVE_WEBGL="NATIVE_WEBGL",r.CANVAS_API_TO_TYPED="CANVAS_API_TO_TYPED",r.TF="TF"})(Jt||(Jt={}));function Pf(r,e,t,n){let o=t,s=r*(o.bottomRight[0]-o.topLeft[0]),i=e*(o.bottomRight[1]-o.topLeft[1]);for(let a of n)if(s>i){let u=(s-i)/s;a[1]-=u/2,a[1]*=1/(1-u)}else if(s<i){let u=(i-s)/i;a[0]-=u/2,a[0]*=1/(1-u)}}function yl(r,e,t){let n=[];for(let o of r)n.push([o[0]*(e-1),o[1]*(t-1)]);return n}function ab(r){let e=0;for(let n=0;n<r.length;++n)e+=Math.pow(r[n],2);return Math.sqrt(e)}function Pr(r,e){return ab(bl(r,e))}function bl(r,e){if(r.length!==e.length)throw"Unequal length vectors";let t=[];for(let n=0;n<r.length;++n)t.push(r[n]-e[n]);return t}function Lf(r,e){if(r.length!==e.length)throw"Unequal length vectors";let t=[];for(let n=0;n<r.length;++n)t.push(r[n]+e[n]);return t}function wl(r,e){if(r.length!==e.length)throw"Unequal length vectors";let t=[];for(let n=0;n<r.length;++n)t.push(r[n]*e[n]);return t}function vl(r,e){if(r.length!==e.length)throw"Unequal length vectors";let t=[];for(let n=0;n<r.length;++n)t.push(r[n]/e[n]);return t}function ib(r){let e=o2(r),t=[];for(let n=0;n<r.length;++n)t.push(r[n]/e);return t}function o2(r){let e=0;for(let n=0;n<r.length;++n)e+=Math.pow(r[n],2);return Math.sqrt(e)}var $i=class{constructor(e,t,n){this.rotationCenter_=e,this.rotationInRadians_=t,this.aspectRatio_=n,this.aspectRatioAwareRotationCenter_=null,this.rotMat_=null,this.reverseRotMat_=null,this.Initialize_()}Initialize_(){let e=this.aspectRatio_.width/this.aspectRatio_.height;this.aspectRatioAwareRotationCenter_=[this.rotationCenter_[0]*e,this.rotationCenter_[1]],this.rotMat_=lb(this.aspectRatioAwareRotationCenter_,-ub(this.rotationInRadians_),1),this.reverseRotMat_=lb(this.aspectRatioAwareRotationCenter_,ub(this.rotationInRadians_),1)}Apply(e){return this.ApplyInternal_(e,!1)}ApplyReverse(e){return this.ApplyInternal_(e,!0)}ApplyInternal_(e,t){let n=this.aspectRatio_.width/this.aspectRatio_.height,o=[];for(let u of e){let l=wl(u,[n,1]);o.push(l)}let s=t?this.reverseRotMat_:this.rotMat_,i=s2(s,o),a=[];for(let u of i){let l=vl(u,[n,1]);a.push(l)}return a}};function a2(r){return r*(Math.PI/180)}function ub(r){return r*(180/Math.PI)}function lb(r,e,t){let n=[[0,0,0],[0,0,0]],o=a2(e),s=Math.cos(o),i=Math.sin(o),a=t*s,u=t*i;return n[0][0]=a,n[0][1]=u,n[0][2]=(1-a)*r[0]-u*r[1],n[1][0]=-u,n[1][1]=a,n[1][2]=u*r[0]+(1-a)*r[1],n}function i2(r,e){if(r.length===0||r[0].length===0)throw"empty matrix";if(r[0].length!==e.length)throw"matrix dimension mismatch";let t=[];for(let n=0;n<r.length;++n){let o=0;for(let s=0;s<r[0].length;++s)o+=r[n][s]*e[s];t.push(o)}return t}function u2(r,e){return e=[e[0],e[1],1],i2(r,e)}function s2(r,e){let t=[];for(let n of e)t.push(u2(r,n));return t}function cb(r,e){if(r.length!==2)throw"Wrong box dimension";let t=r[1][0]-r[0][0],n=r[1][1]-r[0][1],o=[];for(let s of e)o.push([r[0][0]+s[0]*t,r[0][1]+s[1]*n]);return o}function pb(r,e){if(r.length!==2)throw"Wrong box dimension";let t=[],n=r[1][0]-r[0][0],o=r[1][1]-r[0][1],s=1-n,i=1-o,a=(u,l,c)=>(u-l)*(1/(1-c));for(let u of e)t.push([a(u[0],r[0][0],s),a(u[1],r[0][1],i)]);return t}function mb(r){let e=null,t=null,n=null,o=null;for(let s of r){if(e===null){e=s,t=s,n=s,o=s;continue}s[0]<e[0]&&(e=s),s[1]<n[1]&&(n=s),s[0]>t[0]&&(t=s),s[1]>o[1]&&(o=s)}return{minX:e,maxX:t,minY:n,maxY:o}}function fb(){return[[1,0,0],[0,1,0],[0,0,1]]}function Il(r,e){return[[1,0,r],[0,1,e],[0,0,1]]}function db(r,e){let t=Math.cos(r),n=Math.sin(r),o=e.width/e.height;return[[t,n/o,0],[-n*o,t,0],[0,0,1]]}function hb(r,e){return[[r,0,0],[0,e,0],[0,0,1]]}function ao(r,e){let t=[];for(let n=0;n<r.length;++n){t.push([]);for(let o=0;o<e[0].length;++o){t[n].push(0);for(let s=0;s<r.length;++s)t[n][o]+=r[n][s]*e[s][o]}}return t}function gb(r){let e=[];for(let t=0;t<r[0].length;++t){e.push([]);for(let n=0;n<r.length;++n)e[t].push(r[n][t])}return e}var Mf=class{constructor(e){this.n_=e,this.values_=new Set,this.sum_=0}Add(e){if(this.Size()==this.n_){let t=this.values_.keys().next().value;this.values_.delete(t),this.sum_-=t.v}this.values_.add({v:e}),this.sum_+=e}Get(){return this.Size()===0?0:this.sum_/this.Size()}Size(){return this.values_.size}Clear(){this.values_=new Set,this.sum_=0}};var Lr=class{constructor(e){this.n_=e,this.timestamps_=new Map,this.htmlElements_=new Map,this.movingAverages_=new Map}Start(e){this.CreateElementIfNotExists_(e),this.CreateTimestamp_(e)}End(e){this.timestamps_.has(e)||console.warn("Deteced end without start. ("+e+")");let t=this.timestamps_.get(e),n=+new Date-+t,o=this.movingAverages_.get(e);o.Add(n);let s=Math.round(o.Get());this.htmlElements_.get(e).innerText=e+": "+this.n_+"-avg "+s,this.timestamps_.delete(e)}CreateElementIfNotExists_(e){if(!this.htmlElements_.has(e)){let t=document.createElement("div");document.body.appendChild(t),this.htmlElements_.set(e,t)}}CreateTimestamp_(e){this.movingAverages_.has(e)||this.movingAverages_.set(e,new Mf(this.n_)),this.timestamps_.has(e)&&console.warn("Deteced duplicate start."),this.timestamps_.set(e,new Date)}};var io;(function(r){r.SYNC_PIXELS="SYNC_PIXELS",r.ASYNC_PIXELS="ASYNC_PIXELS",r.BITMAP="BITMAP"})(io||(io={}));function l2(r,e,t){let n=fb();n=ao(n,Il(r.rotationCenter[0],r.rotationCenter[1])),n=ao(n,db(r.rotationInRadians,{width:e,height:t})),n=ao(n,Il(-r.rotationCenter[0],-r.rotationCenter[1])),n=ao(n,Il(r.topLeft[0],r.topLeft[1]));let o=r.bottomRight[0]-r.topLeft[0],s=r.bottomRight[1]-r.topLeft[1];return n=ao(n,hb(o,s)),n}var c2=`
attribute vec2 a_position;
attribute vec2 a_texCoord;

varying vec2 v_texCoord;

void main() {
   vec2 zeroToTwo = a_position * 2.0;
   vec2 clipSpace = zeroToTwo - 1.0;
   gl_Position = vec4(clipSpace, 0, 1);
   v_texCoord = a_texCoord;
}
`,p2=`
precision mediump float;

// our texture
uniform sampler2D u_image;

// the texCoords passed in from the vertex shader.
varying vec2 v_texCoord;

void main() {
   gl_FragColor = texture2D(u_image, v_texCoord);
}
`;function m2(r,e,t,n){return new Promise((o,s)=>{function i(){let a=r.clientWaitSync(e,t,0);if(a==r.TIMEOUT_EXPIRED||a===r.WAIT_FAILED){setTimeout(i,n);return}o()}i()})}async function f2(r,e,t,n,o){let s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);return r.flush(),await m2(r,s,0,3),r.deleteSync(s),r.getBufferSubData(e,n,o),e}var xb=class{constructor(e,t){this.buf_=e.createBuffer(),this.gl_=e,this.numBytes_=t,e.bindBuffer(e.PIXEL_PACK_BUFFER,this.buf_),e.bufferData(e.PIXEL_PACK_BUFFER,this.numBytes_,e.STREAM_READ)}async Read(e,t,n,o,s,i,a){let u=this.gl_;return u.bindBuffer(u.PIXEL_PACK_BUFFER,this.buf_),u.readPixels(e,t,n,o,s,i,0),await f2(u,u.PIXEL_PACK_BUFFER,this.buf_,0,a),a}};var Bf=class{Init(e,t,n,o,s){if(this.prof_=new Lr(100),this.originalWidth_=e,this.originalHeight_=t,this.resizeWidth_=n,this.resizeHeight_=o,this.srcCanvas_=document.createElement("canvas"),this.procCanvas_=document.createElement("canvas"),this.procCanvas_.transferControlToOffscreen&&(this.procCanvas_=this.procCanvas_.transferControlToOffscreen()),this.procCanvas_.width=this.resizeWidth_,this.procCanvas_.height=this.resizeHeight_,this.readMode_=io.SYNC_PIXELS,this.returnRawCanvas_=!1,this.gl_=this.procCanvas_.getContext("webgl2",{alpha:!0,desynchronized:!1,powerPreference:"high-performance",preserveDrawingBuffer:!1}),!this.gl_)throw"not supported yet";if(this.preproc_=new Fr,this.preproc_.Init(e,t,n,o,s),this.readMode_===io.ASYNC_PIXELS&&(this.asyncReader_=new xb(this.gl_,this.resizeWidth_*this.resizeHeight_*4)),this.buffer_=new Uint8Array(this.resizeWidth_*this.resizeHeight_*3),this.rgbaBuffer_=new Uint8Array(this.resizeWidth_*this.resizeHeight_*4),s)throw"not yet implemented";this.PrepareWebgl()}async Preprocess(e,t){return this.ThreadSafePreprocessInternal_(e,t)}PrepareWebgl(){let e=this.gl_;this.CreateProgram_(),this.positionLocation_=this.gl_.getAttribLocation(this.glProgram_,"a_position"),this.texcoordLocation_=this.gl_.getAttribLocation(this.glProgram_,"a_texCoord"),this.gl_.viewport(0,0,this.resizeWidth_,this.resizeHeight_),this.gl_.clearColor(0,0,0,0),this.gl_.clear(this.gl_.COLOR_BUFFER_BIT),this.texture_=this.gl_.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture_),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.useProgram(this.glProgram_),this.texCoordBuffer_=e.createBuffer(),this.positionBuffer_=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer_),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),e.STATIC_DRAW),e.enableVertexAttribArray(this.positionLocation_),e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer_),e.vertexAttribPointer(this.positionLocation_,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(this.texcoordLocation_),e.bindBuffer(e.ARRAY_BUFFER,this.texCoordBuffer_),e.vertexAttribPointer(this.texcoordLocation_,2,e.FLOAT,!1,0,0)}async ThreadSafePreprocessInternal_(e,t){let n=this.gl_;n.bindBuffer(n.ARRAY_BUFFER,this.texCoordBuffer_);let o=this.ComputeTexPositions_(t,this.originalWidth_,this.originalHeight_);if(n.bufferData(n.ARRAY_BUFFER,new Float32Array(o),n.DYNAMIC_DRAW),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e),n.drawArrays(n.TRIANGLES,0,6),n.flush(),this.returnRawCanvas_)return{type:je.CANVAS,canvas:this.procCanvas_};if(this.readMode_===io.SYNC_PIXELS)n.readPixels(0,0,this.resizeWidth_,this.resizeHeight_,n.RGBA,n.UNSIGNED_BYTE,this.rgbaBuffer_);else if(this.readMode_===io.ASYNC_PIXELS)await this.asyncReader_.Read(0,0,this.resizeWidth_,this.resizeHeight_,n.RGBA,n.UNSIGNED_BYTE,this.rgbaBuffer_);else if(this.readMode_===io.BITMAP){let s=this.procCanvas_.transferToImageBitmap();return{type:je.BITMAP,data:s,shape:[this.resizeWidth_,this.resizeHeight_,3],dtype:"int32"}}for(let s=0;s<this.resizeWidth_*this.resizeHeight_;s++)for(let i=0;i<3;++i)this.buffer_[s*3+i]=this.rgbaBuffer_[s*4+i];return{type:je.TYPED_ARRAY,data:this.buffer_,shape:[this.resizeWidth_,this.resizeHeight_,3],dtype:"int32"}}CreateProgram_(){let e=this.gl_;if(this.glProgram_=e.createProgram(),e.attachShader(this.glProgram_,this.CreateVertexShader_()),e.attachShader(this.glProgram_,this.CreateFragmentShader_()),e.linkProgram(this.glProgram_),!e.getProgramParameter(this.glProgram_,e.LINK_STATUS)){let n=e.getProgramInfoLog(this.glProgram_);throw"Error in program linking:"+n}}CreateVertexShader_(){return this.CreateShader_(this.gl_.VERTEX_SHADER,c2)}CreateFragmentShader_(){return this.CreateShader_(this.gl_.FRAGMENT_SHADER,p2)}CreateShader_(e,t){let n=this.gl_,o=n.createShader(e);if(n.shaderSource(o,t),n.compileShader(o),!n.getShaderParameter(o,n.COMPILE_STATUS))throw n.getShaderInfoLog(o);return o}ComputeTexPositions_(e,t,n){let o=l2(e,t,n),i=gb(ao(o,[[0,1,0,1],[0,0,1,1],[1,1,1,1]]));for(let u of i)u.splice(2);if(e.flip)for(let u of i)u[0]=1-u[0];return[...i[0],...i[1],...i[2],...i[2],...i[1],...i[3]]}};var Uf=class{Init(e,t,n,o,s){this.preproc_=new Fr,this.preproc_.Init(e,t,n,o,s),this.resizeWidth_=n,this.resizeHeight_=o,this.pad_=s,this.prof_=new Lr(100),this.debug_=!1,this.resultBuffer_=new Uint8Array(this.resizeWidth_*this.resizeHeight_*3)}async Preprocess(e,t){let o=(await this.preproc_.Preprocess(e,t)).canvas.getContext("2d").getImageData(0,0,this.resizeWidth_,this.resizeHeight_);for(let s=0;s<this.resizeWidth_*this.resizeHeight_;s++)for(let i=0;i<3;++i)this.resultBuffer_[s*3+i]=o.data[s*4+i];return{type:je.TYPED_ARRAY,data:this.resultBuffer_,shape:[this.resizeWidth_,this.resizeHeight_,3],dtype:"int32"}}};var d2=1e-7,h2=1e-4,ra=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},cn=class{refCount(e){return Ut("refCount")}incRef(e){return Ut("incRef")}timerAvailable(){return!0}time(e){return Ut("time")}read(e){return Ut("read")}readSync(e){return Ut("readSync")}numDataIds(){return Ut("numDataIds")}disposeData(e,t){return Ut("disposeData")}write(e,t,n){return Ut("write")}move(e,t,n,o,s){return Ut("move")}memory(){return Ut("memory")}floatPrecision(){return Ut("floatPrecision")}epsilon(){return this.floatPrecision()===32?d2:h2}dispose(){return Ut("dispose")}};function Ut(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function _b(r){let e=r.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Cl(r,e,t)}function g2(r,e){if(r.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${e.length}`);let t=r.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Cl(r,t,n),Cl(e,t,n)}function na(r,e,t){return Math.max(r,Math.min(e,t))}function x2(r){return r%2==0?r:r+1}function Cl(r,e,t){let n=r[e];r[e]=r[t],r[t]=n}function _2(r){let e=0;for(let t=0;t<r.length;t++)e+=r[t];return e}function y2(r,e){let t=Math.random();return e*t+(1-t)*r}function b2(r,e){let t=0;for(let n=0;n<r.length;n++){let o=Number(r[n])-Number(e[n]);t+=o*o}return t}function E(r,e){if(!r)throw new Error(typeof e=="string"?e:e())}function Wf(r,e,t=""){E(pr(r,e),()=>t+` Shapes ${r} and ${e} must match`)}function Di(r){E(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function pn(r,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(r)||At(r)&&!t)for(let n=0;n<r.length;++n)pn(r[n],e,t);else e.push(r);return e}function Se(r){if(r.length===0)return 1;let e=r[0];for(let t=1;t<r.length;t++)e*=r[t];return e}function w2(r){return r.length===0}function pr(r,e){if(r===e)return!0;if(r==null||e==null||r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function Re(r){return r%1==0}function v2(r){if(Math.tanh!=null)return Math.tanh(r);if(r===Infinity)return 1;if(r===-Infinity)return-1;{let e=Math.exp(2*r);return(e-1)/(e+1)}}function I2(r){let e=Math.ceil(Math.sqrt(r));return[e,Math.ceil(r/e)]}function C2(r){let e=new Uint32Array(r);for(let t=0;t<r;++t)e[t]=t;return _b(e),e}function uo(r,e){return e<=r.length?r:r+" ".repeat(e-r.length)}function T2(r,e=n=>0,t){return new Promise((n,o)=>{let s=0,i=()=>{if(r()){n();return}s++;let a=e(s);if(t!=null&&s>=t){o();return}setTimeout(i,a)};i()})}function S2(r,e){let t=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)t*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${r}`);return r}if(t===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(e%t!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);let o=r.slice();return o[n]=e/t,o}function yb(r,e){let t=e.length;return r=r==null?e.map((n,o)=>o):[].concat(r),E(r.every(n=>n>=-t&&n<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${r}`),E(r.every(n=>Re(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?t+n:n)}function Vf(r,e){let t=[],n=[],o=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||o?null:yb(e,r).sort(),i=0;for(let a=0;a<r.length;++a){if(s!=null){if(s[i]===a&&r[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${r[a]}' is not 1`);(s[i]==null||s[i]>a)&&r[a]===1&&(t.push(r[a]),n.push(a)),s[i]<=a&&i++}r[a]!==1&&(t.push(r[a]),n.push(a))}return{newShape:t,keptDims:n}}function k2(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${r}`);return t}function Gf(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else if(r==="string")t=new Array(e);else throw new Error(`Unknown data type ${r}`);return t}function zf(r,e){for(let t=0;t<r.length;t++){let n=r[t];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${e} being uploaded contains ${n}.`)}}function Hf(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function N2(r,e){return!(e==="complex64"||e==="float32"&&r!=="complex64"||e==="int32"&&r!=="float32"&&r!=="complex64"||e==="bool"&&r==="bool")}function At(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array}function Tl(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function jf(r){if(r==null)return 0;let e=0;return r.forEach(t=>e+=t.length),e}function oa(r){return typeof r=="string"||r instanceof String}function bb(r){return typeof r=="boolean"}function wb(r){return typeof r=="number"}function sa(r){return Array.isArray(r)?sa(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array?"int32":wb(r)?"float32":oa(r)?"string":bb(r)?"bool":"float32"}function Sl(r){return!!(r&&r.constructor&&r.call&&r.apply)}function aa(r,e){for(let t=e;t<r;++t)if(r%t==0)return t;return r}function mr(r){let e=r.length;if(e<2)return[];let t=new Array(e-1);t[e-2]=r[e-1];for(let n=e-3;n>=0;--n)t[n]=t[n+1]*r[n+1];return t}function vb(r,e,t,n=!1){let o=new Array;if(e.length===1){let s=e[0]*(n?2:1);for(let i=0;i<s;i++)o[i]=t[r+i]}else{let s=e[0],i=e.slice(1),a=i.reduce((u,l)=>u*l)*(n?2:1);for(let u=0;u<s;u++)o[u]=vb(r+u*a,i,t,n)}return o}function lo(r,e,t=!1){if(r.length===0)return e[0];let n=r.reduce((o,s)=>o*s)*(t?2:1);if(n===0)return[];if(n!==e.length)throw new Error(`[${r}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return vb(0,r,e,t)}function Oi(r,e){let t=ia(r,e);for(let n=0;n<t.length;n++)t[n]=1;return t}function ia(r,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${e}`)}function E2(r,e){let t=r.reduce((n,o)=>n*o,1);if(e==null||e==="float32")return lo(r,new Float32Array(t));if(e==="int32")return lo(r,new Int32Array(t));if(e==="bool")return lo(r,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Fi(r){r.forEach(e=>{E(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function A2(r,e,t){if(e===0)return 0;if(e===1)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=t[o]*r[o];return n}function R2(r,e,t){if(e===0)return[];if(e===1)return[r];let n=new Array(e);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/t[o]),r-=n[o]*t[o];return n[n.length-1]=r,n}function Pi(r){return r&&r.then&&typeof r.then=="function"}function Wt(...r){$().getBool("IS_TEST")||$().getBool("PROD")||console.warn(...r)}function $2(...r){$().getBool("IS_TEST")||$().getBool("PROD")||console.log(...r)}var Ib="tfjsflags",kl=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=D2,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&Wt(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let o=this.urlFlags[e];Wt(`Setting feature override from URL ${e}: ${o}.`),this.set(e,o)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Pi(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let e=this.getQueryParams(this.global.location.search);Ib in e&&e[Ib].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=O2(o,s)})}};function D2(r){let e={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(F2(e,n[0],n[1]),n.join("="))),e}function F2(r,e,t){r[decodeURIComponent(e)]=decodeURIComponent(t||"")}function O2(r,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${r}.`)}function $(){return qf}var qf=null;function Cb(r){qf=r}var Kf;function Xf(){if(Kf==null){let r;if(typeof window!="undefined")r=window;else if(typeof global!="undefined")r=global;else if(typeof process!="undefined")r=process;else if(typeof self!="undefined")r=self;else throw new Error("Could not find a global object");Kf=r}return Kf}function P2(){let r=Xf();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function Li(r,e){let t=P2();if(t.has(r))return t.get(r);{let n=e();return t.set(r,n),t.get(r)}}var co="Abs",Nl="Acos",El="Acosh",fr="Add",po="AddN",mo="All",fo="Any",ho="ArgMax",Al="ArgMin",Rl="Asin",$l="Asinh",Dl="Atan",Ol="Atanh",Fl="Atan2",go="AvgPool",Tb="AvgPoolGrad",Pl="AvgPool3D",Sb="AvgPool3DGrad",xo="BatchMatMul",ua="BatchToSpaceND",Ll="Bincount";var kb="BroadcastArgs",Mr="Cast",mn="Ceil",_o="ClipByValue",Mi="Complex",Ml="ComplexAbs",la="Concat",yo="Conv2D",Bl="Conv2DBackpropFilter",bo="Conv2DBackpropInput",Ul="Conv3D",Nb="Conv3DBackpropFilterV2",Eb="Conv3DBackpropInputV2",ca="Cos",pa="Cosh",wo="Cumsum",vo="CropAndResize",Wl="DenseBincount",Io="DepthToSpace",Co="DepthwiseConv2dNative",Vl="DepthwiseConv2dNativeBackpropFilter",Gl="DepthwiseConv2dNativeBackpropInput",Ab="Diag",zl="Dilation2D";var ma="RealDiv",Hl="Einsum",fa="Elu",Rb="EluGrad",jl="Erf",fn="Equal",dn="Exp",da="ExpandDims",ha="Expm1",ql="FFT",ga="Fill",To="FlipLeftRight",hn="Floor",xa="FloorDiv",So="FusedBatchNorm",_a="GatherV2",ko="GatherNd",gn="Greater",xn="GreaterEqual",Br="Identity",Kl="IFFT",Xl="Imag",$b="IsFinite",Db="IsInf",Yl="IsNan",No="LeakyRelu",_n="Less",yn="LessEqual",Jl="LinSpace",bn="Log",Ql="Log1p",ya="LogicalAnd",Zl="LogicalNot",ec="LogicalOr";var tc="LRN",Ob="LRNGrad",Eo="Max",wn="Maximum",Ao="MaxPool",Fb="MaxPoolGrad",rc="MaxPool3D",Pb="MaxPool3DGrad",nc="MaxPoolWithArgmax",Ro="Mean",$o="Min",vn="Minimum",Do="MirrorPad",oc="Mod",sc="Multinomial",In="Multiply",Oo="Neg",Cn="NotEqual",Fo="NonMaxSuppressionV3",Po="NonMaxSuppressionV4",Lo="NonMaxSuppressionV5",ba="OnesLike",Mo="OneHot",wa="Pack",Bo="PadV2";var va="Pow",Uo="Prelu",Tn="Prod",Ia="Range",Bi="Real",ac="Reciprocal",Ca="Relu",Ta="Reshape",ic="ResizeNearestNeighbor",Lb="ResizeNearestNeighborGrad",Wo="ResizeBilinear",Mb="ResizeBilinearGrad",Sa="Relu6",Vo="Reverse",ka="Round",Sn="Rsqrt",Go="ScatterNd",Na="Select",uc="Selu",zo="Slice",Ea="Sin",lc="Sinh",cc="Sign",kn="Sigmoid",pc="Softplus",Nn="Sqrt",Ho="Sum",Aa="SpaceToBatchND",Ra="SplitV",jo="Softmax",mc="SparseFillEmptyRows",fc="SparseReshape",dc="SparseSegmentMean",hc="SparseSegmentSum",gc="SparseToDense",En="SquaredDifference",xc="Square",qo="StridedSlice",_c="StringNGrams",yc="StringSplit",bc="StringToHashBucketFast",An="Sub",$a="Tan",Da="Tanh",Ur="Tile",Ko="TopK",Xo="Transform",Yo="Transpose",wc="Unique",Oa="Unpack",Bb="UnsortedSegmentSum",Fa="ZerosLike",Jo="Step",Ui="FromPixels",Qo="RotateWithOffset",Rn="_FusedMatMul",$n="FusedConv2D",Dn="FusedDepthwiseConv2D";var vc=Li("kernelRegistry",()=>new Map),L2=Li("gradRegistry",()=>new Map);function Wi(r,e){let t=Ub(r,e);return vc.get(t)}function Yf(r){return L2.get(r)}function Jf(r){let e=vc.entries(),t=[];for(;;){let{done:n,value:o}=e.next();if(n)break;let[s,i]=o,[a]=s.split("_");a===r&&t.push(i)}return t}function Ic(r){let{kernelName:e,backendName:t}=r,n=Ub(e,t);vc.has(n)&&Wt(`The kernel '${e}' for backend '${t}' is already registered`),vc.set(n,r)}function Ub(r,e){return`${e}_${r}`}var w={};Ie(w,{arraysEqual:()=>pr,assert:()=>E,assertNonNegativeIntegerDimensions:()=>Fi,assertNonNull:()=>Di,assertShapesMatch:()=>Wf,bytesFromStringArray:()=>jf,bytesPerElement:()=>Tl,checkConversionForErrors:()=>zf,clamp:()=>na,computeStrides:()=>mr,createScalarValue:()=>z2,createShuffledIndices:()=>C2,decodeString:()=>Ua,distSquared:()=>b2,encodeString:()=>Ba,fetch:()=>j2,fingerPrint64:()=>G2,flatten:()=>pn,getArrayFromDType:()=>Gf,getTypedArrayFromDType:()=>k2,hasEncodingLoss:()=>N2,hexToLong:()=>Vi,indexToLoc:()=>R2,inferDtype:()=>sa,inferFromImplicitShape:()=>S2,isBoolean:()=>bb,isFunction:()=>Sl,isInt:()=>Re,isNumber:()=>wb,isPromise:()=>Pi,isScalarShape:()=>w2,isString:()=>oa,isTypedArray:()=>At,isValidDtype:()=>Hf,locToIndex:()=>A2,makeOnesTypedArray:()=>Oi,makeZerosNestedTypedArray:()=>E2,makeZerosTypedArray:()=>ia,nearestDivisor:()=>aa,nearestLargerEven:()=>x2,now:()=>ns,parseAxisParam:()=>yb,randUniform:()=>y2,repeatedTry:()=>T2,rightPad:()=>uo,shuffle:()=>_b,shuffleCombo:()=>g2,sizeFromShape:()=>Se,sizeToSquarishShape:()=>I2,squeezeShape:()=>Vf,sum:()=>_2,swap:()=>Cl,tanh:()=>v2,toNestedArray:()=>lo,toTypedArray:()=>Ma});var Qb=gl(Jb());var ts=Qb.default||Qb;function Vi(r){return ts.fromString(r,!0,16)}var Zb=Vi("c3a5c85c97cb3127"),rs=Vi("b492b66fbe98f273"),ft=Vi("9ae16a3b2f90404f");function ed(r){return r.xor(r.shru(47))}function ew(r,e,t){let n=r.slice(e,e+t);return ts.fromBytes(Array.from(n),!0,!0)}function Ee(r,e){return ew(r,e,8)}function tw(r,e){return ew(r,e,4)}function et(r,e){return e===0?r:r.shru(e).or(r.shl(64-e))}function On(r,e,t=Vi("9ddfea08eb382d69")){let n=r.xor(e).mul(t);n=n.xor(n.shru(47));let o=e.xor(n).mul(t);return o=o.xor(o.shru(47)),o=o.mul(t),o}function B2(r,e,t,n,o,s){o=o.add(r),s=et(s.add(o).add(n),21);let i=o;return o=o.add(e),o=o.add(t),s=s.add(et(o,44)),[o.add(n),s.add(i)]}function Tc(r,e,t,n){return B2(Ee(r,e),Ee(r,e+8),Ee(r,e+16),Ee(r,e+24),t,n)}function U2(r,e=r.length){if(e>=8){let t=ft.add(e*2),n=Ee(r,0).add(ft),o=Ee(r,e-8),s=et(o,37).mul(t).add(n),i=et(n,25).add(o).mul(t);return On(s,i,t)}if(e>=4){let t=ft.add(e*2),n=tw(r,0);return On(n.shl(3).add(e),tw(r,e-4),t)}if(e>0){let t=r[0],n=r[e>>1],o=r[e-1],s=t+(n<<8),i=e+(o<<2);return ed(ft.mul(s).xor(Zb.mul(i))).mul(ft)}return ft}function W2(r,e=r.length){let t=ft.add(e*2),n=Ee(r,0).mul(rs),o=Ee(r,8),s=Ee(r,e-8).mul(t),i=Ee(r,e-16).mul(ft);return On(et(n.add(o),43).add(et(s,30)).add(i),n.add(et(o.add(ft),18)).add(s),t)}function V2(r,e=r.length){let t=ft.add(e*2),n=Ee(r,0).mul(ft),o=Ee(r,8),s=Ee(r,e-8).mul(t),i=Ee(r,e-16).mul(ft),a=et(n.add(o),43).add(et(s,30)).add(i),u=On(a,n.add(et(o.add(ft),18)).add(s),t),l=Ee(r,16).mul(t),c=Ee(r,24),p=a.add(Ee(r,e-32)).mul(t),m=u.add(Ee(r,e-24)).mul(t);return On(et(l.add(c),43).add(et(p,30)).add(m),l.add(et(c.add(n),18)).add(p),t)}function G2(r,e=r.length){let t=ts.fromNumber(81,!0);if(e<=32)return e<=16?U2(r,e):W2(r,e);if(e<=64)return V2(r,e);let n=t,o=t.mul(rs).add(113),s=ed(o.mul(ft).add(113)).mul(ft),i=[ts.UZERO,ts.UZERO],a=[ts.UZERO,ts.UZERO];n=n.mul(ft).add(Ee(r,0));let u=0,l=(e-1>>6)*64,c=l+(e-1&63)-63;do n=et(n.add(o).add(i[0]).add(Ee(r,u+8)),37).mul(rs),o=et(o.add(i[1]).add(Ee(r,u+48)),42).mul(rs),n=n.xor(a[1]),o=o.add(i[0]).add(Ee(r,u+40)),s=et(s.add(a[0]),33).mul(rs),i=Tc(r,u,i[1].mul(rs),n.add(a[0])),a=Tc(r,u+32,s.add(a[1]),o.add(Ee(r,u+16))),[s,n]=[n,s],u+=64;while(u!==l);let p=rs.add(s.and(255).shl(1));return u=c,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),n=et(n.add(o).add(i[0]).add(Ee(r,u+8)),37).mul(p),o=et(o.add(i[1]).add(Ee(r,u+48)),42).mul(p),n=n.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(Ee(r,u+40))),s=et(s.add(a[0]),33).mul(p),i=Tc(r,u,i[1].mul(p),n.add(a[0])),a=Tc(r,u+32,s.add(a[1]),o.add(Ee(r,u+16))),[s,n]=[n,s],On(On(i[0],a[0],p).add(ed(o).mul(Zb)).add(s),On(i[1],a[1],p).add(n),p)}function z2(r,e){return e==="string"?Ba(r):Ma([r],e)}function H2(r,e){return r instanceof Float32Array&&e==="float32"||r instanceof Int32Array&&e==="int32"||r instanceof Uint8Array&&e==="bool"}function Ma(r,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=pn(r)),$().getBool("DEBUG")&&zf(r,e),H2(r,e))return r;if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"){let t=new Uint8Array(r.length);for(let n=0;n<t.length;++n)Math.round(r[n])!==0&&(t[n]=1);return t}else throw new Error(`Unknown data type ${e}`)}function ns(){return $().platform.now()}function j2(r,e){return $().platform.fetch(r,e)}function Ba(r,e="utf-8"){return e=e||"utf-8",$().platform.encode(r,e)}function Ua(r,e="utf-8"){return e=e||"utf-8",$().platform.decode(r,e)}var td=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new rw)}profileKernel(e,t,n){let o,s=()=>{o=n()},i,a=ns();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let l of o)l.dataSync();i=Promise.resolve({kernelMs:ns()-a})}if($().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<o.length;l++){let c=o[l];c.data().then(p=>{q2(p,c.dtype,e)})}return{kernelName:e,outputs:o,inputs:t,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:o,inputs:s,extraInfo:i}=e;n.forEach(a=>{Promise.all([a.data(),o,i]).then(u=>{this.logger.logKernelProfile(t,a,u[0],u[1],s,u[2])})})}};function q2(r,e,t){if(e!=="float32")return!1;for(let n=0;n<r.length;n++){let o=r[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${t}'`),!0}return!1}var rw=class{logKernelProfile(e,t,n,o,s,i){let a=typeof o=="number"?uo(`${o}ms`,9):o.error,u=uo(e,25),l=t.rank,c=t.size,p=uo(t.shape.toString(),14),m="";for(let f in s){let d=s[f];if(d!=null){let h=d.shape||t.shape,g=h.length;m+=`${f}: ${g}D ${g>0?h:""} `}}console.log(`%c${u}	%c${a}	%c${l}D ${p}	%c${c}	%c${m}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function nw(r,e,t){let n={},o={};for(let u=0;u<e.length;u++)n[e[u].id]=!0;for(let u=0;u<r.length;u++){let l=r[u],c=l.inputs;for(let p in c){let m=c[p],f=!1;for(let d=0;d<e.length;d++)if(n[m.id]){l.outputs.forEach(h=>n[h.id]=!0),f=!0,o[l.id]=!0;break}if(f)break}}let s={};s[t.id]=!0;let i={};for(let u=r.length-1;u>=0;u--){let l=r[u],c=l.inputs;for(let p=0;p<l.outputs.length;p++)if(s[l.outputs[p].id]){for(let m in c)s[c[m].id]=!0,i[l.id]=!0;break}}let a=[];for(let u=0;u<r.length;u++){let l=r[u];if(o[l.id]&&i[l.id]){let c={};for(let m in l.inputs){let f=l.inputs[m];n[f.id]&&(c[m]=f)}let p=Object.assign({},l);p.inputs=c,p.outputs=l.outputs,a.push(p)}}return a}function ow(r,e,t,n){for(let o=e.length-1;o>=0;o--){let s=e[o],i=[];if(s.outputs.forEach(u=>{let l=r[u.id];l!=null?i.push(l):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let u in s.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);let l=t(()=>a[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);let c=s.inputs[u];if(!pr(l.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(r[c.id]==null)r[c.id]=l;else{let p=r[c.id];r[c.id]=n(p,l),p.dispose()}}}}var sw=20,Gi=3,rd=7;function aw(r,e,t,n){let o=mr(e),s=K2(r,e,t,o),i=e.length,a=Sc(r,e,t,o,s),u=["Tensor"];return n&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${i}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(a.map(l=>"    "+l).join(`
`)),u.join(`
`)}function K2(r,e,t,n){let o=Se(e),s=n[n.length-1],i=new Array(s).fill(0),a=e.length,u=t==="complex64"?Hi(r):r;if(a>1)for(let l=0;l<o/s;l++){let c=l*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],zi(u[c+p],0,t).length)}return i}function zi(r,e,t){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(rd))} + ${parseFloat(r[1].toFixed(rd))}j`:oa(r)?n=`'${r}'`:t==="bool"?n=iw(r):n=parseFloat(r.toFixed(rd)).toString(),uo(n,e)}function iw(r){return r===0?"false":"true"}function Sc(r,e,t,n,o,s=!0){let i=t==="complex64"?2:1,a=e[0],u=e.length;if(u===0){if(t==="complex64"){let h=Hi(r);return[zi(h[0],0,t)]}return t==="bool"?[iw(r[0])]:[r[0].toString()]}if(u===1){if(a>sw){let g=Gi*i,y=Array.from(r.slice(0,g)),I=Array.from(r.slice((a-Gi)*i,a*i));return t==="complex64"&&(y=Hi(y),I=Hi(I)),["["+y.map((_,N)=>zi(_,o[N],t)).join(", ")+", ..., "+I.map((_,N)=>zi(_,o[a-Gi+N],t)).join(", ")+"]"]}let h=t==="complex64"?Hi(r):Array.from(r);return["["+h.map((g,y)=>zi(g,o[y],t)).join(", ")+"]"]}let l=e.slice(1),c=n.slice(1),p=n[0]*i,m=[];if(a>sw){for(let h=0;h<Gi;h++){let g=h*p,y=g+p;m.push(...Sc(r.slice(g,y),l,t,c,o,!1))}m.push("...");for(let h=a-Gi;h<a;h++){let g=h*p,y=g+p;m.push(...Sc(r.slice(g,y),l,t,c,o,h===a-1))}}else for(let h=0;h<a;h++){let g=h*p,y=g+p;m.push(...Sc(r.slice(g,y),l,t,c,o,h===a-1))}let f=u===2?",":"";m[0]="["+m[0]+f;for(let h=1;h<m.length-1;h++)m[h]=" "+m[h]+f;let d=`,
`;for(let h=2;h<u;h++)d+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(s?"":d),m}function Hi(r){let e=[];for(let t=0;t<r.length;t+=2)e.push([r[t],r[t+1]]);return e}var dr=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Se(e),n!=null){let o=n.length;E(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Gf(t,this.size),this.strides=mr(e)}set(e,...t){t.length===0&&(t=[0]),E(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let o of e){if(o<0||o>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let o=0;o<e.length-1;++o)n+=this.strides[o]*e[o];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return hr().makeTensor(this.values,this.shape,this.dtype)}},hr=null,Wa=null,X2=null;function uw(r){hr=r}function lw(r){Wa=r}function cw(r){X2=r}var ze=class{constructor(e,t,n,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Se(e),this.strides=mr(e),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Wa.buffer(this.shape,this.dtype,e)}bufferSync(){return Wa.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return lo(this.shape,e,this.dtype==="complex64")}arraySync(){return lo(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=hr().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>Ua(n))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();let e=hr().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Ua(t))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await hr().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(hr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Wa.print(this,e)}clone(){return this.throwIfDisposed(),Wa.clone(this)}toString(e=!1){let t=this.dataSync();return aw(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Wa.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),hr().makeVariable(this,e,t,n)}};Object.defineProperty(ze,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function Y2(){return Li("Tensor",()=>ze)}Y2();var os=class extends ze{constructor(e,t,n,o){super(e.shape,e.dtype,e.dataId,o);this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!pr(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);hr().disposeTensor(this),this.dataId=e.dataId,hr().incRef(this,null)}dispose(){hr().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(os,Symbol.hasInstance,{value:r=>r instanceof ze&&r.assign!=null&&r.assign instanceof Function});var nd;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(nd||(nd={}));var od;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(od||(od={}));var sd;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(sd||(sd={}));var ad;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(ad||(ad={}));var id;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(id||(id={}));var J2={float32:ad,int32:od,bool:sd,complex64:id};function ut(r,e){if(r==="string"||e==="string"){if(r==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${r} with ${e}`)}return J2[r][e]}function ss(r){return ut(r,"int32")}function ae(r,e){if(r.dtype===e.dtype)return[r,e];let t=ut(r.dtype,e.dtype);return[r.cast(t),e.cast(t)]}function mw(r){let e=[],t=new Set;return pw(r,e,t),e}function pw(r,e,t){if(r==null)return;if(r instanceof ze){e.push(r);return}if(!Q2(r))return;let n=r;for(let o in n){let s=n[o];t.has(s)||(t.add(s),pw(s,e,t))}}function Q2(r){return Array.isArray(r)||typeof r=="object"}function ud(r){return r.kernelName!=null}var ld=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},as=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ld}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(Wt(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new td(this.backendInstance),!0}setupRegisteredKernels(){Jf(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Jf(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(n&&!(n instanceof cn)&&typeof n.then=="function"){let o=++this.pendingBackendInitId,s=n.then(i=>o<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,Wt(`Initialization of backend ${e} failed`),Wt(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return Wt(`Initialization of backend ${e} failed`),Wt(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:o,asyncInit:s}=this.initializeBackend(n);if(s||o)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),o=n.backend,s=this.readSync(t),i=o.refCount(t);o.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let o;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(o),()=>(o=t(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,t,n){e();try{let o=n();return t(),o}catch(o){throw t(),o}}nextTensorId(){return as.nextTensorId++}nextVariableId(){return as.nextVariableId++}clone(e){let t=C.runKernel(Br,{x:e}),n={x:e},o=i=>({x:()=>{let a="float32",u={x:i},l={dtype:a};return C.runKernel(Mr,u,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],o,s,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(Wi(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let o=this.backend.numDataIds(),s=0;n.forEach(u=>{s+=u.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=o-t-s-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[],o=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let u,l=ud(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(ud(e)){let{kernelName:d,inputs:h,attrs:g}=e;this.backendName==null&&this.backend;let y=Wi(d,this.backendName);E(y!=null,()=>`Cannot find registered kernel '${d}' for backend '${this.backendName}'`),a=()=>{let I=this.backend.numDataIds();u=y.kernelFunc({inputs:h,attrs:g,backend:this.backend});let _=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,I,_);let N=_.map(R=>{if(R.rank!=null)return R;let{dataId:F,shape:D,dtype:O}=R;return this.makeTensorFromDataId(F,D,O)});if(o){let R=this.getTensorsForGradient(d,h,N);n=this.saveTensorsForBackwardMode(R)}return N}}else{let{forwardFunc:d}=e,h=g=>{!o||(n=g.map(y=>this.keep(this.clone(y))))};a=()=>{let g=this.backend.numDataIds();u=this.tidy(()=>d(this.backend,h));let y=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,g,y),y}}let{inputs:c,attrs:p}=e,m=ud(e)?null:e.backwardsFunc,f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(f=this.profiler.profileKernel(l,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs)}),o&&this.addTapeNode(l,c,t,m,n,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(d=>c[d]!=null?c[d].shape:null),outputShapes:t.map(d=>d.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){let o=Yf(e);if(o!=null){let s=o.inputsToSave||[],i=o.outputsToSave||[],a;o.saveAllInputs?(E(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(l=>t[l])):a=s.map(l=>t[l]);let u=n.filter((l,c)=>i[c]);return a.concat(u)}return[]}makeTensor(e,t,n,o){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let s=e;n==="string"&&oa(e[0])&&(s=e.map(u=>Ba(u)));let i=o.write(s,t,n),a=new ze(t,n,i,this.nextTensorId());if(this.trackTensor(a,o),n==="string"){let u=this.state.tensorInfo.get(i),l=jf(s);this.state.numBytes+=l-u.bytes,u.bytes=l}return a}makeTensorFromDataId(e,t,n,o){n=n||"float32";let s=new ze(t,n,e,this.nextTensorId());return this.trackTensor(s,o),s}makeVariable(e,t=!0,n,o){n=n||this.nextVariableId().toString(),o!=null&&o!==e.dtype&&(e=e.cast(o));let s=new os(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*Tl(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof os||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let n=e.size*Tl(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,o,s,i){let a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},u=Yf(e);u!=null&&(o=u.gradFunc),o!=null&&(a.gradient=l=>(l=l.map((c,p)=>{if(c==null){let m=n[p],f=ia(m.size,m.dtype);return this.makeTensor(f,m.shape,m.dtype)}return c}),o(l.length>1?l:l[0],s,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=mw(e),n=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!n.has(i.id)&&i.dispose()}let o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(e,t,n,o=!1){if(E(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));E(s instanceof ze,()=>"The result y returned by f() must be a tensor.");let i=nw(this.state.activeTape,t,s);if(!o&&i.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let a={};a[s.id]=n??Z2(s.shape),ow(a,i,l=>this.tidy(l),e$);let u=t.map(l=>a[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let c of l.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(e){return E(Sl(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{E(t.every(a=>a instanceof ze),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,o={};t.forEach((a,u)=>{o[u]=a});let s=(a,u)=>(n=e(...t,u),E(n.value instanceof ze,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),E(Sl(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),i=(a,u)=>{let l=n.gradFunc(a,u),c=Array.isArray(l)?l:[l];E(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),E(c.every(m=>m instanceof ze),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let p={};return c.forEach((m,f)=>{p[f]=()=>m}),p};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){let t=ns(),n=await this.backend.time(e);return n.wallMs=ns()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ld;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};as.nextTensorId=0;as.nextVariableId=0;function Z2(r){let e=Oi(Se(r),"float32");return C.makeTensor(e,r,"float32")}function cd(){let r=Xf();if(r._tfengine==null){let e=new kl(r);r._tfengine=new as(e)}return Cb(r._tfengine.ENV),uw(()=>r._tfengine),r._tfengine}var C=cd();function e$(r,e){let t={a:r,b:e};return C.runKernel(fr,t)}var is={};Ie(is,{isBrowser:()=>pd,isMobile:()=>r$});function t$(){return typeof navigator!="undefined"&&navigator!=null}function r$(r){if(r||t$()){if(r||(r=navigator),r.product==="ReactNative")return!0;let e=r.userAgent||r.vendor||(typeof window!="undefined"?window.opera:"");if(!e){let t=r;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function pd(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var Zt=$();Zt.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Zt.registerFlag("IS_BROWSER",()=>pd());Zt.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Zt.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Zt.registerFlag("PROD",()=>!1);Zt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Zt.getBool("DEBUG"));Zt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Zt.registerFlag("IS_TEST",()=>!1);Zt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Zt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);function us(r,e){let t=r;if(At(r))return e==="string"?[]:[r.length];if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(t)||At(t)&&e!=="string";)n.push(t.length),t=t[0];return Array.isArray(r)&&$().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&fw(r,n,[]),n}function fw(r,e,t){if(t=t||[],!Array.isArray(r)&&!At(r)){E(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}E(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${r.length} elements`),E(r.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${r.length} elements`);let n=e.slice(1);for(let o=0;o<r.length;++o)fw(r[o],n,t.concat(o))}function dw(r,e,t,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==e||r==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${n}' must be ${r} tensor, but got ${e} tensor`)}}function v(r,e,t,n="numeric"){if(r instanceof ze)return dw(n,r.dtype,e,t),r;let o=sa(r);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),dw(n,o,e,t),r==null||!At(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}let s=us(r,o);!At(r)&&!Array.isArray(r)&&(r=[r]);let a=o!=="string"?Ma(r,o):pn(r,[],!0);return C.makeTensor(a,s,o)}function kc(r,e,t,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,i)=>v(s,`${e}[${i}]`,t,n))}var n$="__op";function S(r){let e=Object.keys(r);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0],n=r[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+n$;let o=(...s)=>{C.startScope(t);try{let i=n(...s);return Pi(i)&&console.error("Cannot return a Promise inside of tidy."),C.endScope(i),i}catch(i){throw C.endScope(null),i}};return Object.defineProperty(o,"name",{value:t,configurable:!0}),o}function o$(r,e){let t=v(r,"real","complex"),n=v(e,"imag","complex");Wf(t.shape,n.shape,`real and imag shapes, ${t.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:t,imag:n};return C.runKernel(Mi,o)}var Dt=S({complex_:o$});function Fn(r,e,t,n){if(n==null&&(n=sa(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!At(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Fi(e);let o=Se(e),s=Se(t);E(o===s,()=>`Based on the provided shape, [${e}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<t.length;++i){let a=t[i],u=i===t.length-1?a!==Se(e.slice(i)):!0;E(t[i]===e[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!At(r)&&!Array.isArray(r)&&(r=[r]),e=e||t,r=n!=="string"?Ma(r,n):pn(r,[],!0),C.makeTensor(r,e,n)}function vt(r,e,t){let n=us(r,t);return Fn(r,e,n,t)}var ji={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var Nc=4;async function hw(r,e){let t=[],n=[],o=Array.isArray(r)?r.map(i=>i.name):Object.keys(r);for(let i=0;i<o.length;++i){let a=o[i],u=Array.isArray(r)?r[i].tensor:r[a];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);let l={name:a,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let c=new Promise(async p=>{let m=await u.bytes(),f=m.reduce((g,y)=>g+y.length,0)+Nc*m.length,d=new Uint8Array(f),h=0;for(let g=0;g<m.length;g++){let y=m[g],I=new Uint8Array(new Uint32Array([y.length]).buffer);d.set(I,h),h+=Nc,d.set(y,h),h+=y.length}p(d)});n.push(c)}else n.push(u.data());e!=null&&(l.group=e),t.push(l)}let s=await Promise.all(n);return{data:s$(s),specs:t}}function Ec(r,e){let t={},n,o=0;for(let s of e){let i=s.name,a=s.dtype,u=s.shape,l=Se(u),c;if("quantization"in s){let p=s.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error(`Weight ${s.name} with quantization ${p.dtype} doesn't have corresponding metadata min and scale.`)}else if(p.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${s.name} is quantized with ${p.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${p.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let m=ji[p.dtype],f=r.slice(o,o+l*m),d=p.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(a==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){c=new Float32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=g*p.scale+p.min}}else if(p.dtype==="float16")n===void 0&&(n=a$()),c=n(d);else throw new Error(`Unsupported quantization type ${p.dtype} for weight type float32.`);else if(a==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error(`Unsupported quantization type ${p.dtype} for weight type int32.`);c=new Int32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=Math.round(g*p.scale+p.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=l*m}else if(a==="string"){let p=Se(s.shape);c=[];for(let m=0;m<p;m++){let f=new Uint32Array(r.slice(o,o+Nc))[0];o+=Nc;let d=new Uint8Array(r.slice(o,o+f));c.push(d),o+=f}}else{let p=ji[a],m=r.slice(o,o+l*p);if(a==="float32")c=new Float32Array(m);else if(a==="int32")c=new Int32Array(m);else if(a==="bool")c=new Uint8Array(m);else if(a==="complex64"){c=new Float32Array(m);let f=new Float32Array(c.length/2),d=new Float32Array(c.length/2);for(let y=0;y<f.length;y++)f[y]=c[y*2],d[y]=c[y*2+1];let h=vt(f,u,"float32"),g=vt(d,u,"float32");t[i]=Dt(h,g),h.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=l*p}a!=="complex64"&&(t[i]=vt(c,u,a))}return t}function s$(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let e=0,t=[];r.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(e),o=0;return t.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var md=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function gw(r){return md?Buffer.byteLength(r):new Blob([r]).size}function xw(r){if(md)return Buffer.from(r).toString("base64");let e=new Uint8Array(r),t="";for(let n=0,o=e.length;n<o;n++)t+=String.fromCharCode(e[n]);return btoa(t)}function _w(r){if(md){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let e=atob(r),t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)t.set([e.charCodeAt(n)],n);return t.buffer}function Va(r){if(r.length===1)return r[0];let e=0;r.forEach(o=>{e+=o.byteLength});let t=new Uint8Array(e),n=0;return r.forEach(o=>{t.set(new Uint8Array(o),n),n+=o.byteLength}),t.buffer}function fd(r){let e="/";for(r=r.trim();r.endsWith(e);)r=r.slice(0,r.length-1);let t=r.split(e);return t[t.length-1]}function Ac(r,e){let t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:e};return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),t}async function Ga(r,e){let t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),r.weightsManifest!=null){let[n,o]=await e(r.weightsManifest);t.weightSpecs=n,t.weightData=o}return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),t}function gr(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:gw(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:gw(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function i$(){let r=t=>{let n=t<<13,o=0;for(;(n&8388608)==0;)o-=8388608,n<<=1;return n&=~8388608,o+=947912704,n|o},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=r(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function u$(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let e=1;e<31;e++)r[e]=e<<23;for(let e=33;e<63;e++)r[e]=2147483648+(e-32<<23);return r}function l$(){let r=new Uint32Array(64);for(let e=0;e<64;e++)r[e]=1024;return r[0]=r[32]=0,r}function a$(){let r=i$(),e=u$(),t=l$();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let i=0;i<n.length;i++){let a=n[i],u=r[t[a>>10]+(a&1023)]+e[a>>10];s[i]=u}return new Float32Array(o)}}var Te=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Te.instance==null&&(Te.instance=new Te),Te.instance}static registerSaveRouter(e){Te.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Te.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Te.getHandlers(e,"save")}static getLoadHandlers(e,t){return Te.getHandlers(e,"load",t)}static getHandlers(e,t,n){let o=[];return(t==="load"?Te.getInstance().loadRouters:Te.getInstance().saveRouters).forEach(i=>{let a=i(e,n);a!==null&&o.push(a)}),o}},yw=r=>Te.registerSaveRouter(r),bw=r=>Te.registerLoadRouter(r),ww=r=>Te.getSaveHandlers(r),vw=(r,e)=>Te.getLoadHandlers(r,e);var dd="tensorflowjs",hd=1,ls="models_store",Pn="model_info_store";function Iw(){if(!$().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window=="undefined"?self:window,e=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function gd(r){let e=r.result;e.createObjectStore(ls,{keyPath:"modelPath"}),e.createObjectStore(Pn,{keyPath:"modelPath"})}var Wr=class{constructor(e){if(this.indexedDB=Iw(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,o)=>{let s=this.indexedDB.open(dd,hd);s.onupgradeneeded=()=>gd(s),s.onsuccess=()=>{let i=s.result;if(t==null){let a=i.transaction(ls,"readonly"),l=a.objectStore(ls).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return i.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(l.result.modelArtifacts)},l.onerror=c=>(i.close(),o(l.error)),a.oncomplete=()=>i.close()}else{let a=gr(t),u=i.transaction(Pn,"readwrite"),l=u.objectStore(Pn),c=l.put({modelPath:this.modelPath,modelArtifactsInfo:a}),p;c.onsuccess=()=>{p=i.transaction(ls,"readwrite");let f=p.objectStore(ls).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});f.onsuccess=()=>n({modelArtifactsInfo:a}),f.onerror=d=>{l=u.objectStore(Pn);let h=l.delete(this.modelPath);h.onsuccess=()=>(i.close(),o(f.error)),h.onerror=g=>(i.close(),o(f.error))}},c.onerror=m=>(i.close(),o(c.error)),u.oncomplete=()=>{p==null?i.close():p.oncomplete=()=>i.close()}}},s.onerror=i=>o(s.error)})}};Wr.URL_SCHEME="indexeddb://";var Cw=r=>$().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Wr.URL_SCHEME)?c$(r.slice(Wr.URL_SCHEME.length)):null;Te.registerSaveRouter(Cw);Te.registerLoadRouter(Cw);function c$(r){return new Wr(r)}function p$(r){return r.startsWith(Wr.URL_SCHEME)?r.slice(Wr.URL_SCHEME.length):r}var xd=class{constructor(){this.indexedDB=Iw()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(dd,hd);n.onupgradeneeded=()=>gd(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(Pn,"readonly"),a=s.objectStore(Pn).getAll();a.onsuccess=()=>{let u={};for(let l of a.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},a.onerror=u=>(o.close(),t(a.error)),s.oncomplete=()=>o.close()},n.onerror=o=>t(n.error)})}async removeModel(e){return e=p$(e),new Promise((t,n)=>{let o=this.indexedDB.open(dd,hd);o.onupgradeneeded=()=>gd(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(Pn,"readwrite"),a=i.objectStore(Pn),u=a.get(e),l;u.onsuccess=()=>{if(u.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let c=a.delete(e),p=()=>{l=s.transaction(ls,"readwrite");let f=l.objectStore(ls).delete(e);f.onsuccess=()=>t(u.result.modelArtifactsInfo),f.onerror=d=>n(u.error)};c.onsuccess=p,c.onerror=m=>(p(),s.close(),n(u.error))}},u.onerror=c=>(s.close(),n(u.error)),i.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})}};var Vr="/",za="tensorflowjs_models",Tw="info",m$="model_topology",f$="weight_specs",d$="weight_data",h$="model_metadata";function Sw(r){return{info:[za,r,Tw].join(Vr),topology:[za,r,m$].join(Vr),weightSpecs:[za,r,f$].join(Vr),weightData:[za,r,d$].join(Vr),modelMetadata:[za,r,h$].join(Vr)}}function kw(r){for(let e of Object.values(r))window.localStorage.removeItem(e)}function g$(r){let e=r.split(Vr);if(e.length<3)throw new Error(`Invalid key format: ${r}`);return e.slice(1,e.length-1).join(Vr)}function x$(r){return r.startsWith(Gr.URL_SCHEME)?r.slice(Gr.URL_SCHEME.length):r}var Gr=class{constructor(e){if(!$().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Sw(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),o=gr(e);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,xw(e.weightData));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch(s){throw kw(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=o;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let a=JSON.parse(s);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}let i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=_w(i),t}};Gr.URL_SCHEME="localstorage://";var Nw=r=>$().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Gr.URL_SCHEME)?_$(r.slice(Gr.URL_SCHEME.length)):null;Te.registerSaveRouter(Nw);Te.registerLoadRouter(Nw);function _$(r){return new Gr(r)}var _d=class{constructor(){E($().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),E(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=za+Vr,n=Vr+Tw;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(t)&&s.endsWith(n)){let i=g$(s);e[i]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=x$(e);let t=Sw(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return kw(t),n}};var Ha="://",dt=class{constructor(){this.managers={}}static getInstance(){return dt.instance==null&&(dt.instance=new dt),dt.instance}static registerManager(e,t){E(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Ha)&&(e=e.slice(0,e.indexOf(Ha))),E(e.length>0,()=>"scheme must not be an empty string.");let n=dt.getInstance();E(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}};function Rc(r){if(r.indexOf(Ha)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${dt.getSchemes().join(",")}`);return{scheme:r.split(Ha)[0],path:r.split(Ha)[1]}}async function Ew(r,e,t=!1){E(r!==e,()=>`Old path and new path are the same: '${r}'`);let n=Te.getLoadHandlers(r);E(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),E(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let o=n[0],s=Te.getSaveHandlers(e);E(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),E(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${e}.`);let i=s[0],a=Rc(r).scheme,u=Rc(r).path,l=a===Rc(r).scheme,c=await o.load();t&&l&&await dt.getManager(a).removeModel(u);let p=await i.save(c);return t&&!l&&await dt.getManager(a).removeModel(u),p.modelArtifactsInfo}async function Aw(){let r=dt.getSchemes(),e={};for(let t of r){let n=await dt.getManager(t).listModels();for(let o in n){let s=t+Ha+o;e[s]=n[o]}}return e}async function Rw(r){let e=Rc(r);return dt.getManager(e.scheme).removeModel(e.path)}async function $w(r,e){return Ew(r,e,!1)}async function Dw(r,e){return Ew(r,e,!0)}var Ow=class{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}};if($().get("IS_BROWSER")){$().setPlatform("browser",new Ow);try{dt.registerManager(Gr.URL_SCHEME,new _d)}catch(r){}try{dt.registerManager(Wr.URL_SCHEME,new xd)}catch(r){}}var y$={importFetch:()=>Fw()},yd;var Lw=class{constructor(){this.util=Pw(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return $().global.fetch!=null?$().global.fetch(e,t):(yd==null&&(yd=y$.importFetch()),yd(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}};$().get("IS_NODE")&&$().setPlatform("node",new Lw);function ye(r,e="float32",t){return e=e||"float32",Fi(r),new dr(r,e,t)}function b$(r,e){let t=v(r,"x","cast");if(!Hf(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:t},o={dtype:e};return C.runKernel(Mr,n,o)}var ge=S({cast_:b$});function w$(r){let t={x:v(r,"x","clone","string_or_numeric")};return C.runKernel(Br,t)}var zr=S({clone_:w$});function Mw(r,e=!1){console.log(r.toString(e))}cd();var v$={buffer:ye,cast:ge,clone:zr,print:Mw};lw(v$);var Mn={};Ie(Mn,{browserFiles:()=>Ww,browserHTTPRequest:()=>zw,concatenateArrayBuffers:()=>Va,copyModel:()=>$w,decodeWeights:()=>Ec,encodeWeights:()=>hw,fromMemory:()=>jw,getLoadHandlers:()=>vw,getModelArtifactsForJSON:()=>Ga,getModelArtifactsInfoForJSON:()=>gr,getSaveHandlers:()=>ww,http:()=>Oc,isHTTPScheme:()=>Dc,listModels:()=>Aw,loadWeights:()=>Vw,moveModel:()=>Dw,registerLoadRouter:()=>bw,registerSaveRouter:()=>yw,removeModel:()=>Rw,weightsLoaderFactory:()=>vd,withSaveHandler:()=>qw});var I$="model",C$=".json",T$=".weights.bin";function Bw(r){return new Promise(e=>setTimeout(e)).then(r)}var Ln=class{constructor(e){if(!$().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ln.URL_SCHEME)&&(e=e.slice(Ln.URL_SCHEME.length)),(e==null||e.length===0)&&(e=I$),this.modelJsonFileName=e+C$,this.weightDataFileName=e+T$}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=Ac(e,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=s,await Bw(()=>i.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=t,await Bw(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:gr(e)}}}};Ln.URL_SCHEME="downloads://";var Uw=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}let u=Ga(s,l=>this.loadWeights(l));e(u)},n.onerror=o=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let i of e)t.push(...i.weights),n.push(...i.paths);let o=this.checkManifestAndWeightFiles(e),s=n.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[t,Va(i)])}loadWeightsFile(e,t){return new Promise((n,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;n(a)},s.onerror=i=>o(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(s=>fd(s.name)),o={};for(let s of e)s.paths.forEach(i=>{let a=fd(i);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),n.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[n.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},k$=r=>$().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Ln.URL_SCHEME)?S$(r.slice(Ln.URL_SCHEME.length)):null;Te.registerSaveRouter(k$);function S$(r="model"){return new Ln(r)}function Ww(r){return new Uw(r)}function bd(r,e,t,n){i(r),t=t??0,n=n??1,a(t,n);let o=0,s=u=>(u.then(l=>{let c=t+ ++o/r.length*(n-t);return e(c),l}),u);function i(u){E(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function a(u,l){E(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),E(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),E(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(r.map(s))}async function wd(r,e){e==null&&(e={});let t=e.fetchFunc==null?$().platform.fetch:e.fetchFunc,n=r.map(p=>t(p,e.requestInit,{isBinary:!0})),o=0,s=.5,a=(e.onProgress==null?await Promise.all(n):await bd(n,e.onProgress,o,s)).map(p=>p.arrayBuffer()),u=.5,l=1;return e.onProgress==null?await Promise.all(a):await bd(a,e.onProgress,u,l)}async function Vw(r,e="",t,n){return vd(i=>wd(i,{requestInit:n}))(r,e,t)}function vd(r){return async(e,t="",n)=>{let o=e.map(()=>!1),s={},i=n!=null?n.map(()=>!1):[],a=[];if(e.forEach((f,d)=>{let h=0;f.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,I=ji[y]*Se(g.shape),_=()=>{o[d]=!0,s[d]==null&&(s[d]=[]),s[d].push({manifestEntry:g,groupOffset:h,sizeBytes:I})};n!=null?n.forEach((N,R)=>{N===g.name&&(_(),i[R]=!0)}):_(),a.push(g.name),h+=I})}),!i.every(f=>f)){let f=n.filter((d,h)=>!i[h]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let u=o.reduce((f,d,h)=>(d&&f.push(h),f),[]),l=[];u.forEach(f=>{e[f].paths.forEach(d=>{let h=t+(t.endsWith("/")?"":"/")+d;l.push(h)})});let c=await r(l),p={},m=0;return u.forEach(f=>{let d=e[f].paths.length,h=0;for(let N=0;N<d;N++)h+=c[m+N].byteLength;let g=new ArrayBuffer(h),y=new Uint8Array(g),I=0;for(let N=0;N<d;N++){let R=new Uint8Array(c[m+N]);y.set(R,I),I+=R.byteLength}s[f].forEach(N=>{let R=g.slice(N.groupOffset,N.groupOffset+N.sizeBytes),F=Ec(R,[N.manifestEntry]);for(let D in F)p[D]=F[D]}),m+=d}),p}}var N$="application/octet-stream",E$="application/json",$c=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(E(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=$().platform.fetch,E(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&E(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],o=Ac(e,n);t.body.append("model.json",new Blob([JSON.stringify(o)],{type:E$}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:N$}),"model.weights.bin");let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:gr(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(s){let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}let n=t.modelTopology,o=t.weightsManifest;if(n==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Ga(t,s=>this.loadWeights(s))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=A$(t),s=this.weightPathPrefix||n,i=[];for(let c of e)i.push(...c.weights);let a=[],u=[];for(let c of e)for(let p of c.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(p)):a.push(s+p+o);this.weightUrlConverter&&a.push(...await Promise.all(u));let l=await wd(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,Va(l)]}};$c.URL_SCHEME_REGEX=/^https?:\/\//;function A$(r){let e=r.lastIndexOf("/"),t=r.lastIndexOf("?"),n=r.substring(0,e),o=t>e?r.substring(t):"";return[n+"/",o]}function Dc(r){return r.match($c.URL_SCHEME_REGEX)!=null}var Gw=(r,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(r)?t=r.every(n=>Dc(n)):t=Dc(r),t)return Oc(r,e)}return null};Te.registerSaveRouter(Gw);Te.registerLoadRouter(Gw);function Oc(r,e){return new $c(r,e)}function zw(r,e){return Oc(r,e)}var Fc=class{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}},Hw=class{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}};function jw(r,e,t,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new Fc(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Fc({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Fc({modelTopology:r,weightSpecs:e,weightData:t,trainingConfig:n}))}function qw(r){return new Hw(r)}function R$(r,e,t=!1,n=!1){let o=v(r,"a","matMul"),s=v(e,"b","matMul");[o,s]=ae(o,s);let i={a:o,b:s},a={transposeA:t,transposeB:n};return C.runKernel(xo,i,a)}var Pt=S({matMul_:R$});function $$(r,e,t=1,n=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);let s={indices:v(r,"indices","oneHot","int32")},i={depth:e,onValue:t,offValue:n};return C.runKernel(Mo,s,i)}var Id=S({oneHot_:$$});function D$(r,e){let t=v(r,"x","transpose");if(e==null&&(e=t.shape.map((s,i)=>i).reverse()),E(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of perm ${e}.`),e.forEach(s=>{E(s>=0&&s<t.rank,()=>`All entries in 'perm' must be between 0 and ${t.rank-1} but got ${e}`)}),t.rank<=1)return t.clone();let n={x:t},o={perm:e};return C.runKernel(Yo,n,o)}var Kw=S({transpose_:D$});var cs={};Ie(cs,{fromPixels:()=>U$,fromPixelsAsync:()=>M$,toPixels:()=>B$});function Xw(r,e,t){if(Di(r),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=us(r,t);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Fn(r,e,n,t)}var ja;function Yw(r,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,n=!1,o=!1,s=!1,i=!1,a=!1;if(r.data instanceof Uint8Array)t=!0;else if(typeof ImageData!="undefined"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)i=!0;else if(typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(o){let d=2;if(o&&r.readyState<d)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(Wi(Ui,C.backendName)!=null){let d={pixels:r},h={numChannels:e};return C.runKernel(Ui,d,h)}let[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],p;i?p=r.getContext("2d").getImageData(0,0,l,c).data:n||t?p=r.data:(s||o||a)&&(ja==null&&(ja=document.createElement("canvas").getContext("2d")),ja.canvas.width=l,ja.canvas.height=c,ja.drawImage(r,0,0,l,c),p=ja.getImageData(0,0,l,c).data);let m;if(e===4)m=new Int32Array(p);else{let d=l*c;m=new Int32Array(d*e);for(let h=0;h<d;h++)for(let g=0;g<e;++g)m[h*e+g]=p[h*4+g]}return Xw(m,[c,l,e],"int32")}function O$(r){return r!=null&&r.data instanceof Uint8Array}function F$(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function P$(r){return r!=null&&r.width!==0&&r.height!==0}function L$(r){return F$()&&!(r instanceof ImageBitmap)&&P$(r)&&!O$(r)}async function M$(r,e=3){let t=null;if($().getBool("WRAP_TO_IMAGEBITMAP")&&L$(r)){let n;try{n=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch(o){n=null}n!=null&&n.width===r.width&&n.height===r.height?t=n:t=r}else t=r;return Yw(t,e)}async function B$(r,e){let t=v(r,"img","toPixels");if(!(r instanceof ze)){let l=t;t=ge(l,"int32"),l.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);let[n,o]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);let i=await t.data(),a=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(o*n*4);for(let l=0;l<n*o;++l){let c=[0,0,0,255];for(let m=0;m<s;m++){let f=i[l*s+m];if(t.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(t.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(c[0]=f*a,c[1]=f*a,c[2]=f*a):c[m]=f*a}let p=l*4;u[p+0]=Math.round(c[0]),u[p+1]=Math.round(c[1]),u[p+2]=Math.round(c[2]),u[p+3]=Math.round(c[3])}if(e!=null){e.width=o,e.height=n;let l=e.getContext("2d"),c=new ImageData(u,o,n);l.putImageData(c,0,0)}return t!==r&&t.dispose(),u}var U$=S({fromPixels_:Yw});var Pc={};Ie(Pc,{prepareAndValidate:()=>Jw});function Jw(r,e){let t=r.shape.length,n=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[n-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[n-1]} vs. ${t}`);if(Se(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let o=e.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=r.shape,u=o.slice();u.pop();let l=1;for(let p=s;p<t;++p)l*=a[p],u.push(a[p]);let c=[...mr(r.shape).map(p=>p/l),1].slice(0,s);return[u,i,l,c]}var Lc={};Ie(Lc,{calculateShapes:()=>Qw,validateInput:()=>Mc,validateUpdateShape:()=>Cd});function Cd(r,e,t){let n=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${o}.`;if(t.rank<o)throw new Error(s+` update.rank < ${o}. `);if(r.length<n+(t.rank-o))throw new Error(s+` Output shape length < ${n+(t.rank-o)}`);if(t.rank!==o+r.length-n)throw new Error(s+` update.rank != ${o+r.length-n}`);for(let i=0;i<o;++i)if(t.shape[i]!==e.shape[i])throw new Error(s+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<t.rank-o;++i)if(t.shape[i+o]!==r[i+n])throw new Error(s+` updates.shape[${i+o}] (${t.shape[i+o]}) != shape[${i+o}] (${r[i+o]})`)}function Mc(r,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}Cd(t,e,r)}function Qw(r,e,t){let n=e.shape.length,o=n>1?e.shape[n-1]:1,s=t.length,i=1;for(let p=o;p<s;++p)i*=t[p];let a=o<1?1:o,u=Se(e.shape)/a,l=[...mr(t.slice(0,o)),1],c=Se(t);return{sliceRank:o,numUpdates:u,sliceSize:i,strides:l,outputSize:c}}var st={};Ie(st,{assertParamsValid:()=>W$,computeFlatOffset:()=>G$,computeOutShape:()=>Zw,getNormalizedAxes:()=>uv,isSliceContinous:()=>V$,maskToAxes:()=>Bc,parseSliceParams:()=>z$,sliceInfo:()=>H$,startForAxis:()=>av,startIndicesWithElidedDims:()=>nv,stopForAxis:()=>iv,stopIndicesWithElidedDims:()=>ov,stridesForAxis:()=>sv,stridesWithElidedDims:()=>ev});function W$(r,e,t){let n=r.shape.length;E(n===e.length,()=>`Error in slice${n}D: Length of begin ${e} must match the rank of the array (${n}).`),E(n===t.length,()=>`Error in slice${n}D: Length of size ${t} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)E(e[o]+t[o]<=r.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${e[o]+t[o]}) would overflow input.shape[${o}] (${r.shape[o]})`)}function Bc(r){let e=[],t=0;for(;r>0;)r&1&&e.push(t),r/=2,t++;return e}function Zw(r,e,t){let n=[];for(let o=0;o<r.length;o++)n[o]=Math.ceil((e[o]-r[o])/t[o]);return n}function ev(r,e,t,n){let o=[...r];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<t;s++)s===0?o[e]=1:(o.splice(e,0,1),o.pop());return o}function tv(r,e,t){return t<=r?t:t-(e-1)}function rv(r,e){let t=[];for(let n=0;n<r;n++)t.push(e+n);return t}function uv(r,e,t,n,o,s,i,a,u){let l=r.length,c=new Array(l),p=new Array(l),m=new Array(l);if(e.length&&t>0){let f=e[0],d=t+1;c=nv(i,f,d,n,r),p=ov(a,f,d,o,r),m=ev(s,f,d,r)}else for(let f=0;f<l;f++)c[f]=av(i,n,s,r,f,u),p[f]=iv(a,o,s,r,f,u),m[f]=sv(s,f,u);return{begin:c,end:p,strides:m}}function nv(r,e,t,n,o){let s=[...o],i=rv(t,e);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let u=tv(e,t,a),l=n[u];r&1<<u&&(l=0),s[a]=l}return s}function ov(r,e,t,n,o){let s=[...o],i=rv(t,e);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let u=tv(e,t,a),l=n[u];r&1<<u&&(l=Number.MAX_SAFE_INTEGER),s[a]=l}for(let a=0;a<s.length;a++){let u=o[a];s[a]<0&&(s[a]+=u),s[a]=na(0,s[a],o[a])}return s}function sv(r,e,t){let n=r[e];return(t&1<<e||n==null)&&(n=1),n}function av(r,e,t,n,o,s){let i=e[o],a=t[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),i=na(0,i,u-1),i}function iv(r,e,t,n,o,s){let i=e[o],a=t[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),a>0?i=na(0,i,u):i=na(-1,i,u-1),i}function V$(r,e,t){let n=t.length;for(let o=0;o<t.length;o++)if(t[o]>1){n=o;break}for(let o=n+1;o<t.length;o++)if(e[o]>0||t[o]!==r[o])return!1;return!0}function G$(r,e){let t=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)t+=r[n]*e[n];return t}function z$(r,e,t){let n,o=r.shape.length;typeof e=="number"?n=[e,...new Array(o-1).fill(0)]:e.length<o?n=e.concat(new Array(o-e.length).fill(0)):n=e.slice(),n.forEach(i=>{E(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(o).fill(-1):typeof t=="number"?s=[t,...new Array(o-1).fill(-1)]:t.length<o?s=t.concat(new Array(o-t.length).fill(-1)):s=t,s=s.map((i,a)=>i>=0?i:(E(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),r.shape[a]-n[a])),[n,s]}function H$(r,e,t,n,o,s,i,a,u){let l=e.slice(),c=t.slice(),p=n;n==null&&(p=new Array(l.length));let m=Bc(i);if(m.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(i!==0&&a!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(i!==0&&u!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let f=r.length-l.length,d=Bc(a),h=r.slice();d.forEach(D=>{l[D]=0,c[D]=1,h.splice(D,0,1)});let{begin:g,end:y,strides:I}=uv(h,m,f,l,c,p,o,s,i);l=g,c=y,p=I;let _=Bc(u);_.forEach(D=>{c[D]=l[D]+1,p[D]=1});let N=Zw(l,c,p),R=N.filter((D,O)=>_.indexOf(O)===-1);return{nonStrided:p.every(D=>D===1),$begin:l,$end:c,$strides:p,size:N,newShape:h,outShape:R}}function lv(r){$().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}cw(lv);function Bn(){return C}function xe(r,e){return C.tidy(r,e)}function er(r){return C.keep(r)}function Uc(r){return C.setBackend(r)}function cv(){return C.ready()}function Un(){return C.backendName}function pv(r){C.removeBackend(r)}function qa(r,e,t=1){return C.registerBackend(r,e,t)}function j$(r,e){let t=v(r,"a","add"),n=v(e,"b","add");[t,n]=ae(t,n);let o={a:t,b:n};return C.runKernel(fr,o)}var Lt=S({add_:j$});function q$(r,e){let t=v(r,"a","floorDiv"),n=v(e,"b","floorDiv");[t,n]=ae(t,n);let o={a:t,b:n};return C.runKernel(xa,o)}var qi=S({floorDiv_:q$});function K$(r,e){let t=v(r,"a","div"),n=v(e,"b","div");if([t,n]=ae(t,n),t.dtype==="int32"&&n.dtype==="int32")return qi(t,n);let o={a:t,b:n},s={};return C.runKernel(ma,o,s)}var xr=S({div_:K$});function X$(r,e){let t=v(r,"a","mul"),n=v(e,"b","mul");[t,n]=ae(t,n);let o={a:t,b:n};return C.runKernel(In,o)}var Ye=S({mul_:X$});function Y$(r){let e=v(r,"x","abs");if(e.dtype==="complex64"){let t={x:e};return C.runKernel(Ml,t)}else{let t={x:e};return C.runKernel(co,t)}}var Td=S({abs_:Y$});function J$(r){let t={x:v(r,"x","acos")};return C.runKernel(Nl,t)}var Sd=S({acos_:J$});function Q$(r){let t={x:v(r,"x","acosh")};return C.runKernel(El,t)}var kd=S({acosh_:Q$});function Z$(r){E(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),E(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let e=r.map((o,s)=>v(o,`tensors${s}`,"addN")),t=e[0];e.forEach(o=>{if(o.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(o=>{if(!pr(o.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=e;return C.runKernel(po,n)}var Nd=S({addN_:Z$});function eD(r,e=null,t=!1){let o={x:v(r,"x","all","bool")},s={axis:e,keepDims:t};return C.runKernel(mo,o,s)}var Ed=S({all_:eD});function tD(r,e=null,t=!1){let o={x:v(r,"x","any","bool")},s={axis:e,keepDims:t};return C.runKernel(fo,o,s)}var Ad=S({any_:tD});function rD(r,e=0){let n={x:v(r,"x","argMax")},o={axis:e};return C.runKernel(ho,n,o)}var Rd=S({argMax_:rD});function nD(r,e=0){let n={x:v(r,"x","argMin")},o={axis:e};return C.runKernel(Al,n,o)}var $d=S({argMin_:nD});function oD(r){let t={x:v(r,"x","asin")};return C.runKernel(Rl,t)}var Dd=S({asin_:oD});function sD(r){let t={x:v(r,"x","asinh")};return C.runKernel($l,t)}var Od=S({asinh_:sD});function aD(r){let t={x:v(r,"x","atan")};return C.runKernel(Dl,t)}var Fd=S({atan_:aD});function iD(r,e){let t=v(r,"a","atan2"),n=v(e,"b","atan2");[t,n]=ae(t,n);let o={a:t,b:n};return C.runKernel(Fl,o)}var Pd=S({atan2_:iD});function uD(r){let t={x:v(r,"x","atanh")};return C.runKernel(Ol,t)}var Ld=S({atanh_:uD});function lD(r,e,t,n,o="NHWC",s){let i=r[3],a=[...e,i],u=mv(o);return ps(r,a,t,s,n,null,null,u)}function cD(r,e,t,n,o,s,i="channelsLast"){let[a,u]=Wc(e),l;if(i==="channelsLast")l=[a,u,r[3],r[3]];else if(i==="channelsFirst")l=[a,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return ps(r,l,t,n,o,s,!1,i)}function pD(r,e,t,n,o,s,i="NDHWC"){let[a,u,l]=Md(e),c,p;if(i==="NDHWC")p="channelsLast",c=[a,u,l,r[4],r[4]];else if(i==="NCDHW")p="channelsFirst",c=[a,u,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return fv(r,c,t,n,o,!1,p,s)}function ps(r,e,t,n,o,s,i=!1,a="channelsLast"){let[u,l,c,p]=[-1,-1,-1,-1];if(a==="channelsLast")[u,l,c,p]=r;else if(a==="channelsFirst")[u,p,l,c]=r;else throw new Error(`Unknown dataFormat ${a}`);let[m,f,,d]=e,[h,g]=Wc(t),[y,I]=Wc(n),_=Ka(m,y),N=Ka(f,I),{padInfo:R,outHeight:F,outWidth:D}=mD(o,l,c,h,g,_,N,s,a),O=i?d*p:d,U;return a==="channelsFirst"?U=[u,O,F,D]:a==="channelsLast"&&(U=[u,F,D,O]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:c,inChannels:p,outHeight:F,outWidth:D,outChannels:O,padInfo:R,strideHeight:h,strideWidth:g,filterHeight:m,filterWidth:f,effectiveFilterHeight:_,effectiveFilterWidth:N,dilationHeight:y,dilationWidth:I,inShape:r,outShape:U,filterShape:e}}function fv(r,e,t,n,o,s=!1,i="channelsLast",a){let[u,l,c,p,m]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,p,m]=r;else if(i==="channelsFirst")[u,m,l,c,p]=r;else throw new Error(`Unknown dataFormat ${i}`);let[f,d,h,,g]=e,[y,I,_]=Md(t),[N,R,F]=Md(n),D=Ka(f,N),O=Ka(d,R),U=Ka(h,F),{padInfo:M,outDepth:G,outHeight:j,outWidth:ee}=fD(o,l,c,p,y,I,_,D,O,U,a),Q=s?g*m:g,ie;return i==="channelsFirst"?ie=[u,Q,G,j,ee]:i==="channelsLast"&&(ie=[u,G,j,ee,Q]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:p,inChannels:m,outDepth:G,outHeight:j,outWidth:ee,outChannels:Q,padInfo:M,strideDepth:y,strideHeight:I,strideWidth:_,filterDepth:f,filterHeight:d,filterWidth:h,effectiveFilterDepth:D,effectiveFilterHeight:O,effectiveFilterWidth:U,dilationDepth:N,dilationHeight:R,dilationWidth:F,inShape:r,outShape:ie,filterShape:e}}function dD(r,e,t,n,o){n==null&&(n=Bd(r,e,t));let s=r[0],i=r[1],a=ms((s-e+2*n)/t+1,o),u=ms((i-e+2*n)/t+1,o);return[a,u]}function hD(r,e,t,n,o,s){o==null&&(o=Bd(r,e,n));let i=r[0],a=r[1],u=r[2],l=ms((i-e+2*o)/n+1,s),c=ms((a-e+2*o)/n+1,s),p=ms((u-e+2*o)/n+1,s);return[l,c,p,t]}function Bd(r,e,t,n=1){let o=Ka(e,n);return Math.floor((r[0]*(t-1)-t+o)/2)}function Wc(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function Md(r){return typeof r=="number"?[r,r,r]:r}function Ka(r,e){return e<=1?r:r+(r-1)*(e-1)}function mD(r,e,t,n,o,s,i,a,u){let l,c,p;if(typeof r=="number"){l={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let f=dD([e,t],s,n,r,a);c=f[0],p=f[1]}else if(r==="same"){c=Math.ceil(e/n),p=Math.ceil(t/o);let m=Math.max(0,(c-1)*n+s-e),f=Math.max(0,(p-1)*o+i-t),d=Math.floor(m/2),h=m-d,g=Math.floor(f/2),y=f-g;l={top:d,bottom:h,left:g,right:y,type:"SAME"}}else if(r==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-s+1)/n),p=Math.ceil((t-i+1)/o);else if(typeof r=="object"){let m=u==="channelsLast"?r[1][0]:r[2][0],f=u==="channelsLast"?r[1][1]:r[2][1],d=u==="channelsLast"?r[2][0]:r[3][0],h=u==="channelsLast"?r[2][1]:r[3][1];l={top:m,bottom:f,left:d,right:h,type:m===0&&f===0&&d===0&&h===0?"VALID":"EXPLICIT"},c=ms((e-s+m+f)/n+1,a),p=ms((t-i+d+h)/o+1,a)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:l,outHeight:c,outWidth:p}}function fD(r,e,t,n,o,s,i,a,u,l,c){let p,m,f,d;if(typeof r=="number"){p={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=hD([e,t,n,1],a,1,o,r,c);m=g[0],f=g[1],d=g[2]}else if(r==="same"){m=Math.ceil(e/o),f=Math.ceil(t/s),d=Math.ceil(n/i);let h=(m-1)*o+a-e,g=(f-1)*s+u-t,y=(d-1)*i+l-n,I=Math.floor(h/2),_=h-I,N=Math.floor(g/2),R=g-N,F=Math.floor(y/2),D=y-F;p={top:N,bottom:R,left:F,right:D,front:I,back:_,type:"SAME"}}else if(r==="valid")p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},m=Math.ceil((e-a+1)/o),f=Math.ceil((t-u+1)/s),d=Math.ceil((n-l+1)/i);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:p,outDepth:m,outHeight:f,outWidth:d}}function ms(r,e){if(!e)return Math.trunc(r);switch(e){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${e}`)}}function fs(r){let[e,t,n]=Wc(r);return e===1&&t===1&&n===1}function It(r,e){return fs(r)||fs(e)}function mv(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function gD(r,e){let n={x:v(r,"x","reshape","string_or_numeric")},o={shape:e};return C.runKernel(Ta,n,o)}var W=S({reshape_:gD});function xD(r,e,t,n,o){let s=v(r,"x","avgPool","float32"),i=1;E(It(t,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);let a=s,u=!1;s.rank===3&&(u=!0,a=W(s,[1,s.shape[0],s.shape[1],s.shape[2]])),E(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),o!=null&&E(Re(n),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${o} but got pad ${n}.`);let l={x:a},c={filterSize:e,strides:t,pad:n,dimRoundingMode:o},p=C.runKernel(go,l,c);return p=ge(p,s.dtype),u?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Ud=S({avgPool_:xD});function _D(r,e,t,n,o,s="NDHWC"){let i=v(r,"x","avgPool3d","float32"),a=i,u=!1;i.rank===4&&(u=!0,a=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),E(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),E(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),o!=null&&E(Re(n),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${n}.`);let l={x:a},c={filterSize:e,strides:t,pad:n,dimRoundingMode:o,dataFormat:s},p=C.runKernel(Pl,l,c);return p=ge(p,a.dtype),u?W(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Wd=S({avgPool3d_:_D});function yD(r,e=0){E(r.length>=1,()=>"Pass at least one tensor to concat");let t=kc(r,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return zr(t[0]);let n=t,o={axis:e};return C.runKernel(la,n,o)}var Ht=S({concat_:yD});function bD(r){let t={x:v(r,"x","sigmoid")};return C.runKernel(kn,t)}var Ki=S({sigmoid_:bD});function wD(r,e,t){let n=v(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:e,size:t};return C.runKernel(zo,o,s)}var Ct=S({slice_:wD});function vD(r){let t={x:v(r,"x","tanh")};return C.runKernel(Da,t)}var Vd=S({tanh_:vD});function ID(r,e,t){let n=v(r,"x","batchToSpaceND"),o=e.reduce((a,u)=>a*u);E(n.rank>=1+e.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${e.length}`),E(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),E(n.shape[0]%o==0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${o}`);let s={x:n},i={blockShape:e,crops:t};return C.runKernel(ua,s,i)}var Gd=S({batchToSpaceND_:ID});function dv(r){let e;return r.rank===0||r.rank===1?e=W(r,[1,1,1,r.size]):r.rank===2?e=W(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?e=W(r,[1,r.shape[0],r.shape[1],r.shape[2]]):e=r,e}function CD(r,e,t,n,o,s){s==null&&(s=.001);let i=v(r,"x","batchNorm"),a=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let c;n!=null&&(c=v(n,"offset","batchNorm")),E(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let m={x:dv(i),scale:l,offset:c,mean:a,variance:u},f={varianceEpsilon:s},d=C.runKernel(So,m,f);return W(d,i.shape)}var Vc=S({batchNorm_:CD});function TD(r,e,t){let n=v(r,"x","bincount"),o=v(e,"weights","bincount");E(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),E(t>=0,()=>`size must be non-negative, but got ${t}.`),E(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},i={size:t};return C.runKernel(Ll,s,i)}var Xi=S({bincount_:TD});function SD(r,e){let t=v(r,"s0","broadcastArgs","int32"),n=v(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);let o={s0:t,s1:n};return C.runKernel(kb,o)}var zd=S({broadcastArgs_:SD});function kD(r,e){let t=v(r,"broadcastTo","x"),n=t.shape;if(e.some(l=>!(l>0)||l%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){let l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=W(t,l)}let o=t.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(o[l]===e[l])s[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${e}].`);if(s.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return zr(t);let a={x:t},u={reps:s};return C.runKernel(Ur,a,u)}var ds=S({broadcastTo_:kD});function ND(r){let t={x:v(r,"x","ceil")};return C.runKernel(mn,t)}var Hd=S({ceil_:ND});function ED(r,e,t){let n=v(r,"x","clipByValue");E(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`);let o={x:n},s={clipValueMin:e,clipValueMax:t};return C.runKernel(_o,o,s)}var jd=S({clipByValue_:ED});function AD(r,e,t,n,o="NHWC",s=[1,1],i){let a=v(r,"x","conv2d"),u=v(e,"filter","conv2d"),l=a,c=!1;a.rank===3&&(c=!0,l=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),E(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),E(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),i!=null&&E(Re(n),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${n}.`);let p=o==="NHWC"?l.shape[3]:l.shape[1];E(p===u.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${u.shape[2]}.`),E(It(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let m={x:l,filter:u},f={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},d=C.runKernel(yo,m,f);return c?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var hs=S({conv2d_:AD});function RD(r,e,t,n,o="NWC",s=1,i){let a=v(r,"x","conv1d"),u=v(e,"filter","conv1d"),l=a,c=!1;a.rank===2&&(c=!0,l=W(a,[1,a.shape[0],a.shape[1]])),E(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),E(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),i!=null&&E(Re(n),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${n}.`),E(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),E(It(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),E(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=W(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=W(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=hs(m,p,[1,t],n,"NHWC",[1,s],i);return c?W(g,[g.shape[2],g.shape[3]]):W(g,[g.shape[0],g.shape[2],g.shape[3]])}var qd=S({conv1d_:RD});function $D(r,e,t,n,o,s="NHWC",i){E(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let a=r,u=e,l=!1;e.rank===3&&(l=!0,u=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,r[0],r[1],r[2]]),E(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),E(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),E(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);let c=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?u.shape[3]:u.shape[1];E(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),E(p===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${t.shape[3]}.`),i!=null&&E(Re(o),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`);let m={dy:u,filter:t},f={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},d=C.runKernel(bo,m,f);return l?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Gc=S({conv2DBackpropInput_:$D});function DD(r,e,t,n,o,s){let i=v(r,"x","conv2dTranspose"),a=v(e,"filter","conv2dTranspose");return Gc(t,i,a,n,o,"NHWC",s)}var Kd=S({conv2dTranspose_:DD});function OD(r,e,t,n,o="NDHWC",s=[1,1,1]){let i=v(r,"x","conv3d"),a=v(e,"filter","conv3d"),u=i,l=!1;i.rank===4&&(l=!0,u=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),E(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),E(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),E(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),E(It(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),E(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);let c={x:u,filter:a},p={strides:t,pad:n,dataFormat:o,dilations:s},m=C.runKernel(Ul,c,p);return l?W(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Xd=S({conv3d_:OD});function FD(r){let t={x:v(r,"x","cos")};return C.runKernel(ca,t)}var Yd=S({cos_:FD});function PD(r){let t={x:v(r,"x","cosh")};return C.runKernel(pa,t)}var Jd=S({cosh_:PD});function LD(r,e=0,t=!1,n=!1){let s={x:v(r,"x","cumsum")},i={axis:e,exclusive:t,reverse:n};return C.runKernel(wo,s,i)}var Qd=S({cumsum_:LD});function MD(r,e,t,n=!1){let o=v(r,"x","denseBincount"),s=v(e,"weights","denseBincount");E(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),E(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),E(t>=0,()=>`size must be non-negative, but got ${t}.`),E(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:t,binaryOutput:n};return C.runKernel(Wl,i,a)}var Zd=S({denseBincount_:MD});function BD(r,e,t="NHWC"){let n=v(r,"x","depthToSpace"),o=t==="NHWC"?n.shape[1]:n.shape[2],s=t==="NHWC"?n.shape[2]:n.shape[3],i=t==="NHWC"?n.shape[3]:n.shape[1];E(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e}  for depthToSpace with input shape
    ${n.shape}`),E(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${n.shape}`),E(i%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${n.shape}`);let a={x:n},u={blockSize:e,dataFormat:t};return C.runKernel(Io,a,u)}var eh=S({depthToSpace_:BD});function UD(r,e,t,n,o="NHWC",s=[1,1],i){let a=v(r,"x","depthwiseConv2d"),u=v(e,"filter","depthwiseConv2d"),l=a,c=!1;a.rank===3&&(c=!0,l=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),E(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),E(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),E(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),i!=null&&E(Re(n),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${n}.`);let p={x:l,filter:u},m={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},f=C.runKernel(Co,p,m);return c?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Yi=S({depthwiseConv2d_:UD});function WD(r,e,t,n,o=[1,1],s="NHWC"){let i=v(r,"x","dilation2d"),a=v(e,"filter","dilation2d");E(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),E(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),E(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=i,l=!1;i.rank===3&&(u=W(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0);let c={x:u,filter:a},p={strides:t,pad:n,dilations:o},m=C.runKernel(zl,c,p);return l?W(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var th=S({dilation2d_:WD});function VD(r,e){let t=r.length,n=[];for(let o=0;o<t;o++){let s=t-1-o,i=r[s]||1;(e[e.length-1-o]||1)>1&&i===1&&n.unshift(s)}return n}function rh(r,e){let t=[];for(let n=0;n<e.length;n++){let o=r[r.length-n-1],s=e.length-n-1,i=e[s];(o==null||o===1&&i>1)&&t.unshift(s)}return t}function be(r,e){let t=[],n=Math.max(r.length,e.length);for(let o=0;o<n;o++){let s=r[r.length-o-1];s==null&&(s=1);let i=e[e.length-o-1];if(i==null&&(i=1),s===1)t.unshift(i);else if(i===1)t.unshift(s);else if(s!==i){let a=`Operands could not be broadcast together with shapes ${r} and ${e}.`;throw Error(a)}else t.unshift(s)}return t}function GD(r,e){let t=v(r,"a","equal","string_or_numeric"),n=v(e,"b","equal","string_or_numeric");[t,n]=ae(t,n),be(t.shape,n.shape);let o={a:t,b:n};return C.runKernel(fn,o)}var Ji=S({equal_:GD});function zD(r,e,t){let n=v(e,"a","where"),o=v(t,"b","where"),s=v(r,"condition","where","bool"),i=be(be(s.shape,n.shape),o.shape),a=ds(s,i),u=ds(n,i),l=ds(o,i),c={condition:a,t:u,e:l};return C.runKernel(Na,c)}var Wn=S({where_:zD});function HD(r){let t={x:v(r,"x","zerosLike")};return C.runKernel(Fa,t)}var gs=S({zerosLike_:HD});function jD(r,e){let t=v(r,"a","div"),n=v(e,"b","div");[t,n]=ae(t,n);let o=xr(t,n),s=gs(o),i=Ji(n,s);return Wn(i,s,o)}var nh=S({divNoNan_:jD});function qD(r,...e){let t=e.map((o,s)=>v(o,`tensors${s}`,"einsum")),n={equation:r};return C.runKernel(Hl,t,n)}var oh=S({einsum_:qD});function KD(r){let t={x:v(r,"x","elu")};return C.runKernel(fa,t)}var Qi=S({elu_:KD});function XD(r){let e=v(r,"x","erf");E(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=ge(e,"float32"));let t={x:e};return C.runKernel(jl,t)}var sh=S({erf_:XD});function YD(r){let t={x:v(r,"x","exp")};return C.runKernel(dn,t)}var Xa=S({exp_:YD});function JD(r,e=0){let t=v(r,"x","expandDims","string_or_numeric");E(e<=t.rank,()=>"Axis must be <= rank of the tensor");let n={input:t},o={dim:e};return C.runKernel(da,n,o)}var ah=S({expandDims_:JD});function QD(r){let t={x:v(r,"x","expm1")};return C.runKernel(ha,t)}var ih=S({expm1_:QD});function ZD(r,e){let t=v(r,"x","tile","string_or_numeric");E(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);let n={x:t},o={reps:e};return C.runKernel(Ur,n,o)}var Zi=S({tile_:ZD});function eu(r,e,t){let n={shape:r,value:e,dtype:t};return C.runKernel(ga,{},n)}function eO(r){let t={x:v(r,"x","floor")};return C.runKernel(hn,t)}var uh=S({floor_:eO});function tO(r,e,t=0,n=0){let o=v(r,"x","gather"),s=v(e,"indices","gather","int32"),i={x:o,indices:s},a={axis:t,batchDims:n};return C.runKernel(_a,i,a)}var zc=S({gather_:tO});function rO(r,e){let t=v(r,"a","greater","string_or_numeric"),n=v(e,"b","greater","string_or_numeric");[t,n]=ae(t,n),be(t.shape,n.shape);let o={a:t,b:n};return C.runKernel(gn,o)}var Ya=S({greater_:rO});function nO(r,e){let t=v(r,"a","greaterEqual","string_or_numeric"),n=v(e,"b","greaterEqual","string_or_numeric");[t,n]=ae(t,n),be(t.shape,n.shape);let o={a:t,b:n};return C.runKernel(xn,o)}var lh=S({greaterEqual_:nO});function oO(r){let t={input:v(r,"input","imag")};return C.runKernel(Xl,t)}var xs=S({imag_:oO});function sO(r){let t={x:v(r,"x","isNaN")};return C.runKernel(Yl,t)}var ch=S({isNaN_:sO});function aO(r,e=.2){let n={x:v(r,"x","leakyRelu")},o={alpha:e};return C.runKernel(No,n,o)}var tu=S({leakyRelu_:aO});function iO(r,e){let t=v(r,"a","less","string_or_numeric"),n=v(e,"b","less","string_or_numeric");[t,n]=ae(t,n),be(t.shape,n.shape);let o={a:t,b:n};return C.runKernel(_n,o)}var ph=S({less_:iO});function uO(r,e){let t=v(r,"a","lessEqual","string_or_numeric"),n=v(e,"b","lessEqual","string_or_numeric");[t,n]=ae(t,n),be(t.shape,n.shape);let o={a:t,b:n};return C.runKernel(yn,o)}var ru=S({lessEqual_:uO});function mh(r,e,t){if(t<=0)throw new Error("The number of values should be positive.");let n={start:r,stop:e,num:t};return C.runKernel(Jl,{},n)}function lO(r,e=5,t=1,n=1,o=.5){let s=v(r,"x","localResponseNormalization");E(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),E(Re(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=W(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:i},l={depthRadius:e,bias:t,alpha:n,beta:o},c=C.runKernel(tc,u,l);return a?W(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var fh=S({localResponseNormalization_:lO});function cO(r){let t={x:v(r,"x","log")};return C.runKernel(bn,t)}var nu=S({log_:cO});function pO(r){let t={x:v(r,"x","log1p")};return C.runKernel(Ql,t)}var dh=S({log1p_:pO});function tr(r){return C.customGrad(r)}function mO(r){let t={x:v(r,"x","neg")};return C.runKernel(Oo,t)}var hh=S({neg_:mO});function fO(r){let t={x:v(r,"x","softplus")};return C.runKernel(pc,t)}var gh=S({softplus_:fO});function dO(r,e=null,t=!1){let o={x:v(r,"x","max")},s={reductionIndices:e,keepDims:t};return C.runKernel(Eo,o,s)}var ou=S({max_:dO});function hO(r,e){let t=v(r,"a","sub"),n=v(e,"b","sub");[t,n]=ae(t,n);let o={a:t,b:n};return C.runKernel(An,o)}var _r=S({sub_:hO});function gO(r,e=null,t=!1){let n=v(r,"x","sum");n.dtype==="bool"&&(n=ge(n,"int32"));let o={x:n},s={axis:e,keepDims:t};return C.runKernel(Ho,o,s)}var Tt=S({sum_:gO});function xO(r,e=-1){let t=v(r,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return tr((o,s)=>{let i=!0,a=ou(o,e,!0),u=_r(o,a),l=_r(ge(u,"float32"),nu(Tt(Xa(u),e,i)));return s([l]),{value:l,gradFunc:(p,m)=>{let[f]=m,d=!0,h=Xa(f);return _r(p,Ye(Tt(p,e,d),h))}}})(t)}var xh=S({logSoftmax_:xO});function _h(r,e){for(let t=0;t<r.length;++t)if(r[r.length-t-1]!==e-1-t)return!1;return!0}function hv(r,e,t){let n=r.length+e.length,o=[],s=0,i=0;for(let a=0;a<n;a++)t.indexOf(a)===-1?o.push(r[s++]):o.push(e[i++]);return o}function _O(r,e){let t=[],n=r.length;for(let s=0;s<n;s++)e.indexOf(s)===-1&&t.push(r[s]);let o=e.map(s=>r[s]);return[t,o]}function yO(r,e){let t=e.map(n=>1);return hv(r,t,e)}function bO(r,e,t){E(_h(e,t),()=>`${r} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function wO(r,e){if(_h(r,e))return null;let t=[];for(let n=0;n<e;++n)r.indexOf(n)===-1&&t.push(n);return r.forEach(n=>t.push(n)),t}function vO(r){return r.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function IO(r,e){let t=[];for(let n=e-r;n<e;++n)t.push(n);return t}function CO(r,e){let t=v(r,"a","logicalAnd","bool"),n=v(e,"b","logicalAnd","bool");be(t.shape,n.shape);let o={a:t,b:n};return C.runKernel(ya,o)}var yh=S({logicalAnd_:CO});function TO(r){let t={x:v(r,"x","logicalNot","bool")};return C.runKernel(Zl,t)}var bh=S({logicalNot_:TO});function SO(r,e){let t=v(r,"a","logicalOr","bool"),n=v(e,"b","logicalOr","bool");be(t.shape,n.shape);let o={a:t,b:n};return C.runKernel(ec,o)}var wh=S({logicalOr_:SO});function kO(r,e,t,n,o){let s=v(r,"x","maxPool"),i=1,a=s,u=!1;s.rank===3&&(u=!0,a=W(s,[1,s.shape[0],s.shape[1],s.shape[2]])),E(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),E(It(t,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),o!=null&&E(Re(n),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${o} but got pad ${n}.`);let l={x:a},c={filterSize:e,strides:t,pad:n,dimRoundingMode:o},p=C.runKernel(Ao,l,c);return u?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var vh=S({maxPool_:kO});function NO(r,e=[1,1,1],t,n,o,s="NDHWC"){let i=v(r,"x","maxPool3d"),a=i,u=!1;i.rank===4&&(u=!0,a=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),E(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),E(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),o!=null&&E(Re(n),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${n}.`);let l={x:a},c={filterSize:e,strides:t,pad:n,dimRoundingMode:o,dataFormat:s},p=C.runKernel(rc,l,c);return u?W(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Ih=S({maxPool3d_:NO});function EO(r,e,t,n,o=!1){let i={x:v(r,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:n,includeBatchInIndex:o},u=C.runKernel(nc,i,a);return{result:u[0],indexes:u[1]}}var Ch=S({maxPoolWithArgmax_:EO});function AO(r,e){let t=v(r,"a","maximum"),n=v(e,"b","maximum");[t,n]=ae(t,n),t.dtype==="bool"&&(t=ge(t,"int32"),n=ge(n,"int32")),be(t.shape,n.shape);let o={a:t,b:n};return C.runKernel(wn,o)}var Th=S({maximum_:AO});function RO(r,e=null,t=!1){let o={x:v(r,"x","mean")},s={axis:e,keepDims:t};return C.runKernel(Ro,o,s)}var Sh=S({mean_:RO});function rr(r,e="float32"){if(e==="complex64"){let n=rr(r,"float32"),o=rr(r,"float32");return Dt(n,o)}let t=ia(Se(r),e);return C.makeTensor(t,r,e)}function Hc(r,e="float32"){if(e==="complex64"){let n=Hc(r,"float32"),o=rr(r,"float32");return Dt(n,o)}let t=Oi(Se(r),e);return C.makeTensor(t,r,e)}function $O(r,e=null,t=!1){let o={x:v(r,"x","min")},s={axis:e,keepDims:t};return C.runKernel($o,o,s)}var kh=S({min_:$O});function DO(r,e){let t=v(r,"a","minimum"),n=v(e,"b","minimum");[t,n]=ae(t,n),t.dtype==="bool"&&(t=ge(t,"int32"),n=ge(n,"int32")),be(t.shape,n.shape);let o={a:t,b:n};return C.runKernel(vn,o)}var Nh=S({minimum_:DO});function OO(r,e,t){E(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);let n=v(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");E(e.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${e.length}.`);let o=t==="reflect"?1:0;for(let a=0;a<n.rank;a++)E(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),E(e[a][0]>=0&&e[a][0]<=n.shape[a]-o&&e[a][1]>=0&&e[a][1]<=n.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${n.shape[a]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:e,mode:t},i={x:n};return C.runKernel(Do,i,s)}var Eh=S({mirrorPad_:OO});function FO(r,e){let t=v(r,"a","mod"),n=v(e,"b","mod");[t,n]=ae(t,n);let o={a:t,b:n};return C.runKernel(oc,o)}var Ah=S({mod_:FO});function PO(r){let e=v(r,"x","square"),t={};return C.runKernel("Square",{x:e},t)}var Rh=S({square_:PO});function LO(r,e,t,n=!1){let o=v(r,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();let u={logits:i===1?W(o,[1,-1]):o},l={numSamples:e,seed:t,normalized:n},c=C.runKernel(sc,u,l);return i===1?W(c,[c.size]):c}var $h=S({multinomial_:LO});function MO(r,e){let t=v(r,"a","notEqual","string_or_numeric"),n=v(e,"b","notEqual","string_or_numeric");[t,n]=ae(t,n),be(t.shape,n.shape);let o={a:t,b:n};return C.runKernel(Cn,o)}var Dh=S({notEqual_:MO});function BO(r){let t={x:v(r,"x","onesLike")};return C.runKernel(ba,t)}var Oh=S({onesLike_:BO});function UO(r,e,t=0){let n=v(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:e,constantValue:t},s={x:n};return C.runKernel(Bo,s,o)}var Fh=S({pad_:UO});function WO(r,e,t){let n=v(r,"x","spaceToBatchND");E(n.rank>=1+e.length,()=>`input rank ${n.rank} should be > than [blockShape] ${e.length}`),E(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),E(n.shape.reduce((i,a,u)=>u>0&&u<=e.length?i&&(a+t[u-1][0]+t[u-1][1])%e[u-1]==0:i,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);let o={x:n},s={blockShape:e,paddings:t};return C.runKernel(Aa,o,s)}var Ph=S({spaceToBatchND_:WO});function VO(r,e){let t=v(r,"base","pow"),n=v(e,"exp","pow");[t,n]=ae(t,n);let o={a:t,b:n};return C.runKernel(va,o)}var Lh=S({pow_:VO});function GO(r,e){let t=v(r,"x","prelu"),n=v(e,"alpha","prelu"),o={x:t,alpha:n};return C.runKernel(Uo,o)}var su=S({prelu_:GO});function zO(r,e=null,t=!1){let n=v(r,"x","prod");n.dtype==="bool"&&(n=ge(n,"int32"));let o={x:n},s={axis:e,keepDims:t};return C.runKernel(Tn,o,s)}var au=S({prod_:zO});var zh=gl(Rv());var Hh=class{constructor(e,t,n,o,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=zh.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let e,t,n=!1;for(;!n;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*o*a,t=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}};var jh=class{constructor(e=0,t=1,n,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=zh.alea(o)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function JO(r,e=0,t=1,n="float32",o){let s=ye(r,n),i=new jh(e,t,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var qh=S({randomUniform_:JO});function Ja(r,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");let o={start:r,stop:e,step:t,dtype:n};return C.runKernel(Ia,{},o)}function QO(r){let t={input:v(r,"input","real")};return C.runKernel(Bi,t)}var Vn=S({real_:QO});function ZO(r){let t={x:v(r,"x","reciprocal")};return C.runKernel(ac,t)}var Kh=S({reciprocal_:ZO});function eF(r){let t={x:v(r,"x","relu")};return C.runKernel(Ca,t)}var iu=S({relu_:eF});function tF(r){let t={x:v(r,"x","relu6")};return C.runKernel(Sa,t)}var uu=S({relu6_:tF});function rF(r,e){let n={x:v(r,"x","reverse")},o={dims:e};return C.runKernel(Vo,n,o)}var ys=S({reverse_:rF});function nF(r){let t={x:v(r,"x","round")};return C.runKernel(ka,t)}var lu=S({round_:nF});function oF(r){let t={x:v(r,"x","rsqrt")};return C.runKernel(Sn,t)}var Xh=S({rsqrt_:oF});function He(r,e){if((At(r)&&e!=="string"||Array.isArray(r))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&At(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Fn(r,[],[],e)}function sF(r){let t={x:v(r,"x","selu")};return C.runKernel(uc,t)}var Yh=S({selu_:sF});async function aF(r,e){let t=v(r,"x","setdiff1d"),n=v(e,"y","setdiff1d");E(t.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${n.dtype}).`),E(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),E(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let o=await t.data(),s=await n.data(),i=new Set(s),a=0;for(let c=0;c<o.length;c++)i.has(o[c])||a++;let u=new dr([a],t.dtype),l=new dr([a],"int32");for(let c=0,p=0;c<o.length;c++)i.has(o[c])||(u.values[p]=o[c],l.values[p]=c,p++);return[u.toTensor(),l.toTensor()]}var Jh=aF;function iF(r){let t={x:v(r,"x","sign")};return C.runKernel(cc,t)}var Qh=S({sign_:iF});function uF(r){let t={x:v(r,"x","sin")};return C.runKernel(Ea,t)}var Zh=S({sin_:uF});function lF(r){let t={x:v(r,"x","sinh")};return C.runKernel(lc,t)}var eg=S({sinh_:lF});function cF(r,e=-1){let t=v(r,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);let n={logits:t},o={dim:e};return C.runKernel(jo,n,o)}var tg=S({softmax_:cF});function pF(r){E(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let e={input:r};return C.runKernel(ql,e)}var cu=S({fft_:pF});function mF(r){E(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let e={input:r};return C.runKernel(Kl,e)}var Qa=S({ifft_:mF});function fF(r){let e=r.shape[r.shape.length-1],t=r.size/e,n;if(e<=2){let o=W(r,[t,e]);n=Qa(o)}else{let o=[t,2*(e-1)],s=W(Vn(r),[t,e]),i=W(xs(r),[t,e]),a=ys(Ct(s,[0,1],[t,e-2]),1),u=Ye(ys(Ct(i,[0,1],[t,e-2]),1),He(-1)),l=Ht([s,a],1),c=Ht([i,u],1),p=W(Dt(l,c),[o[0],o[1]]);n=Qa(p)}if(n=Vn(n),r.rank===3&&r.shape[0]!==0){let o=n,s=r.shape[0];n=W(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var rg=S({irfft_:fF});function dF(r,e,t=0){let o={x:v(r,"x","split")},s={numOrSizeSplits:e,axis:t};return C.runKernel(Ra,o,s)}var Gn=S({split_:dF});function hF(r,e){E(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let t=r.shape[r.shape.length-1],n=r.size/t,o;if(e!=null&&e<t){let d=r.shape.map(g=>0),h=r.shape.map(g=>g);h[r.shape.length-1]=e,o=Ct(r,d,h),t=e}else if(e!=null&&e>t){let d=r.shape.map(h=>h);d[r.shape.length-1]=e-t,o=Ht([r,rr(d)],r.shape.length-1),t=e}else o=r;let s=gs(o),i=W(Dt(o,s),[n,t]),a=cu(i),u=Math.floor(t/2)+1,l=Vn(a),c=xs(a),p=Gn(l,[u,t-u],l.shape.length-1),m=Gn(c,[u,t-u],c.shape.length-1),f=o.shape.slice();return f[o.shape.length-1]=u,W(Dt(p[0],m[0]),f)}var ng=S({rfft_:hF});function gF(r){let t={x:v(r,"x","sqrt")};return C.runKernel(Nn,t)}var og=S({sqrt_:gF});function xF(r,e){let t=v(r,"a","squaredDifference"),n=v(e,"b","squaredDifference");[t,n]=ae(t,n),be(t.shape,n.shape);let o={a:t,b:n},s={};return C.runKernel(En,o,s)}var sg=S({squaredDifference_:xF});function _F(r,e){let t=v(r,"x","squeeze");return W(t,Vf(t.shape,e).newShape)}var Za=S({squeeze_:_F});function yF(r,e=0){let t=kc(r,"tensors","stack","string_or_numeric");E(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&E(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");let n=t,o={axis:e};return C.runKernel(wa,n,o)}var yr=S({stack_:yF});function bF(r,e=0){let n={x:v(r,"x","step")},o={alpha:e};return C.runKernel(Jo,n,o)}var $v=S({step_:bF});function wF(r,e,t,n,o=0,s=0,i=0,a=0,u=0){let c={x:v(r,"x","stridedSlice","string_or_numeric")},p={begin:e,end:t,strides:n,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return C.runKernel(qo,c,p)}var ag=S({stridedSlice_:wF});function vF(r){let t={x:v(r,"x","tan")};return C.runKernel($a,t)}var ig=S({tan_:vF});function lt(r,e){Di(r);let t=us(r,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Fn(r,null,t,e)}function IF(r,e=1,t=!0){let n=v(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${e}`);let s={x:n},i={k:e,sorted:t},[a,u]=C.runKernel(Ko,s,i);return{values:a,indices:u}}var ug=S({topk_:IF});function CF(r,e=0,t=1,n,o){if(n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new Hh(e,t,n,!0,o),i=ye(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var lg=S({truncatedNormal_:CF});function TF(r,e=0){let t=v(r,"x","unique","string_or_numeric");E(t.rank>0,()=>"The input tensor must be at least 1D");let n={x:t},o={axis:e},[s,i]=C.runKernel(wc,n,o);return{values:s,indices:i}}var qc=S({unique_:TF});function SF(r,e=0){let t=v(r,"x","unstack","string_or_numeric");E(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);let n={value:t},o={axis:e};return C.runKernel(Oa,n,o)}var br=S({unstack_:SF});function Kc(r,e){let t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);let n=ye(r,"int32"),o=ye([t.length,r.length],"int32");for(let s=0;s<t.length;s++){let i=n.indexToLoc(t[s]),a=s*r.length;o.values.set(i,a)}return o.toTensor()}async function kF(r){let e=v(r,"condition","whereAsync","bool"),t=await e.data(),n=Kc(e.shape,t);return r!==e&&e.dispose(),n}var cg=kF;function NF(r,e,t){let n=v(r,"indices","scatterND","int32"),o=v(e,"updates","scatterND");Mc(o,n,t);let s={indices:n,updates:o},i={shape:t};return C.runKernel(Go,s,i)}var Dv=S({scatterND_:NF});function Ov(r,e,t,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let o=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);let i=e.size;if(!(e.rank===0||e.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${o}]`);if(e.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function EF(r,e,t,n=0){let o=v(r,"sparseIndices","sparseToDense","int32"),s=v(e,"sparseValues","sparseToDense"),i=v(n,"defaultValue","sparseToDense",s.dtype);Ov(o,s,t,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},u={outputShape:t};return C.runKernel(gc,a,u)}var Xc=S({sparseToDense_:EF});function AF(r,e){let t=v(e,"indices","gatherND","int32"),o={params:v(r,"x","gatherND","string_or_numeric"),indices:t};return C.runKernel(ko,o)}var Fv=S({gatherND_:AF});var Cs={};Ie(Cs,{conv2d:()=>Lv,depthwiseConv2d:()=>Uv,matMul:()=>Wv});function RF(r,e,t,n,o,s="NHWC",i){let a=r;r.rank===3&&(a=W(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=e;u.rank===3&&(u=W(e,[1,e.shape[0],e.shape[1],e.shape[2]])),E(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),E(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),E(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);let l=s==="NHWC"?a.shape[3]:a.shape[1],c=s==="NHWC"?u.shape[3]:u.shape[1];E(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),E(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),i!=null&&E(Re(o),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`);let p={x:a,dy:u},m={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:t};return C.runKernel(Bl,p,m)}var Pv=S({conv2DBackpropFilter_:RF});function bs(r,e,t){if(t==null||t==="linear")return r;if(t==="relu")return Ye(r,$v(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function ws(r,e){let t=e,n=rh(r.shape,e.shape);return n.length>0&&(t=Tt(t,n)),W(t,r.shape)}function vs(r,e,t,n){if(e==="linear")return r;if(e==="relu")return iu(r);if(e==="elu")return Qi(r);if(e==="relu6")return uu(r);if(e==="prelu")return su(r,t);if(e==="leakyrelu")return tu(r,n);if(e==="sigmoid")return Ki(r);throw new Error(`Unknown fused activation ${e}.`)}var Is=(r,e)=>!(r>0)||e==="linear";function $F({x:r,filter:e,strides:t,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",Is(C.state.gradientDepth,u)===!1){let R=hs(r,e,t,n,o,s,i);return a!=null&&(R=Lt(R,a)),vs(R,u,l,c)}let p=v(r,"x","conv2d"),m=v(e,"filter","conv2d"),f=p,d=!1;p.rank===3&&(d=!0,f=W(p,[1,p.shape[0],p.shape[1],p.shape[2]])),E(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),E(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),i!=null&&E(Re(n),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${n}.`),E(f.shape[3]===m.shape[2],()=>`Error in conv2d: depth of input (${f.shape[3]}) must match input depth for filter ${m.shape[2]}.`),E(It(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),E(o==="NHWC",()=>`Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`);let h=ps(f.shape,m.shape,t,s,n,i),g;a!=null&&(g=v(a,"bias","fused conv2d"),[g]=ae(g,p),be(h.outShape,g.shape));let y;l!=null&&(y=v(l,"prelu weights","fused conv2d"));let I=(R,F)=>{let[D,O,U,M]=F,G=bs(R,U,u);E(fs(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let j=Gc(O.shape,G,D,t,n),ee=Pv(O,G,D.shape,t,n),Q=[j,ee];if(M!=null){let ie=ws(M,G);Q.push(ie)}return Q},_={x:f,filter:m,bias:g,preluActivationWeights:y},N={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?tr((F,D,O)=>{let U=C.runKernel($n,_,N);return O([D,F,U]),d&&(U=W(U,[U.shape[1],U.shape[2],U.shape[3]])),{value:U,gradFunc:I}})(f,m):tr((F,D,O,U)=>{let M=C.runKernel($n,_,N);return U([D,F,M,O]),d&&(M=W(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:I}})(f,m,g)}var Lv=S({fusedConv2d_:$F});function DF(r,e,t,n,o,s=[1,1],i){let a=r;r.rank===3&&(a=W(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=e;u.rank===3&&(u=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l={x:a,dy:u},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,filterShape:t};return C.runKernel(Vl,l,c)}var Mv=S({depthwiseConv2dNativeBackpropFilter_:DF});function OF(r,e,t,n,o,s=[1,1],i){let a=e,u=!1;e.rank===3&&(u=!0,a=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l={dy:a,filter:t},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,inputShape:r},p=C.runKernel(Gl,l,c);return u?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Bv=S({depthwiseConv2dNativeBackpropInput_:OF});function FF({x:r,filter:e,strides:t,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(Is(C.state.gradientDepth,u)===!1){let R=Yi(r,e,t,n,o,s,i);return a!=null&&(R=Lt(R,a)),vs(R,u,l,c)}let p=v(r,"x","depthwiseConv2d"),m=v(e,"filter","depthwiseConv2d"),f=p,d=!1;p.rank===3&&(d=!0,f=W(p,[1,p.shape[0],p.shape[1],p.shape[2]])),E(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),E(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),E(f.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),s==null&&(s=[1,1]),E(It(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),i!=null&&E(Re(n),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${i} but got pad ${n}.`);let h=ps(f.shape,m.shape,t,s,n,i,!0),g;a!=null&&(g=v(a,"bias","fused conv2d"),[g]=ae(g,p),be(h.outShape,g.shape));let y;l!=null&&(y=v(l,"prelu weights","fused depthwiseConv2d"));let I=(R,F)=>{E(fs(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[D,O,U,M]=F,G=bs(R,U,u),j=Bv(O.shape,G,D,t,n,s,i),ee=Mv(O,G,D.shape,t,n,s,i);if(M!=null){let Q=ws(g,G);return[j,ee,Q]}return[j,ee]},_={x:f,filter:m,bias:g,preluActivationWeights:y},N={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?tr((F,D,O)=>{let U=C.runKernel(Dn,_,N);return O([D,F,U]),d&&(U=W(U,[U.shape[1],U.shape[2],U.shape[3]])),{value:U,gradFunc:I}})(f,m):tr((F,D,O,U)=>{let M=C.runKernel(Dn,_,N);return U([D,F,M,O]),d&&(M=W(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:I}})(f,m,g)}var Uv=S({fusedDepthwiseConv2d_:FF});function PF({a:r,b:e,transposeA:t=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a}){if(Is(C.state.gradientDepth,s)===!1){let M=Pt(r,e,t,n);return o!=null&&(M=Lt(M,o)),vs(M,s,i,a)}let u=v(r,"a","fused matMul"),l=v(e,"b","fused matMul");[u,l]=ae(u,l);let c=t?u.shape[u.rank-2]:u.shape[u.rank-1],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],m=t?u.shape[u.rank-1]:u.shape[u.rank-2],f=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=u.shape.slice(0,-2),h=l.shape.slice(0,-2),g=Se(d),y=Se(h);E(u.rank>=2&&l.rank>=2&&u.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${u.rank} and ${l.rank}.`),E(pr(d,h),()=>`Error in fused matMul: outer dimensions (${d}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} must match.`),E(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${t} and transposeB=${n} must match.`);let I=u.shape.slice(0,-2).concat([m,f]),_=t?W(u,[g,c,m]):W(u,[g,m,c]),N=n?W(l,[y,f,p]):W(l,[y,p,f]),R;o!=null&&(R=v(o,"bias","fused matMul"),[R]=ae(R,u),be(I,R.shape));let F;i!=null&&(F=v(i,"prelu weights","fused matMul"));let D=(M,G)=>{let[j,ee,Q,ie]=G,le=bs(W(M,Q.shape),Q,s),Ce,de;if(!t&&!n?(Ce=Pt(le,ee,!1,!0),de=Pt(j,le,!0,!1)):!t&&n?(Ce=Pt(le,ee,!1,!1),de=Pt(le,j,!0,!1)):t&&!n?(Ce=Pt(ee,le,!1,!0),de=Pt(j,le,!1,!1)):(Ce=Pt(ee,le,!0,!0),de=Pt(le,j,!0,!0)),o!=null){let Qe=ws(ie,le);return[Ce,de,Qe]}else return[Ce,de]},O={a:_,b:N,bias:R,preluActivationWeights:F},U={transposeA:t,transposeB:n,activation:s,leakyreluAlpha:a};return o==null?tr((G,j,ee)=>{let Q=C.runKernel(Rn,O,U);return ee([G,j,Q]),{value:W(Q,I),gradFunc:D}})(_,N):tr((G,j,ee,Q)=>{let ie=C.runKernel(Rn,O,U);return Q([G,j,ie,ee]),{value:W(ie,I),gradFunc:D}})(_,N,R)}var Wv=S({fusedMatMul_:PF});function LF(r,e,t,n,o="bilinear",s=0){let i=v(r,"image","cropAndResize"),a=v(e,"boxes","cropAndResize","float32"),u=v(t,"boxInd","cropAndResize","int32"),l=a.shape[0];E(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),E(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),E(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),E(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),E(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),E(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let c={image:i,boxes:a,boxInd:u},p={method:o,extrapolationValue:s,cropSize:n};return C.runKernel(vo,c,p)}var Vv=S({cropAndResize_:LF});function MF(r){let e=v(r,"image","flipLeftRight","float32");E(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);let t={image:e};return C.runKernel(To,t,{})}var Gv=S({flipLeftRight_:MF});function BF(r){let e=v(r,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];E(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),E(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let o=new Array(e.rank);return o.fill(1,0,t),o[t]=3,Zi(e,o)}var zv=S({grayscaleToRGB_:BF});function UF(r,e,t=0,n=.5){let o=v(r,"image","rotateWithOffset","float32");E(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:e,fillValue:t,center:n};return C.runKernel(Qo,s,i)}var Hv=S({rotateWithOffset_:UF});function jt(r,e,t,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=r.shape[0];return t=Math.min(t,i),E(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),E(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),E(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),E(e.rank===1,()=>"scores must be a 1D tensor"),E(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),E(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function WF(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY){let s=v(r,"boxes","nonMaxSuppression"),i=v(e,"scores","nonMaxSuppression"),a=jt(s,i,t,n,o);t=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u={maxOutputSize:t,iouThreshold:n,scoreThreshold:o};return C.runKernel(Fo,{boxes:s,scores:i},u)}var jv=S({nonMaxSuppression_:WF});function qv(r,e,t){let n=VF(r,e,t),o=n<0?-(n+1):n;r.splice(o,0,e)}function VF(r,e,t){return zF(r,e,t||GF)}function GF(r,e){return r>e?1:r<e?-1:0}function zF(r,e,t){let n=0,o=r.length,s=0,i=!1;for(;n<o;){s=n+(o-n>>>1);let a=t(e,r[s]);a>0?n=s+1:(o=s,i=!a)}return i?n:-n-1}function Yc(r,e,t,n,o){return pg(r,e,t,n,o,0)}function Jc(r,e,t,n,o,s){return pg(r,e,t,n,o,0,!1,s,!0)}function Qc(r,e,t,n,o,s){return pg(r,e,t,n,o,s,!0)}function pg(r,e,t,n,o,s,i=!1,a=!1,u=!1){let l=[];for(let g=0;g<e.length;g++)e[g]>o&&l.push({score:e[g],boxIndex:g,suppressBeginIndex:0});l.sort(Kv);let c=s>0?-.5/s:0,p=[],m=[];for(;p.length<t&&l.length>0;){let g=l.pop(),{score:y,boxIndex:I,suppressBeginIndex:_}=g;if(y<o)break;let N=!1;for(let R=p.length-1;R>=_;--R){let F=HF(r,I,p[R]);if(F>=n){N=!0;break}if(g.score=g.score*jF(n,c,F),g.score<=o)break}g.suppressBeginIndex=p.length,N||(g.score===y?(p.push(I),m.push(g.score)):g.score>o&&qv(l,g,Kv))}let f=p.length,d=t-f;a&&d>0&&(p.push(...new Array(d).fill(0)),m.push(...new Array(d).fill(0)));let h={selectedIndices:p};return i&&(h.selectedScores=m),u&&(h.validOutputs=f),h}function HF(r,e,t){let n=r.subarray(e*4,e*4+4),o=r.subarray(t*4,t*4+4),s=Math.min(n[0],n[2]),i=Math.min(n[1],n[3]),a=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),l=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),m=Math.max(o[1],o[3]),f=(a-s)*(u-i),d=(p-l)*(m-c);if(f<=0||d<=0)return 0;let h=Math.max(s,l),g=Math.max(i,c),y=Math.min(a,p),I=Math.min(u,m),_=Math.max(y-h,0)*Math.max(I-g,0);return _/(f+d-_)}function jF(r,e,t){let n=Math.exp(e*t*t);return t<=r?n:0}function Kv(r,e){return r.score-e.score||r.score===e.score&&e.boxIndex-r.boxIndex}async function qF(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY){let s=v(r,"boxes","nonMaxSuppressionAsync"),i=v(e,"scores","nonMaxSuppressionAsync"),a=jt(s,i,t,n,o);t=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u=await Promise.all([s.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:p}=Yc(l,c,t,n,o);return s!==r&&s.dispose(),i!==e&&i.dispose(),lt(p,"int32")}var Xv=qF;function KF(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=v(r,"boxes","nonMaxSuppression"),a=v(e,"scores","nonMaxSuppression"),u=jt(i,a,t,n,o,s);t=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l={boxes:i,scores:a},c={maxOutputSize:t,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},p=C.runKernel(Lo,l,c);return{selectedIndices:p[0],selectedScores:p[1]}}var Yv=S({nonMaxSuppressionWithScore_:KF});async function XF(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=v(r,"boxes","nonMaxSuppressionAsync"),a=v(e,"scores","nonMaxSuppressionAsync"),u=jt(i,a,t,n,o,s);t=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l=await Promise.all([i.data(),a.data()]),c=l[0],p=l[1],{selectedIndices:m,selectedScores:f}=Qc(c,p,t,n,o,s);return i!==r&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:lt(m,"int32"),selectedScores:lt(f)}}var Jv=XF;function YF(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=v(r,"boxes","nonMaxSuppression"),a=v(e,"scores","nonMaxSuppression"),u=jt(i,a,t,n,o,null),l=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,m={boxes:i,scores:a},f={maxOutputSize:l,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},d=C.runKernel(Po,m,f);return{selectedIndices:d[0],validOutputs:d[1]}}var Qv=S({nonMaxSuppressionPadded_:YF});async function JF(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=v(r,"boxes","nonMaxSuppressionAsync"),a=v(e,"scores","nonMaxSuppressionAsync"),u=jt(i,a,t,n,o,null),l=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,[m,f]=await Promise.all([i.data(),a.data()]),{selectedIndices:d,validOutputs:h}=Jc(m,f,l,c,p,s);return i!==r&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:lt(d,"int32"),validOutputs:He(h,"int32")}}var Zv=JF;function QF(r,e,t=!1,n=!1){let o=v(r,"images","resizeBilinear");E(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),E(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),E(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=W(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,a={images:s},u={alignCorners:t,halfPixelCenters:n,size:e},l=C.runKernel(Wo,a,u);return i?W(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var eI=S({resizeBilinear_:QF});function ZF(r,e,t=!1,n=!1){let o=v(r,"images","resizeNearestNeighbor");E(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),E(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),E(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),E(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=W(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,a={images:s},u={alignCorners:t,halfPixelCenters:n,size:e},l=C.runKernel(ic,a,u);return i?W(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var tI=S({resizeNearestNeighbor_:ZF});function tP(r,e="binary",t=!1,n=.5){let o=v(r,"image","threshold"),s=.2989,i=.587,a=.114,u=o.shape[0]*o.shape[1],l=Ye(lt([n]),255),c,p,m,f;if(E(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),E(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),E(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),E(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),o.shape[2]===3){[c,p,m]=Gn(o,[1,1,1],-1);let g=Ye(c,s),y=Ye(p,i),I=Ye(m,a);f=Lt(Lt(g,y),I)}else f=r;if(e==="otsu"){let g=Xi(ge(lu(f),"int32"),vt([]),256);l=eP(g,u)}let d=t?ru(f,l):Ya(f,l);return ge(Ye(d,255),"int32")}function eP(r,e){let t=lt([-1]),n=lt([0]),o=lt([0]),s,i,a,u,l,c;for(let p=0;p<r.size-1;p++){s=Ct(r,0,p+1),i=Ct(r,p+1),l=xr(Tt(s),e),c=xr(Tt(i),e);let m=Tt(Ye(s,Ja(0,s.size)));a=xr(m,Tt(s));let f=eu(i.shape,s.size),d=Lt(Ja(0,i.size),f),h=Ye(i,d);u=xr(Tt(h),Tt(i));let g=_r(a,u),y=_r(a,u),I=Ye(l,c);o=Ye(Ye(I,g),y);let _=Ya(o,n);n=Wn(_,o,n),t=Wn(_,lt([p]),t)}return t}var rI=S({threshold_:tP});function rP(r,e,t="nearest",n="constant",o=0,s){let i=v(r,"image","transform","float32"),a=v(e,"transforms","transform","float32");E(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),E(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),E(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:i,transforms:a},l={interpolation:t,fillMode:n,fillValue:o,outputShape:s};return C.runKernel(Xo,u,l)}var nI=S({transform_:rP});function nP(r,e,t,n){let o=v(r,"indices","sparseFillEmptyRows"),s=v(e,"values","sparseFillEmptyRows"),i=v(t,"denseShape","sparseFillEmptyRows"),a=v(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let u={indices:o,values:s,denseShape:i,defaultValue:a},l=C.runKernel(mc,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var oI=S({sparseFillEmptyRows_:nP});function oP(r,e,t){let n=v(r,"inputIndices","sparseReshape"),o=v(e,"inputShape","sparseReshape"),s=v(t,"newShape","sparseReshape");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:n,inputShape:o,newShape:s},a=C.runKernel(fc,i);return{outputIndices:a[0],outputShape:a[1]}}var sI=S({sparseReshape_:oP});function sP(r,e,t){let n=v(r,"data","sparseSegmentMean"),o=v(e,"indices","sparseSegmentMean"),s=v(t,"segmentIds","sparseSegmentMean");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return C.runKernel(dc,i)}var aI=S({sparseSegmentMean_:sP});function aP(r,e,t){let n=v(r,"data","sparseSegmentSum"),o=v(e,"indices","sparseSegmentSum"),s=v(t,"segmentIds","sparseSegmentSum");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return C.runKernel(hc,i)}var iI=S({sparseSegmentSum_:aP});function iP(r,e,t,n,o,s,i,a){let u=v(r,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let l=v(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:t,nGramWidths:n,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},p={data:u,dataSplits:l},m=C.runKernel(_c,p,c);return{nGrams:m[0],nGramsSplits:m[1]}}var uI=S({stringNGrams_:iP});function uP(r,e,t=!0){let n=v(r,"input","stringSplit","string"),o=v(e,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:t},i={input:n,delimiter:o},a=C.runKernel(yc,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var lI=S({stringSplit_:uP});function lP(r,e){let t=v(r,"input","stringToHashBucketFast","string"),n={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");let o={input:t};return C.runKernel(bc,o,n)}var cI=S({stringToHashBucketFast_:lP});var zn={flipLeftRight:Gv,grayscaleToRGB:zv,resizeNearestNeighbor:tI,resizeBilinear:eI,rotateWithOffset:Hv,cropAndResize:Vv,nonMaxSuppression:jv,nonMaxSuppressionAsync:Xv,nonMaxSuppressionWithScore:Yv,nonMaxSuppressionWithScoreAsync:Jv,nonMaxSuppressionPadded:Qv,nonMaxSuppressionPaddedAsync:Zv,threshold:rI,transform:nI};var pu={sparseFillEmptyRows:oI,sparseReshape:sI,sparseSegmentMean:aI,sparseSegmentSum:iI},Zc={stringNGrams:uI,stringSplit:lI,stringToHashBucketFast:cI};var k={};Ie(k,{ERF_A1:()=>vP,ERF_A2:()=>IP,ERF_A3:()=>CP,ERF_A4:()=>TP,ERF_A5:()=>SP,ERF_P:()=>wP,PARALLELIZE_THRESHOLD:()=>ep,SELU_SCALE:()=>bP,SELU_SCALEALPHA:()=>yP,applyActivation:()=>vs,assertAndGetBroadcastShape:()=>be,assertAxesAreInnerMostDims:()=>bO,assertParamsConsistent:()=>cP,assignToTypedArray:()=>$P,axesAreInnerMostDims:()=>_h,calculateShapes:()=>Qw,checkEinsumDimSizes:()=>MP,combineLocations:()=>hv,complexWithEvenIndex:()=>EP,complexWithOddIndex:()=>AP,computeConv2DInfo:()=>ps,computeConv3DInfo:()=>fv,computeDefaultPad:()=>Bd,computeDilation2DInfo:()=>lD,computeOptimalWindowSize:()=>mP,computeOutAndReduceShapes:()=>_O,computeOutShape:()=>pP,computePool2DInfo:()=>cD,computePool3DInfo:()=>pD,convertConv2DDataFormat:()=>mv,decodeEinsumEquation:()=>PP,eitherStridesOrDilationsAreOne:()=>It,expandShapeToKeepDim:()=>yO,exponent:()=>OP,exponents:()=>DP,fromStringArrayToUint8:()=>qP,fromUint8ToStringArray:()=>jP,getAxesPermutation:()=>wO,getBroadcastDims:()=>VD,getComplexWithIndex:()=>RP,getEinsumComputePath:()=>UP,getEinsumPermutation:()=>LP,getFusedBiasGradient:()=>ws,getFusedDyActivation:()=>bs,getImageCenter:()=>fP,getInnerMostAxes:()=>IO,getPermuted:()=>hP,getReductionAxes:()=>rh,getReshaped:()=>dP,getReshapedPermuted:()=>gP,getSliceBeginCoords:()=>xP,getSliceSize:()=>_P,getUndoAxesPermutation:()=>vO,isIdentityPermutation:()=>WP,log:()=>$2,mergeRealAndImagArrays:()=>kP,prepareAndValidate:()=>Jw,prepareSplitSize:()=>VP,segment_util:()=>fg,shouldFuse:()=>Is,slice_util:()=>st,splitRealAndImagArrays:()=>NP,tupleValuesAreOne:()=>fs,upcastType:()=>ut,validateInput:()=>Mc,validateUpdateShape:()=>Cd,warn:()=>Wt});function cP(r,e){let t=r[0].length;r.forEach((o,s)=>{E(o.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),E(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);let n=r[0];r.forEach((o,s)=>{for(let i=0;i<t;i++)E(i===e||o[i]===n[i],()=>`Error in concat${t}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function pP(r,e){let t=r[0].slice();for(let n=1;n<r.length;n++)t[e]+=r[n][e];return t}var ep=30;function mP(r){return r<=ep?r:aa(r,Math.floor(Math.sqrt(r)))}function fP(r,e,t){let n=t*(typeof r=="number"?r:r[0]),o=e*(typeof r=="number"?r:r[1]);return[n,o]}function dP(r,e,t,n=!0){let o=[];if(n)o=o.concat(e.slice(0)),o.push(r[0]/t),o=o.concat(r.slice(1));else{o=o.concat(r[0]);let s=e.length;for(let i=0;i<s;++i)o=o.concat([r[i+1]/e[i],e[i]]);o=o.concat(r.slice(s+1))}return o}function hP(r,e,t=!0){let n=[];if(t){n.push(e);for(let o=e+1;o<r;++o)o<=2*e?(n.push(o),n.push(o-(e+1))):n.push(o)}else{let o=[],s=[];for(let i=1;i<r;++i)i>=e*2+1||i%2==1?s.push(i):o.push(i);n.push(...o),n.push(0),n.push(...s)}return n}function gP(r,e,t,n=!0){let o=[];n?o.push(r[0]/t):o.push(r[0]*t);for(let s=1;s<r.length;++s)s<=e.length?n?o.push(e[s-1]*r[s]):o.push(r[s]/e[s-1]):o.push(r[s]);return o}function xP(r,e){let t=[0];for(let n=0;n<e;++n)t.push(r[n][0]);return t}function _P(r,e,t){let n=r.slice(0,1);for(let o=0;o<t;++o)n.push(r[o+1]-e[o][0]-e[o][1]);return n}var yP=1.7580993408473768,bP=1.0507009873554805;var wP=.3275911,vP=.254829592,IP=-.284496736,CP=1.421413741,TP=-1.453152027,SP=1.061405429;function kP(r,e){if(r.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${e.length}.`);let t=new Float32Array(r.length*2);for(let n=0;n<t.length;n+=2)t[n]=r[n/2],t[n+1]=e[n/2];return t}function NP(r){let e=new Float32Array(r.length/2),t=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)e[n/2]=r[n],t[n/2]=r[n+1];return{real:e,imag:t}}function EP(r){let e=Math.ceil(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let o=0;o<r.length;o+=4)t[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:t,imag:n}}function AP(r){let e=Math.floor(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let o=2;o<r.length;o+=4)t[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:t,imag:n}}function RP(r,e){let t=r[e*2],n=r[e*2+1];return{real:t,imag:n}}function $P(r,e,t,n){r[n*2]=e,r[n*2+1]=t}function DP(r,e){let t=new Float32Array(r/2),n=new Float32Array(r/2);for(let o=0;o<Math.ceil(r/2);o++){let s=(e?2:-2)*Math.PI*(o/r);t[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:t,imag:n}}function OP(r,e,t){let n=(t?2:-2)*Math.PI*(r/e),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var mg="->",FP=/->/g,pI=",",mI="...";function PP(r,e){r=r.replace(/\s/g,"");let t=(r.length-r.replace(FP,"").length)/mg.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${mg}").`);let[n,o]=r.split(mg);E(n.indexOf(mI)===-1,()=>`The ellipsis notation ("${mI}") is not supported yet.`);let s=n.split(pI),i=s.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let m=0;m<o.length;++m){let f=o[m];if(!s.some(d=>d.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let m=0;m<n.length;++m){let f=n[m];a.indexOf(f)===-1&&f!==pI&&a.push(f)}let u=new Array(s.length);for(let m=0;m<i;++m){if(new Set(s[m].split("")).size!==s[m].length)throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let f=0;f<s[m].length;++f)u[m].push(a.indexOf(s[m][f]))}let l=a.length,c=o.length,p=[];for(let m=c;m<l;++m)p.push(m);return{allDims:a,summedDims:p,idDims:u}}function LP(r,e){let t=new Array(r);t.fill(-1);for(let o=0;o<e.length;++o)t[e[o]]=o;let n=[];for(let o=0;o<r;++o)t[o]===-1&&n.push(o);return t=t.filter(o=>o!==-1),{permutationIndices:t,expandDims:n}}function MP(r,e,t){let n=new Array(r);for(let o=0;o<t.length;++o){let s=t[o].shape;for(let i=0;i<e[o].length;++i)n[e[o][i]]===void 0?n[e[o][i]]=s[i]:E(n[e[o][i]]===s[i],()=>`Expected dimension ${n[e[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function UP(r,e){let t=r,n=[],o=0;r.length===0&&t.push(-1),o=r.length+1;for(let i=0;i<o;++i)n.push([]);let s=[];for(let i=0;i<t.length;++i){let a=t[i],u=BP(e,a);for(let l of u)s.indexOf(l)===-1&&(n[i].push(l),s.push(l))}return{path:t,steps:n}}function WP(r){return r.every((e,t)=>e===t)}function BP(r,e){let t=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(e)!==-1||e===-1)&&t.push(n);return t}function VP(r,e,t=0){let n=[];if(typeof e=="number")E(r.shape[t]%e==0,()=>"Number of splits must evenly divide the axis."),n=new Array(e).fill(r.shape[t]/e);else{let o=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);E(o<=1,()=>"There should be only one negative value in split array.");let s=e.indexOf(-1);if(s!==-1){let i=e.reduce((a,u)=>u>0?a+u:a);e[s]=r.shape[t]-i}E(r.shape[t]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),n=e}return n}var fg={};Ie(fg,{collectGatherOpShapeInfo:()=>HP,computeOutShape:()=>zP,segOpComputeOptimalWindowSize:()=>GP});function GP(r,e){let t=!1,n;for(r<=ep?(n=r,t=!0):n=aa(r,Math.floor(Math.sqrt(r)));!t;)n>e||n===r?t=!0:n=aa(r,n+1);return n}function zP(r,e,t){let n=[],o=r.length;for(let s=0;s<o;s++)s!==e?n.push(r[s]):n.push(t);return n}function HP(r,e,t,n){let o=e.shape.length,s=r.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(t<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${t}).`);for(let p=0;p<n;++p)if(r.shape[p]!==e.shape[p])throw new Error(`x.shape[${p}]: ${r.shape[p]} should be equal to indices.shape[${p}]: ${e.shape[p]}.`);let i=r.shape[t],a=[],u=1,l=1,c=1;for(let p=0;p<n;++p)a.push(r.shape[p]),u*=r.shape[p];for(let p=n;p<t;p++)a.push(r.shape[p]),l*=r.shape[p];for(let p=n;p<o;p++)a.push(e.shape[p]);for(let p=t+1;p<s;p++)a.push(r.shape[p]),c*=r.shape[p];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:a}}function jP(r){try{return r.map(e=>Ua(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function qP(r){return r.map(e=>Ba(e))}var wr={};Ie(wr,{nonMaxSuppressionV3Impl:()=>Yc,nonMaxSuppressionV4Impl:()=>Jc,nonMaxSuppressionV5Impl:()=>Qc,whereImpl:()=>Kc});var ke;(function(r){r[r.float32=0]="float32",r[r.int32=1]="int32",r[r.bool=2]="bool",r[r.string=3]="string",r[r.complex64=4]="complex64"})(ke||(ke={}));var Hn;(function(r){r[r.linear=0]="linear",r[r.relu=1]="relu",r[r.relu6=2]="relu6",r[r.prelu=3]="prelu",r[r.leakyrelu=4]="leakyrelu",r[r.sigmoid=5]="sigmoid",r[r.elu=6]="elu"})(Hn||(Hn={}));var fI;function KP(r){fI=r.wasm.cwrap(Rn,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function XP(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=e;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n,m=t.dataIdMap.get(o.dataId).id,f=t.dataIdMap.get(s.dataId).id,d=0;if(i!=null){let O=t.dataIdMap.get(i.dataId);if(O.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${O.shape.length}.`);d=O.id}let h=a==null?0:t.dataIdMap.get(a.dataId).id,g=Hn[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=u?o.shape[2]:o.shape[1],I=l?s.shape[1]:s.shape[2],_=o.shape[0],N=t.makeOutput([_,y,I],o.dtype),R=t.dataIdMap.get(N.dataId).id,F=new Uint8Array(new Int32Array(o.shape).buffer),D=new Uint8Array(new Int32Array(s.shape).buffer);return fI(m,F,o.shape.length,f,D,s.shape.length,u,l,g,d,h,p||0,R),N}var dI={kernelName:Rn,backendName:"wasm",setupFunc:KP,kernelFunc:XP};function me(r){let e;function t(o){e=o.wasm.cwrap(r,null,["number","number"])}function n(o){let{backend:s,inputs:{x:i}}=o,a=s.dataIdMap.get(i.dataId).id,u=s.makeOutput(i.shape,i.dtype),l=s.dataIdMap.get(u.dataId).id;return w.sizeFromShape(u.shape)===0||e(a,l),u}return{kernelName:r,backendName:"wasm",setupFunc:t,kernelFunc:n}}var hI=me(co);function we(r,e,t){let n;function o(i){n=i.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:a,inputs:u}=i,{a:l,b:c}=u,p=a.dataIdMap.get(l.dataId).id,m=a.dataIdMap.get(c.dataId).id,f=t??l.dtype,d=k.assertAndGetBroadcastShape(l.shape,c.shape),h=a.makeOutput(d,f);if(w.sizeFromShape(d)===0)return h;let g=new Uint8Array(new Int32Array(l.shape).buffer),y=new Uint8Array(new Int32Array(c.shape).buffer),I=a.dataIdMap.get(h.dataId).id,_=()=>n(p,g,l.shape.length,m,y,c.shape.length,ke[l.dtype],I);if(e&&l.dtype==="float32")return _(),h;let N=k.getBroadcastDims(l.shape,d),R=k.getBroadcastDims(c.shape,d),F=N.every((O,U)=>O===U),D=R.every((O,U)=>O===U);if(F&&D)return _(),h;throw new Error(`Broadcasting along outer dims is not yet supported for ${l.dtype} ${r}.`)}return{kernelName:r,backendName:"wasm",setupFunc:o,kernelFunc:s}}var YP=!0,gI=we(fr,YP);var xI;function JP(r){xI=r.wasm.cwrap(po,null,["array","number","number","number"])}function QP(r){let{inputs:e,backend:t}=r,n=t.makeOutput(e[0].shape,e[0].dtype);if(w.sizeFromShape(n.shape)===0)return n;let o=e.map(a=>t.dataIdMap.get(a.dataId).id),s=new Uint8Array(new Int32Array(o).buffer),i=t.dataIdMap.get(n.dataId).id;return xI(s,o.length,ke[n.dtype],i),n}var _I={kernelName:po,backendName:"wasm",setupFunc:JP,kernelFunc:QP};function Ts(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype),o=t.typedArrayFromHeap(e);return t.typedArrayFromHeap(n).set(o),n}var yI={kernelName:Br,backendName:"wasm",kernelFunc:Ts};var bI;function ZP(r){bI=r.wasm.cwrap(Yo,null,["number","array","number","number","number","array","number"])}function vr(r){let{inputs:e,backend:t,attrs:n}=r,[o,s]=tL(e.x.shape,n.perm),i=!0;for(let d=0;d<s.length;d++)s[d]!==d&&(i=!1);let a=eL(e.x.shape,n.perm),u={dataId:e.x.dataId,shape:o,dtype:e.x.dtype};if(i){let d=Ts({inputs:e,backend:t});return d.shape=a,d}let l=t.makeOutput(a,u.dtype),c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(l.dataId).id,m=new Uint8Array(new Int32Array(s).buffer),f=new Uint8Array(new Int32Array(u.shape).buffer);return bI(c,f,u.shape.length,ke[u.dtype],p,m,s.length),l}function eL(r,e){let t=new Array(r.length);for(let n=0;n<t.length;n++)t[n]=r[e[n]];return t}function tL(r,e){let t=[],n=[];for(let o=0;o<r.length;++o)r[o]!==1&&t.push(r[o]),r[e[o]]!==1&&n.push(e[o]);for(let o=0;o<n.length;++o){let s=-1;for(let i=0;i<n.length;++i)n[i]>=o&&(s===-1||n[s]>n[i])&&(s=i);n[s]=o}return[t,n]}var wI={kernelName:Yo,backendName:"wasm",kernelFunc:vr,setupFunc:ZP};function ht(r,e,t){let n=r.shape,o=r.shape.length,s=w.parseAxisParam(e,n),i=s,a=k.getAxesPermutation(i,o),u=null,l=!1;if(a!=null){let c=new Array(o);for(let f=0;f<c.length;f++)c[f]=n[a[f]];i=k.getInnerMostAxes(i.length,o),u=vr({inputs:{x:r},attrs:{perm:a},backend:t});let p=t.dataIdMap.get(r.dataId).id;t.dataIdMap.get(u.dataId).id!==p&&(l=!0)}return{transposed:u,originalAxes:s,axes:i,inputWasTransposed:l}}var vI;function rL(r){vI=r.wasm.cwrap(mo,null,["number, number, number"])}function nL(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=t,u=e.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=ht(i,o,e);if(f){let _=e.dataIdMap.get(c.dataId).id;l=c,u=_}let d=l.shape.length;k.assertAxesAreInnerMostDims("all",p,d);let[h,g]=k.computeOutAndReduceShapes(l.shape,p),y=w.sizeFromShape(g),I=e.makeOutput(h,i.dtype);if(w.sizeFromShape(l.shape)!==0){let _=e.dataIdMap.get(I.dataId).id;vI(u,y,_)}if(f&&e.disposeData(c.dataId),s){let _=k.expandShapeToKeepDim(I.shape,m);I.shape=_}return I}var II={kernelName:mo,backendName:"wasm",setupFunc:rL,kernelFunc:nL};var CI;function oL(r){CI=r.wasm.cwrap(fo,null,["number, number, number"])}function sL(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=t,u=e.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=ht(i,o,e);if(f){let _=e.dataIdMap.get(c.dataId).id;l=c,u=_}let d=l.shape.length;k.assertAxesAreInnerMostDims("any",p,d);let[h,g]=k.computeOutAndReduceShapes(l.shape,p),y=w.sizeFromShape(g),I=e.makeOutput(h,i.dtype);if(w.sizeFromShape(l.shape)!==0){let _=e.dataIdMap.get(I.dataId).id;CI(u,y,_)}if(f&&e.disposeData(c.dataId),s){let _=k.expandShapeToKeepDim(I.shape,m);I.shape=_}return I}var TI={kernelName:fo,backendName:"wasm",setupFunc:oL,kernelFunc:sL};var SI;function aL(r){SI=r.wasm.cwrap(ho,null,["number","number","number","number","number"])}function iL(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o}=n,{x:s}=t,i=e.dataIdMap.get(s.dataId).id,a=i,u=s,{transposed:l,axes:c,inputWasTransposed:p}=ht(s,o,e);if(p){let y=e.dataIdMap.get(l.dataId).id;y!==i&&(u=l,a=y)}let m=u.shape.slice(0,-1),f=e.makeOutput(m,"int32"),d=e.dataIdMap.get(f.dataId).id,h=w.sizeFromShape(f.shape),g=u.shape[c[0]];return SI(a,ke[u.dtype],h,g,d),p&&e.disposeData(l.dataId),f}var kI={kernelName:ho,backendName:"wasm",kernelFunc:iL,setupFunc:aL};var NI;function uL(r){NI=r.wasm.cwrap(go,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function lL(r){let{inputs:e,attrs:t,backend:n}=r,o=e.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=t,c=k.computePool2DInfo(o.shape,i,a,1,u,l),p=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,I=c.strideWidth,_=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let N=n.makeOutput(c.outShape,"float32"),R=n.dataIdMap.get(N.dataId).id;return NI(s,o.shape[0],o.shape[1],o.shape[2],p,m,f,d,h,g,y,I,_,R),N}var EI={kernelName:go,backendName:"wasm",setupFunc:uL,kernelFunc:lL};function Ge(r){let{inputs:e,attrs:t}=r,{x:n}=e,{shape:o}=t,s=w.sizeFromShape(n.shape),i=w.inferFromImplicitShape(o,s);return w.assert(s===w.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:i,dtype:n.dtype}}var AI={kernelName:Ta,backendName:"wasm",kernelFunc:Ge};var RI;function cL(r){RI=r.wasm.cwrap(xo,null,["number","array","number","number","array","number","number","number","number"])}function pL(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:i,transposeB:a}=n;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=o.shape.length,l=s.shape.length,c=i?o.shape[u-2]:o.shape[u-1],p=a?s.shape[l-1]:s.shape[l-2],m=i?o.shape[u-1]:o.shape[u-2],f=a?s.shape[l-2]:s.shape[l-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=w.sizeFromShape(d),y=w.sizeFromShape(h),I=g===y||g===1||y===1;w.assert(u>=2&&l>=2&&I,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${d}) and (${h}).`);let N=(g>y?o.shape.slice(0,-2):s.shape.slice(0,-2)).concat([m,f]);w.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let R=i?[g,c,m]:[g,m,c],F=a?[y,f,p]:[y,p,f],D=Ge({inputs:{x:o},backend:t,attrs:{shape:R}}),O=Ge({inputs:{x:s},backend:t,attrs:{shape:F}}),U=t.dataIdMap.get(D.dataId).id,M=t.dataIdMap.get(O.dataId).id,G=i?D.shape[2]:D.shape[1],j=a?O.shape[1]:O.shape[2],ee=Math.max(g,y),Q=t.makeOutput([ee,G,j],D.dtype),ie=t.dataIdMap.get(Q.dataId).id,le=new Uint8Array(new Int32Array(D.shape).buffer),Ce=new Uint8Array(new Int32Array(O.shape).buffer);return RI(U,le,D.shape.length,M,Ce,O.shape.length,i,a,ie),t.disposeData(D.dataId),t.disposeData(O.dataId),Q.shape=N,Q}var $I={kernelName:xo,backendName:"wasm",setupFunc:cL,kernelFunc:pL};var $g={};Ie($g,{addImpl:()=>hg,bincountImpl:()=>FI,bincountReduceImpl:()=>PI,ceilImpl:()=>gg,concatImpl:()=>du,equalImpl:()=>xg,expImpl:()=>_g,expm1Impl:()=>yg,floorImpl:()=>bg,gatherNdImpl:()=>LI,gatherV2Impl:()=>MI,greaterEqualImpl:()=>vg,greaterImpl:()=>wg,lessEqualImpl:()=>Cg,lessImpl:()=>Ig,linSpaceImpl:()=>BI,logImpl:()=>Tg,maxImpl:()=>UI,maximumImpl:()=>Sg,minimumImpl:()=>kg,multiplyImpl:()=>hu,negImpl:()=>WI,notEqualImpl:()=>Ng,prodImpl:()=>GI,rangeImpl:()=>gu,rsqrtImpl:()=>Eg,sigmoidImpl:()=>zI,simpleAbsImpl:()=>DI,sliceImpl:()=>ri,sparseFillEmptyRowsImpl:()=>HI,sparseReshapeImpl:()=>jI,sparseSegmentReductionImpl:()=>qI,sqrtImpl:()=>KI,squaredDifferenceImpl:()=>Ag,stridedSliceImpl:()=>XI,stringNGramsImpl:()=>JI,stringSplitImpl:()=>QI,stringToHashBucketFastImpl:()=>ZI,subImpl:()=>Rg,tileImpl:()=>eC,topKImpl:()=>rC,transposeImpl:()=>VI,uniqueImpl:()=>nC});function mu(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&w.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}function DI(r){let e=new Float32Array(r.length);for(let t=0;t<r.length;++t)e[t]=Math.abs(r[t]);return e}function Oe(r){return(e,t,n,o,s)=>{let i=k.assertAndGetBroadcastShape(e,t),a=i.length,u=w.computeStrides(i),l=w.sizeFromShape(i),c=w.getTypedArrayFromDType(s,l),p=e.length,m=t.length,f=w.computeStrides(e),d=w.computeStrides(t),h=k.getBroadcastDims(e,i),g=k.getBroadcastDims(t,i);if(h.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=r(n[y%n.length],o[y%o.length]);else for(let y=0;y<c.length;++y){let I=w.indexToLoc(y,a,u),_=I.slice(-p);h.forEach(D=>_[D]=0);let N=w.locToIndex(_,p,f),R=I.slice(-m);g.forEach(D=>R[D]=0);let F=w.locToIndex(R,m,d);c[y]=r(n[N],o[F])}return[c,i]}}function ei(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,a=t.makeTensorInfo(n.shape,"complex64"),u=t.data.get(a.dataId);return u.complexTensorInfos={real:t.makeTensorInfo(n.shape,"float32",s),imag:t.makeTensorInfo(o.shape,"float32",i)},a}function tp(r,e,t="float32"){if(t==="complex64"){let o=tp(r,e,"float32"),s=tp(r,e,"float32");return ei({inputs:{real:o,imag:s},backend:r})}let n=w.makeZerosTypedArray(w.sizeFromShape(e),t);return r.makeTensorInfo(e,t,n)}function dg(r){let{inputs:e,backend:t}=r,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function OI(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.data.get(n.dataId).complexTensorInfos.real,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}function fu(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return dg({inputs:{x:o},backend:t});let i=tp(t,o.shape,o.dtype),a=fu({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=ei({inputs:{real:a,imag:i},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),u}if(o.dtype==="complex64"){let i=OI({inputs:{input:o},backend:t}),a=fu({inputs:{x:i},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(i),a}if(!w.hasEncodingLoss(o.dtype,s)){let i=dg({inputs:{x:o},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(s==="int32"){let i=t.data.get(o.dataId).values,a=Int32Array.from(i);return t.makeTensorInfo(o.shape,"int32",a)}if(s==="bool"){let i=t.data.get(o.dataId).values,a=w.toTypedArray([0],o.dtype),[u,l]=Oe((c,p)=>c!==p?1:0)(o.shape,[],i,a,"bool");return t.makeTensorInfo(l,"bool",u)}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}function Ue(r,e,t,n){return t==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;mu([i,a],r);let l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,p=i.dtype==="string"?k.fromUint8ToStringArray(l):l,m=i.dtype==="string"?k.fromUint8ToStringArray(c):c,f=n||i.dtype,[d,h]=e(i.shape,a.shape,p,m,f);return u.makeTensorInfo(h,f,d)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let l=fu({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(l.dataId),p=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,f=u.data.get(p.dataId).values,d=u.data.get(m.dataId).values,h=fu({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(h.dataId),y=g.complexTensorInfos.real,I=g.complexTensorInfos.imag,_=u.data.get(y.dataId).values,N=u.data.get(I.dataId).values,[R,F,D]=t(i.shape,a.shape,f,d,_,N),O=u.makeTensorInfo(D,"float32",R),U=u.makeTensorInfo(D,"float32",F),M=ei({inputs:{real:O,imag:U},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(O),u.disposeIntermediateTensorInfo(U),M}else{let l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,p=n||i.dtype,[m,f]=e(i.shape,a.shape,l,c,p);return u.makeTensorInfo(f,p,m)}}}function ti(r){return(e,t,n,o,s,i)=>{let a=k.assertAndGetBroadcastShape(e,t),u=w.sizeFromShape(a),l=a.length,c=w.computeStrides(a),p=w.getTypedArrayFromDType("float32",u),m=w.getTypedArrayFromDType("float32",u),f=k.getBroadcastDims(e,a),d=k.getBroadcastDims(t,a),h=k.mergeRealAndImagArrays(n,o),g=k.mergeRealAndImagArrays(s,i),y=e.length,I=w.computeStrides(e),_=t.length,N=w.computeStrides(t);if(f.length+d.length===0)for(let R=0;R<p.length;R++){let F=R%h.length,D=R%g.length,O=r(h[F*2],h[F*2+1],g[D*2],g[D*2+1]);p[R]=O.real,m[R]=O.imag}else for(let R=0;R<p.length;R++){let F=w.indexToLoc(R,l,c),D=F.slice(-y);f.forEach(j=>D[j]=0);let O=w.locToIndex(D,y,I),U=F.slice(-_);d.forEach(j=>U[j]=0);let M=w.locToIndex(U,_,N),G=r(h[O*2],h[O*2+1],g[M*2],g[M*2+1]);p[R]=G.real,m[R]=G.imag}return[p,m,a]}}var hg=Oe((r,e)=>r+e),mL=ti((r,e,t,n)=>({real:r+t,imag:e+n})),Cfe=Ue(fr,hg,mL);function FI(r,e,t,n,o){let s=w.sizeFromShape(n),i=w.makeZerosTypedArray(o,t);for(let a=0;a<r.length;a++){let u=r[a];if(u<0)throw new Error("Input x must be non-negative!");u>=o||(s>0?i[u]+=e[a]:i[u]+=1)}return i}function PI(r,e,t,n=!1){let o=r.shape[0],s=r.shape[1],i=ye([o,t],e.dtype);for(let a=0;a<o;a++)for(let u=0;u<s;u++){let l=r.get(a,u);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(n?i.set(1,a,l):e.size>0?i.set(i.get(a,l)+e.get(a,u),a,l):i.set(i.get(a,l)+1,a,l))}return i}function gt(r){return(e,t,n)=>{let o=w.getTypedArrayFromDType(t,e.length);for(let s=0;s<e.length;++s)o[s]=r(e[s],n);return o}}function rp(r,e,t){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(mu(i,r),i.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,u=a.data.get(i.dataId).values,l=w.sizeFromShape(i.shape),c=t||i.dtype,p=w.getArrayFromDType(c,l);for(let m=0;m<l;++m)p[m]=e(u[m],o);return a.makeTensorInfo(i.shape,c,p)}}function qt(r,e,t){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(mu(i,r),i.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,u=a.data.get(i.dataId).values,l=t||i.dtype,c=e(u,l,o);return a.makeTensorInfo(i.shape,l,c)}}var gg=gt(r=>Math.ceil(r)),Pfe=qt(mn,gg);function du(r,e,t,n){let o=w.getArrayFromDType(t,w.sizeFromShape(e));if(n&&t!=="string"){let s=0;r.forEach(i=>{let a=w.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;r.forEach(i=>{let a=t==="string"?k.fromUint8ToStringArray(i.vals):i.vals,u=0;for(let l=0;l<i.shape[0];++l){let c=l*e[1]+s;for(let p=0;p<i.shape[1];++p)o[c+p]=a[u++]}s+=i.shape[1]})}return o}var xg=Oe((r,e)=>r===e?1:0),Gfe=Ue(fn,xg,null,"bool");var _g=gt(r=>Math.exp(r)),Kfe=qt(dn,_g);var yg=gt(r=>Math.expm1(r)),Zfe=qt(ha,yg);var bg=gt(r=>Math.floor(r)),ode=qt(hn,bg);function LI(r,e,t,n,o,s,i,a,u){let l=ye([n,s],t);for(let c=0;c<n;c++){let p=[],m=0;for(let f=0;f<o;f++){let d=r[c*o+f];m+=d*i[f],p.push(d)}if(m<0||m>=u/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let f=0;f<s;f++)l.values[c*s+f]=e.get(...e.indexToLoc(m*s+f))}return l}function MI(r,e,t){let n=ye(t,r.dtype);for(let o=0;o<n.size;++o){let i=n.indexToLoc(o).slice(),a=i[0],u=i[2],l=e.locToIndex([a,u]);i[2]=e.values[l];let c=r.locToIndex(i);n.values[o]=r.values[c]}return n}var wg=Oe((r,e)=>r>e?1:0),fde=Ue(gn,wg,null,"bool");var vg=Oe((r,e)=>r>=e?1:0),_de=Ue(xn,vg,null,"bool");var Ig=Oe((r,e)=>r<e?1:0),Ide=Ue(_n,Ig,null,"bool");var Cg=Oe((r,e)=>r<=e?1:0),Nde=Ue(yn,Cg,null,"bool");function BI(r,e,t){let n=(e-r)/(t-1),o=w.makeZerosTypedArray(t,"float32");o[0]=r;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var Tg=gt(r=>Math.log(r)),Fde=qt(bn,Tg);function UI(r,e,t,n){let o=w.getTypedArrayFromDType(n,w.sizeFromShape(t));for(let s=0;s<o.length;++s){let i=s*e,a=r[i];for(let u=0;u<e;++u){let l=r[i+u];(Number.isNaN(l)||l>a)&&(a=l)}o[s]=a}return o}var Sg=Oe((r,e)=>Math.max(r,e)),Vde=Ue(wn,Sg);var kg=Oe((r,e)=>Math.min(r,e)),qde=Ue(vn,kg);var hu=Oe((r,e)=>r*e),fL=ti((r,e,t,n)=>({real:r*t-e*n,imag:r*n+e*t})),Qde=Ue(In,hu,fL);function WI(r,e,t){let n=w.createScalarValue(-1,t);return hu([],e,n,r,t)}var Ng=Oe((r,e)=>r!==e?1:0),ahe=Ue(Cn,Ng,null,"bool");function VI(r,e,t,n,o){let s=e.length,i=w.sizeFromShape(e),a=w.computeStrides(e),u=w.computeStrides(o),l=w.getTypedArrayFromDType(t,w.sizeFromShape(o));for(let c=0;c<i;++c){let p=w.indexToLoc(c,s,a),m=new Array(p.length);for(let d=0;d<m.length;d++)m[d]=p[n[d]];let f=w.locToIndex(m,s,u);l[f]=r[c]}return l}function GI(r,e,t,n){let[o,s]=k.computeOutAndReduceShapes(r,n),i=ut(e,"int32"),a=w.makeZerosTypedArray(w.sizeFromShape(o),i),u=w.sizeFromShape(s);for(let l=0;l<a.length;++l){let c=l*u,p=1;for(let m=0;m<u;++m)p*=t[c+m];a[l]=p}return{outVals:a,outShape:o,outDtype:i}}function gu(r,e,t,n){let o=r===e,s=r<e&&t<0,i=e<r&&t>1;if(o||s||i)return w.makeZerosTypedArray(0,n);let a=Math.abs(Math.ceil((e-r)/t)),u=w.makeZerosTypedArray(a,n);e<r&&t===1&&(t=-1),u[0]=r;for(let l=1;l<u.length;l++)u[l]=u[l-1]+t;return u}var Eg=gt(r=>1/Math.sqrt(r)),xhe=qt(Sn,Eg);var zI=gt(r=>1/(1+Math.exp(-r))),vhe=rp(kn,r=>1/(1+Math.exp(-r)));function ri(r,e,t,n,o){let s=st.isSliceContinous(n,e,t),i=w.sizeFromShape(t),a=w.computeStrides(n);if(s){let p=st.computeFlatOffset(e,a);return o==="string"?r.slice(p,p+i):r.subarray(p,p+i)}let u=o==="string"?k.fromUint8ToStringArray(r):r,l=ye(n,o,u),c=ye(t,o);for(let p=0;p<c.size;++p){let m=c.indexToLoc(p),f=m.map((d,h)=>d+e[h]);c.set(l.get(...f),...m)}return o==="string"?k.fromStringArrayToUint8(c.values):c.values}function HI(r,e,t,n,o,s,i){let a=e[0],u=s[0],l=new Array(u),c=new Array(a),p=e[1];if(u===0){if(a!==0)throw new Error(`Received SparseTensor with denseShape[0] = 0 but
         indices.shape[0] = ${a}`);let g=w.getArrayFromDType(t,0),y=w.getArrayFromDType(o,0);return[g,[0,p],y,l,c]}let m=!0,f=0,d=new Array(u).fill(0);for(let g=0;g<a;++g){let y=r[g*p];if(y<0)throw new Error(`indices(${g}, 0) is invalid: ${y} < 0`);if(y>=u)throw new Error(`indices(${g}, 0) is invalid: ${y} >= ${u}`);++d[y],m=m&&y>=f,f=y}let h=!0;for(let g=0;g<u;++g){let y=d[g]===0;l[g]=y,h=h&&!y,d[g]=Math.max(d[g],1),g>0&&(d[g]+=d[g-1])}if(h&&m){let g=r,y=n;for(let I=0;I<a;++I)c[I]=I;return[g,[a,p],y,l,c]}else{let g=d[u-1],y=w.getArrayFromDType(t,g*p),I=w.getArrayFromDType(o,g),_=new Array(u).fill(0);for(let N=0;N<a;++N){let R=r[N*p],F=_[R],D=(R===0?0:d[R-1])+F;_[R]++;for(let O=0;O<p;++O)y[D*p+O]=r[N*p+O];I[D]=n[N],c[N]=D}for(let N=0;N<u;++N)if(_[N]===0){let F=N===0?0:d[N-1];y[F*p+0]=N;for(let D=1;D<p;++D)y[F*p+D]=0;I[F]=i}return[y,[g,p],I,l,c]}}function jI(r,e,t,n,o){let s=w.sizeFromShape(n),i=e[0],a=o.length,u=[],l=1,c=-1;for(let g=0;g<a;++g){let y=o[g];if(y===-1){if(c!==-1)throw new Error(`only one output dimension may be -1, not both ${c} and ${g}`);c=g,u.push(1)}else{if(y<0)throw new Error(`size ${g} must be non-negative, not ${y}`);l*=y,u.push(y)}}if(c!==-1){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");let g=Math.trunc(s/l);if(l*g!==s)throw new Error(`Input to reshape is a SparseTensor with ${s}
          dense values, but the requested shape requires a multiple of ${l}. inputShape=${n} outputShape= ${u}`);u[c]=g}let p=w.sizeFromShape(u);if(p!==s)throw new Error(`Input to reshape is a tensor with ${s} dense values, but the requested shape has ${p}. inputShape=${n} outputShape=${u}`);let m=n.length,f=[];if(m>0){f[m-1]=1;for(let g=m-2;g>=0;--g)f[g]=f[g+1]*n[g+1]}let d=[];if(a>0){d[a-1]=1;for(let g=a-2;g>=0;--g)d[g]=d[g+1]*u[g+1]}let h=w.getArrayFromDType(t,i*a);for(let g=0;g<i;++g){let y=0;for(let I=0;I<m;++I)y+=r[g*m+I]*f[I];for(let I=0;I<a;++I)h[g*a+I]=Math.trunc(y/d[I]),y%=d[I]}return[h,[i,a],u]}function qI(r,e,t,n,o,s=!1,i=0){let a=n.length;if(a!==o.length)throw new Error("segmentIds and indices should have same size.");let u=[e[0],r.length/e[0]],l=u[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error("segment ids must be >= 0");let m=e.slice();m[0]=p;let f=m.reduce((_,N)=>_*N,1),d=w.getArrayFromDType(t,f);if(a===0)return p>0&&d.fill(i),[d,m];if(p<=0)throw new Error("segment ids must be >= 0");let h=0,g=1,y=0,I=o[h];for(;;){let _=0;if(g<a){if(_=o[g],I===_){++g;continue}if(I>=_)throw new Error("segment ids are not increasing")}if(I<0||I>=p)throw new Error(`Segment id ${I} out of range [0, ${p}), possibly because segmentIds input is not sorted.`);I>y&&d.fill(i,y*l,I*l);for(let N=h;N<g;++N){let R=n[N];if(R<0||R>=u[0])throw new Error(`Bad: indices[${N}] == ${n[N]} out of range [0, ${u[0]})`);for(let F=0;F<l;F++)d[I*l+F]+=r[R*l+F]}if(s)for(let N=0;N<l;N++)d[I*l+N]/=g-h;if(h=g,++g,y=I+1,I=_,g>a)break}return y<p&&d.fill(i,y*l,p*l),[d,m]}var KI=gt(r=>Math.sqrt(r)),Fhe=rp(Nn,r=>Math.sqrt(r));var Ag=Oe((r,e)=>{let t=r-e;return t*t}),Uhe=Ue(En,Ag);function XI(r,e,t,n){let o=ye(r,e.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*t[u]+n[u];o.set(e.get(...a),...i)}return o}var YI=class{constructor(e,t,n,o,s,i){this.separator=w.encodeString(e),this.nGramWidths=t,this.leftPad=w.encodeString(n),this.rightPad=w.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,o,s,i){for(let a=0;a<s;++a){let u=this.getPadWidth(i),l=Math.max(0,u-a),c=Math.max(0,u-(s-(a+1))),p=i-(l+c),m=t+(l>0?0:a-u),f=0;f+=l*this.leftPad.length;for(let I=0;I<p;++I)f+=e[m+I].length;f+=c*this.rightPad.length,f+=(l+c+p-1)*this.separator.length,n[o+a]=new Uint8Array(f);let h=n[o+a],g=0,y=I=>I.forEach(_=>h[g++]=_);for(let I=0;I<l;++I)y(this.leftPad),y(this.separator);for(let I=0;I<p-1;++I)y(e[m+I]),y(this.separator);if(p>0){y(e[m+p-1]);for(let I=0;I<c;++I)y(this.separator),y(this.rightPad)}else{for(let I=0;I<c-1;++I)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){let n=e.length,o=t.length;if(o>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<o;++l){let c=t[l]>=u;if(c=c&&t[l]<=n,!c)throw new Error(`Invalid split value ${t[l]}, must be in [${u}, ${n}]`);u=t[l]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}let s=o-1,i=w.getArrayFromDType("int32",o);if(n===0||o===0){let u=new Array(n);for(let l=0;l<=s;++l)i[l]=0;return[u,i]}i[0]=0;for(let u=1;u<=s;++u){let l=t[u]-t[u-1],c=0;this.nGramWidths.forEach(p=>{c+=this.getNumNGrams(l,p)}),this.preserveShort&&l>0&&c===0&&(c=1),i[u]=i[u-1]+c}let a=new Array(i[s]);for(let u=0;u<s;++u){let l=t[u],c=i[u];if(this.nGramWidths.forEach(p=>{let m=t[u+1]-t[u],f=this.getNumNGrams(m,p);this.createNGrams(e,l,a,c,f,p),c+=f}),this.preserveShort&&c===i[u]){let p=t[u+1]-t[u];if(p===0)continue;let m=p+2*this.padWidth,f=1;this.createNGrams(e,l,a,c,f,m)}}return[a,i]}};function JI(r,e,t,n,o,s,i,a){return new YI(t,n,o,s,i,a).compute(r,e)}function dL(r,e,t,n){if(!r.length)return;if(e.length===0){for(let s=0;s<r.length;++s)n.push(r.subarray(s,s+1));return}if(e.length===1){let s=e[0],i=r.indexOf(s);for(;i!==-1;){let a=r.subarray(0,i);(!t||a.length!==0)&&n.push(a),r=r.subarray(i+1),i=r.indexOf(s)}(!t||r.length!==0)&&n.push(r);return}let o=0;for(let s=0;s<r.length+1;s++)if(s===r.length||e.indexOf(r[s])!==-1){let i=r.subarray(o,s);(!t||i.length!==0)&&n.push(i),o=s+1}}function QI(r,e,t){let n=r.length,o=[],s=0,i=0,a=new Array(n);for(let m=0;m<n;++m){let f=o.length;dL(r[m],e,t,o);let d=o.length-f;a[m]=d,s+=d,i=Math.max(i,d)}let u=w.getArrayFromDType("int32",s*2),l=new Array(s),c=[n,i],p=0;for(let m=0;m<n;++m)for(let f=0;f<a[m];++f)u[p*2]=m,u[p*2+1]=f,l[p]=o[p],++p;return[u,l,c]}function ZI(r,e){let t=w.getArrayFromDType("int32",r.length);for(let n=0;n<r.length;++n)t[n]=w.fingerPrint64(r[n]).modulo(e).getLowBitsUnsigned();return t}var Rg=Oe((r,e)=>r-e),hL=ti((r,e,t,n)=>({real:r-t,imag:e-n})),Zhe=Ue(An,Rg,hL);function eC(r,e){let t=new Array(r.rank);for(let o=0;o<t.length;o++)t[o]=r.shape[o]*e[o];let n=ye(t,r.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),i=new Array(r.rank);for(let u=0;u<i.length;u++)i[u]=s[u]%r.shape[u];let a=r.locToIndex(i);n.values[o]=r.values[a]}return n}var xu=(r,e)=>{let t=e.value-r.value;return t===0?r.index-e.index:t};function tC(r,e,t=0,n=r.length-1){for(;n>t;){if(n-t>600){let a=n-t+1,u=e-t+1,l=Math.log(a),c=.5*Math.exp(2*l/3),p=.5*Math.sqrt(l*c*(a-c)/a)*Math.sign(u-a/2),m=Math.max(t,Math.floor(e-u*c/a+p)),f=Math.min(n,Math.floor(e+(a-u)*c/a+p));tC(r,e,m,f)}let o=r[e],s=t,i=n;for(w.swap(r,t,e),xu(r[n],o)>0&&w.swap(r,t,n);s<i;){for(w.swap(r,s,i),s++,i--;xu(r[s],o)<0;)s=s+1;for(;xu(r[i],o)>0;)i=i-1}xu(r[t],o)===0?w.swap(r,t,i):(i=i+1,w.swap(r,i,n)),i<=e&&(t=i+1),e<=i&&(n=i-1)}}function rC(r,e,t,n,o){let s=e[e.length-1],[i,a]=[r.length/s,s],u=w.getTypedArrayFromDType(t,i*n),l=w.getTypedArrayFromDType("int32",i*n);for(let p=0;p<i;p++){let m=p*a,f=r.subarray(m,m+a),d=new Array(f.length);f.forEach((I,_)=>d[_]={value:I,index:_}),n<d.length&&(tC(d,n),d=d.slice(0,n)),o&&d.sort(xu);let h=p*n,g=u.subarray(h,h+n),y=l.subarray(h,h+n);for(let I=0;I<n;I++)g[I]=d[I].value,y[I]=d[I].index}let c=e.slice();return c[c.length-1]=n,[ye(c,t,u),ye(c,"int32",l)]}function nC(r,e,t,n){let o=w.parseAxisParam(e,t)[0],s=[1,t[0],1];for(let d=0;d<o;d++)s[0]*=t[d];s[1]=t[o];for(let d=o+1;d<t.length;d++)s[2]*=t[d];let i={},a=new Int32Array(t[o]),u=new dr(s,n,r),l=[],c=s[0]===1&&s[2]===1;for(let d=0;d<t[o];d++){let h;if(c)h=r[d].toString();else{let g=[];for(let y=0;y<s[0];y++)for(let I=0;I<s[2];I++)g.push(u.get(y,d,I));h=g.join(",")}if(i[h]!==void 0)a[d]=i[h];else{let g=Object.keys(i).length;i[h]=g,a[d]=g,l.push(d)}}let p=s.slice();p[1]=Object.keys(i).length;let m=new dr(p,n);l.forEach((d,h)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)m.set(u.get(g,d,y),g,h,y)});let f=t.slice();return f[o]=p[1],{outputValues:m.values,outputShape:f,indices:a}}function Hr(r){let{inputs:{x:e},attrs:{begin:t,size:n},backend:o}=r,[s,i]=st.parseSliceParams(e,t,n),a=st.isSliceContinous(e.shape,s,i),u=o.readSync(e.dataId),l=o.makeOutput(i,e.dtype),c=w.computeStrides(e.shape),p=o.dataIdMap.get(l.dataId);if(a){let d=st.computeFlatOffset(s,c);return e.dtype==="string"?p.stringBytes=u.slice(d,d+w.sizeFromShape(i)):o.typedArrayFromHeap(l).set(u.subarray(d,d+w.sizeFromShape(i))),l}if(e.dtype==="string"){let d=ri(u,s,i,e.shape,e.dtype);return p.stringBytes=d,l}let m=o.typedArrayFromHeap(l),f=e.shape.length;if(f===2)gL(u,c[0],m,s,i);else if(f===3)xL(u,c[0],c[1],m,s,i);else if(f===4)_L(u,c[0],c[1],c[2],m,s,i);else{let d=ri(u,s,i,e.shape,e.dtype);m.set(d)}return l}function gL(r,e,t,n,o){let s=0,i=n[0],a=n[1],u=i+o[0];for(let l=i;l<u;l++){let c=l*e+a;t.set(r.subarray(c,c+o[1]),s),s+=o[1]}}function xL(r,e,t,n,o,s){let i=0,a=o[0],u=o[1],l=o[2],c=a+s[0],p=u+s[1];for(let m=a;m<c;m++)for(let f=u;f<p;f++){let d=m*e+f*t+l;n.set(r.subarray(d,d+s[2]),i),i+=s[2]}}function _L(r,e,t,n,o,s,i){let a=0,u=s[0],l=s[1],c=s[2],p=u+i[0],m=l+i[1],f=c+i[2],d=s[3];for(let h=u;h<p;h++)for(let g=l;g<m;g++)for(let y=c;y<f;y++){let I=h*e+g*t+y*n+d;o.set(r.subarray(I,I+i[3]),a),a+=i[3]}}var oC={kernelName:zo,backendName:"wasm",kernelFunc:Hr};function yL(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:i}=n,a=s.reduce((y,I)=>y*I),u=k.getReshaped(o.shape,s,a),l=k.getPermuted(u.length,s.length),c=k.getReshapedPermuted(o.shape,s,a),p=k.getSliceBeginCoords(i,s.length),m=k.getSliceSize(c,i,s.length),f=Ge({inputs:{x:o},backend:t,attrs:{shape:u}}),d=vr({inputs:{x:f},backend:t,attrs:{perm:l}}),h=Ge({inputs:{x:d},backend:t,attrs:{shape:c}}),g=Hr({inputs:{x:h},backend:t,attrs:{begin:p,size:m}});return t.disposeData(f.dataId),t.disposeData(d.dataId),t.disposeData(f.dataId),g}var sC={kernelName:ua,backendName:"wasm",kernelFunc:yL};function Ss(r){let{inputs:{x:e},attrs:{dtype:t},backend:n}=r,o=n.makeOutput(e.shape,t),s=n.typedArrayFromHeap(e);return n.typedArrayFromHeap(o).set(s),o}var aC={kernelName:Mr,backendName:"wasm",kernelFunc:Ss};var iC=me(mn);var uC;function bL(r){uC=r.wasm.cwrap(_o,null,["number","number","number","number"])}function wL(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:i}=n,a=t.dataIdMap.get(o.dataId).id,u=t.makeOutput(o.shape,o.dtype),l=t.dataIdMap.get(u.dataId).id;return uC(a,s,i,l),u}var lC={kernelName:_o,backendName:"wasm",setupFunc:bL,kernelFunc:wL};function Dg(r){let{inputs:e,backend:t}=r,n=w.parseAxisParam(r.attrs.axis,e[0].shape)[0],o=k.computeOutShape(e.map(f=>f.shape),n),s=e.filter(f=>w.sizeFromShape(f.shape)>0);if(s.length===1)return Ts({inputs:{x:s[0]},backend:t});let i=t.makeOutput(o,e[0].dtype);if(w.sizeFromShape(o)===0)return i;let a=s.map(f=>f.shape);if(k.assertParamsConsistent(a,n),s[0].dtype==="string"){let f=s.map(_=>{let N=w.sizeFromShape(_.shape.slice(n));return Ge({inputs:{x:_},backend:t,attrs:{shape:[-1,N]}})}),d=f.map(_=>({vals:t.readSync(_.dataId),shape:_.shape}));o=k.computeOutShape(f.map(_=>_.shape),1);let h=f[0].shape[0]===1,g=du(d,o,e[0].dtype,h),y=k.computeOutShape(s.map(_=>_.shape),n);i.shape=y;let I=t.dataIdMap.get(i.dataId);return I.stringBytes=k.fromStringArrayToUint8(g),f.forEach(_=>t.disposeData(_.dataId)),i}let u=w.sizeFromShape(s[0].shape.slice(0,n)),l=0,c=s.map(f=>{let d=w.sizeFromShape(f.shape.slice(n));return l+=d,d}),p=s.map(f=>t.typedArrayFromHeap(f)),m=t.typedArrayFromHeap(i);for(let f=0;f<u;f++){let d=f*l;for(let h=0;h<p.length;h++){let g=c[h],y=f*g,I=p[h].subarray(y,y+g);m.set(I,d),d+=g}}return i}var cC={kernelName:la,backendName:"wasm",kernelFunc:Dg};var pC;function vL(r){pC=r.wasm.cwrap(yo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function IL(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,i=n.dataIdMap.get(o.dataId).id,a=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:p,dataFormat:m}=t,f=k.convertConv2DDataFormat(m),d=k.computeConv2DInfo(o.shape,s.shape,u,l,c,p,!1,f),h=d.filterHeight,g=d.filterWidth,y=d.padInfo.top,I=d.padInfo.right,_=d.padInfo.bottom,N=d.padInfo.left,R=d.dilationHeight,F=d.dilationWidth,D=d.strideHeight,O=d.strideWidth,U=d.inChannels,M=d.outChannels,G=d.padInfo.type==="SAME"?1:0;if(d.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let j=n.makeOutput(d.outShape,"float32"),ee=n.dataIdMap.get(j.dataId).id;return pC(i,o.shape[0],o.shape[1],o.shape[2],a,h,g,y,I,_,N,G,R,F,D,O,U,M,ee),j}var mC={kernelName:yo,backendName:"wasm",setupFunc:vL,kernelFunc:IL};var fC;function CL(r){fC=r.wasm.cwrap(bo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function TL(r){let{backend:e,inputs:t,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,inputShape:c}=n,p=1,m=k.convertConv2DDataFormat(u),f=k.computeConv2DInfo(c,s.shape,i,p,a,l,!1,m),{batchSize:d,filterHeight:h,filterWidth:g,inChannels:y,inHeight:I,inWidth:_,outChannels:N,outHeight:R,outWidth:F,strideHeight:D,strideWidth:O}=f,U=h-1-f.padInfo.top,M=g-1-f.padInfo.left,G=f.dataFormat==="channelsLast",j=w.computeStrides(f.inShape),ee=w.computeStrides(o.shape),[Q,ie,le]=w.computeStrides(s.shape),Ce=j[0],de=G?j[1]:j[2],Qe=G?j[2]:1,se=G?1:j[1],it=ee[0],rt=G?ee[1]:ee[2],We=G?ee[2]:1,_t=G?1:ee[1],lr=e.makeOutput(f.inShape,"float32"),Nt=e.dataIdMap.get(lr.dataId).id,rn=e.dataIdMap.get(o.dataId).id,zs=e.dataIdMap.get(s.dataId).id;return fC(rn,zs,d,h,g,I,_,y,R,F,N,D,O,U,M,Q,ie,le,Ce,de,Qe,se,it,rt,We,_t,Nt),lr}var dC={kernelName:bo,backendName:"wasm",setupFunc:CL,kernelFunc:TL};var hC=me(ca);var gC=me(pa);var Og;(function(r){r[r.bilinear=0]="bilinear",r[r.nearest=1]="nearest"})(Og||(Og={}));var xC;function SL(r){xC=r.wasm.cwrap(vo,null,["number","number","number","number","array","number","number","number","number","number"])}function kL(r){let{backend:e,inputs:t,attrs:n}=r,{method:o,extrapolationValue:s,cropSize:i}=n,{image:a,boxes:u,boxInd:l}=t,c=u.shape[0],[p,m]=i,f=[c,p,m,a.shape[3]],d=e.dataIdMap.get(a.dataId),h;a.dtype!=="float32"&&(h=Ss({backend:e,inputs:{x:a},attrs:{dtype:"float32"}}),d=e.dataIdMap.get(h.dataId));let g=d.id,y=e.dataIdMap.get(u.dataId).id,I=e.dataIdMap.get(l.dataId).id,_=e.makeOutput(f,"float32"),N=e.dataIdMap.get(_.dataId).id,R=new Uint8Array(new Int32Array(a.shape).buffer);return xC(g,y,I,c,R,p,m,Og[o],s,N),h!=null&&e.disposeData(h.dataId),_}var _C={kernelName:vo,backendName:"wasm",setupFunc:SL,kernelFunc:kL};var yC;function NL(r){yC=r.wasm.cwrap(wo,null,["number","number","number","number","number","number"])}function EL(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length;w.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumsum does not support ${o.dtype} tensors in the WASM backend`);let l=k.getAxesPermutation([s],u),c=o;l!==null&&(c=vr({inputs:{x:o},attrs:{perm:l},backend:t}));let p=k.getInnerMostAxes(1,u)[0];k.assertAxesAreInnerMostDims("cumsum",[p],u);let m=t.makeOutput(c.shape,c.dtype),f=c.shape[p],d=t.dataIdMap.get(c.dataId).id,h=t.dataIdMap.get(m.dataId).id;yC(d,i?1:0,a?1:0,f,h,ke[o.dtype]);let g=m;if(l!==null){let y=k.getUndoAxesPermutation(l);g=vr({inputs:{x:m},attrs:{perm:y},backend:t}),t.disposeData(c.dataId),t.disposeData(m.dataId)}return g}var bC={kernelName:wo,backendName:"wasm",setupFunc:NL,kernelFunc:EL};var wC;function AL(r){wC=r.wasm.cwrap(Io,null,["number","number","number","array","number","array","array","number","number"])}function RL(r){let{backend:e,inputs:t,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n;w.assert(s>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${s}`);let a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=u*s,m=l*s,f=c/(s*s),d=i==="NHWC"?[a,p,m,f]:[a,f,p,m],h=e.makeOutput(d,"float32"),y=e.dataIdMap.get(o.dataId).id,I=new Uint8Array(new Int32Array(w.computeStrides(o.shape)).buffer),_=new Uint8Array(new Int32Array(d).buffer),N=new Uint8Array(new Int32Array(w.computeStrides(d)).buffer),R=e.dataIdMap.get(h.dataId).id;return wC(y,s,i==="NHWC"?1:0,I,o.shape.length-1,_,N,d.length,R),h}var vC={kernelName:Io,backendName:"wasm",setupFunc:AL,kernelFunc:RL};var IC;function $L(r){IC=r.wasm.cwrap(Co,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function DL(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,i=n.dataIdMap.get(o.dataId).id,a=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:p}=t,m=l??[1,1],f=k.computeConv2DInfo(o.shape,s.shape,u,m,c,p,!0),d=f.filterHeight,h=f.filterWidth,g=f.padInfo.top,y=f.padInfo.right,I=f.padInfo.bottom,_=f.padInfo.left,N=f.dilationHeight,R=f.dilationWidth,F=f.strideHeight,D=f.strideWidth,O=f.inChannels,U=f.outChannels,M=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let G=n.makeOutput(f.outShape,"float32"),j=n.dataIdMap.get(G.dataId).id;return IC(i,o.shape[0],o.shape[1],o.shape[2],a,d,h,g,y,I,_,M,N,R,F,D,O,U,j),G}var CC={kernelName:Co,backendName:"wasm",setupFunc:$L,kernelFunc:DL};var TC=me(fa);var OL=!1,SC=we(fn,OL,"bool");var kC=me(dn);function np(r){let{inputs:e,attrs:t,backend:n}=r,{input:o}=e,{dim:s}=t,i=o.shape.length,a=o.shape.slice(),u=s;return s<0&&(w.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),Ge({inputs:{x:o},backend:n,attrs:{shape:a}})}var NC={kernelName:da,backendName:"wasm",kernelFunc:np};function Fg(r){let{attrs:{shape:e,value:t,dtype:n},backend:o}=r,s=o.makeOutput(e,n);return o.typedArrayFromHeap(s).fill(t),s}var EC={kernelName:ga,backendName:"wasm",kernelFunc:Fg};var AC;function FL(r){AC=r.wasm.cwrap(To,null,["number","number","number","number","number","number"])}function PL(r){let{inputs:e,backend:t}=r,{image:n}=e,o=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(n.dataId).id,i=t.dataIdMap.get(o.dataId).id,[a,u,l,c]=n.shape;return AC(s,a,u,l,c,i),o}var RC={kernelName:To,backendName:"wasm",kernelFunc:PL,setupFunc:FL};var $C=me(hn);var LL=!1,DC=we(xa,LL);var OC;function ML(r){OC=r.wasm.cwrap(So,null,["number","number","number","number","number","number","number"])}function BL(r){let{backend:e,inputs:t,attrs:n}=r,{varianceEpsilon:o}=n,{x:s,mean:i,variance:a,offset:u,scale:l}=t,c=e.dataIdMap.get(s.dataId).id,p=e.dataIdMap.get(i.dataId).id,m=e.dataIdMap.get(a.dataId).id,f=u!=null?e.dataIdMap.get(u.dataId).id:0,d=l!=null?e.dataIdMap.get(l.dataId).id:0,h=e.makeOutput(s.shape,s.dtype);if(w.sizeFromShape(s.shape)===0)return h;let g=e.dataIdMap.get(h.dataId).id;return OC(c,p,m,f,d,o,g),h}var FC={kernelName:So,backendName:"wasm",setupFunc:ML,kernelFunc:BL};var PC;function UL(r){PC=r.wasm.cwrap($n,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function WL(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:c,dataFormat:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=t,h=k.computeConv2DInfo(o.shape,s.shape,u,c,l,m),g=Hn[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedConv2D in the wasm backend.`);let y=n.dataIdMap.get(o.dataId).id,I=n.dataIdMap.get(s.dataId).id,_=h.outChannels,N=0;if(i!=null){let We=n.dataIdMap.get(i.dataId);if(We.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${We.shape.length}.`);if(We.shape[0]!==_)throw new Error(`FusedConv2D bias shape (${We.shape}) does not match the number of output channels (${_})`);N=We.id}let R=h.filterHeight,F=h.filterWidth,D=h.padInfo.top,O=h.padInfo.right,U=h.padInfo.bottom,M=h.padInfo.left,G=h.dilationHeight,j=h.dilationWidth,ee=h.strideHeight,Q=h.strideWidth,ie=h.inChannels,le=h.padInfo.type==="SAME"?1:0,Ce=h.batchSize,de=h.inHeight,Qe=h.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let se=n.makeOutput(h.outShape,"float32"),it=n.dataIdMap.get(se.dataId).id,rt=a==null?0:n.dataIdMap.get(a.dataId).id;return PC(y,Ce,de,Qe,I,R,F,N,D,O,U,M,le,G,j,ee,Q,ie,_,g,rt,d||0,it),se}var LC={kernelName:$n,backendName:"wasm",setupFunc:UL,kernelFunc:WL};var MC;function VL(r){MC=r.wasm.cwrap(Dn,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function GL(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:c,dataFormat:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=t,h=k.computeConv2DInfo(o.shape,s.shape,u,c,l,m,!0),g=Hn[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=n.dataIdMap.get(o.dataId).id,I=n.dataIdMap.get(s.dataId).id,_=h.outChannels,N=0;if(i!=null){let We=n.dataIdMap.get(i.dataId);if(We.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${We.shape.length}.`);if(We.shape[0]!==_)throw new Error(`FusedDepthwiseConv2D bias shape (${We.shape}) does not match the number of output channels (${_})`);N=We.id}let R=h.filterHeight,F=h.filterWidth,D=h.padInfo.top,O=h.padInfo.right,U=h.padInfo.bottom,M=h.padInfo.left,G=h.dilationHeight,j=h.dilationWidth,ee=h.strideHeight,Q=h.strideWidth,ie=h.inChannels,le=h.padInfo.type==="SAME"?1:0,Ce=h.batchSize,de=h.inHeight,Qe=h.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let se=n.makeOutput(h.outShape,"float32"),it=n.dataIdMap.get(se.dataId).id,rt=a==null?0:n.dataIdMap.get(a.dataId).id;return MC(y,Ce,de,Qe,I,R,F,N,D,O,U,M,le,G,j,ee,Q,ie,_,g,rt,d||0,it),se}var BC={kernelName:Dn,backendName:"wasm",setupFunc:VL,kernelFunc:GL};var UC;function zL(r){UC=r.wasm.cwrap(ko,null,["number","number","number","number","number","number","array","number"])}function HL(r){let{backend:e,inputs:t}=r,{params:n,indices:o}=t,[s,i,a,u]=Pc.prepareAndValidate(n,o),l=e.makeOutput(s,n.dtype);if(i===0)return l;let c=o.shape,p=c[c.length-1],f=e.dataIdMap.get(n.dataId).id,h=e.dataIdMap.get(o.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),y=e.dataIdMap.get(l.dataId).id;return UC(f,ke[n.dtype],h,i,p,a,g,y),l}var WC={kernelName:ko,backendName:"wasm",setupFunc:zL,kernelFunc:HL};var VC;function jL(r){VC=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function qL(r){let{backend:e,inputs:t,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n,u=w.parseAxisParam(i,o.shape)[0],l=k.segment_util.collectGatherOpShapeInfo(o,s,u,a),c=Ge({inputs:{x:o},attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]},backend:e}),p=w.sizeFromShape(s.shape),m=Ge({inputs:{x:s},attrs:{shape:[l.batchSize,p/l.batchSize]},backend:e}),f=[l.batchSize,l.outerSize,p/l.batchSize,l.sliceSize],d=e.makeOutput(f,o.dtype);if(w.sizeFromShape(o.shape)===0)return d;let h=c.shape.length-1,y=e.dataIdMap.get(c.dataId).id,_=e.dataIdMap.get(m.dataId).id,N=e.dataIdMap.get(d.dataId).id,R=new Uint8Array(new Int32Array(w.computeStrides(c.shape)).buffer),F=new Uint8Array(new Int32Array(w.computeStrides(f)).buffer);return VC(y,ke[o.dtype],R,h,_,l.batchSize,F,N),e.disposeData(c.dataId),e.disposeData(m.dataId),d.shape=l.outputShape,d}var GC={kernelName:_a,backendName:"wasm",setupFunc:jL,kernelFunc:qL};var KL=!1,zC=we(gn,KL,"bool");var XL=!1,HC=we(xn,XL,"bool");var jC;function YL(r){jC=r.wasm.cwrap(No,null,["number","number","number"])}function JL(r){let{inputs:{x:e},attrs:{alpha:t},backend:n}=r,o=n.dataIdMap.get(e.dataId).id,s=n.makeOutput(e.shape,e.dtype);if(w.sizeFromShape(e.shape)!==0){let i=n.dataIdMap.get(s.dataId).id;jC(o,t,i)}return s}var qC={kernelName:No,backendName:"wasm",setupFunc:YL,kernelFunc:JL};var QL=!1,KC=we(_n,QL,"bool");var ZL=!1,XC=we(yn,ZL,"bool");var YC=me(bn);var eM=!1,JC=we(ya,eM,"bool");var QC;function tM(r){QC=r.wasm.cwrap(Eo,null,["number, number, number"])}function rM(r){let{backend:e,inputs:t,attrs:n}=r,{reductionIndices:o,keepDims:s}=n,{x:i}=t,u=e.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=ht(i,o,e);if(f){let _=e.dataIdMap.get(c.dataId).id;l=c,u=_}let d=l.shape.length;k.assertAxesAreInnerMostDims("max",p,d);let[h,g]=k.computeOutAndReduceShapes(l.shape,p),y=w.sizeFromShape(g),I=e.makeOutput(h,i.dtype);if(w.sizeFromShape(l.shape)!==0){let _=e.dataIdMap.get(I.dataId).id;QC(u,y,_)}if(f&&e.disposeData(c.dataId),s){let _=k.expandShapeToKeepDim(I.shape,m);I.shape=_}return I}var ZC={kernelName:Eo,backendName:"wasm",setupFunc:tM,kernelFunc:rM};var nM=!1,eT=we(wn,nM);var tT;function oM(r){tT=r.wasm.cwrap(Ao,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function sM(r){let{inputs:e,attrs:t,backend:n}=r,o=e.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=t,c=k.computePool2DInfo(o.shape,i,a,1,u,l),p=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,I=c.dilationWidth,_=c.strideHeight,N=c.strideWidth,R=c.inChannels,F=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let D=n.makeOutput(c.outShape,"float32"),O=n.dataIdMap.get(D.dataId).id;return tT(s,o.shape[0],o.shape[1],o.shape[2],p,m,f,d,h,g,y,I,_,N,R,F,O),D}var rT={kernelName:Ao,backendName:"wasm",setupFunc:oM,kernelFunc:sM};var nT;function aM(r){nT=r.wasm.cwrap(Ro,null,["number, number, number"])}function iM(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=t,a=e.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=ht(i,o,e),d=p;if(f){let N=e.dataIdMap.get(c.dataId).id;N!==a&&(l=c,u=N,d=k.getInnerMostAxes(d.length,l.shape.length))}k.assertAxesAreInnerMostDims("mean",d,l.shape.length);let[h,g]=k.computeOutAndReduceShapes(l.shape,d),y=w.sizeFromShape(g),I=l;l.dtype!=="float32"&&(I=Ss({backend:e,inputs:{x:l},attrs:{dtype:"float32"}}),u=e.dataIdMap.get(I.dataId).id);let _=e.makeOutput(h,"float32");if(w.sizeFromShape(l.shape)!==0){let N=e.dataIdMap.get(_.dataId).id;nT(u,y,N)}if(f&&e.disposeData(c.dataId),s){let N=k.expandShapeToKeepDim(_.shape,m);_.shape=N}return l.dtype!=="float32"&&e.disposeData(I.dataId),_}var oT={kernelName:Ro,backendName:"wasm",setupFunc:aM,kernelFunc:iM};var sT;function uM(r){sT=r.wasm.cwrap($o,null,["number, number, number"])}function lM(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=t,a=e.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=ht(i,o,e);if(f){let _=e.dataIdMap.get(c.dataId).id;_!==a&&(l=c,u=_)}let d=l.shape.length;k.assertAxesAreInnerMostDims("min",p,d);let[h,g]=k.computeOutAndReduceShapes(l.shape,p),y=w.sizeFromShape(g),I=e.makeOutput(h,l.dtype);if(w.sizeFromShape(l.shape)!==0){let _=e.dataIdMap.get(I.dataId).id;sT(u,y,_)}if(f&&e.disposeData(c.dataId),s){let _=k.expandShapeToKeepDim(I.shape,m);I.shape=_}return I}var aT={kernelName:$o,backendName:"wasm",setupFunc:uM,kernelFunc:lM};var cM=!1,iT=we(vn,cM);var Pg;(function(r){r[r.reflect=0]="reflect",r[r.symmetric=1]="symmetric"})(Pg||(Pg={}));var uT;function pM(r){uT=r.wasm.cwrap(Do,null,["number","array","number","number","array","array","number","number"])}function mM(r){let{inputs:{x:e},backend:t,attrs:{paddings:n,mode:o}}=r,s=n.map((d,h)=>d[0]+e.shape[h]+d[1]),i=t.dataIdMap.get(e.dataId).id,a=t.makeOutput(s,e.dtype),u=t.dataIdMap.get(a.dataId).id,l=new Uint8Array(new Int32Array(e.shape).buffer),c=n.map(d=>d[0]),p=n.map(d=>d[1]),m=new Uint8Array(new Int32Array(c).buffer),f=new Uint8Array(new Int32Array(p).buffer);return uT(i,l,e.shape.length,ke[e.dtype],m,f,Pg[o],u),a}var lT={kernelName:Do,backendName:"wasm",kernelFunc:mM,setupFunc:pM};var fM=!0,cT=we(In,fM);var pT=me(Oo);function ni(r,e){let t=new Int32Array(r.wasm.HEAPU8.buffer,e,4),n=t[0],o=t[1],s=t[2],i=t[3];return r.wasm._free(e),{pSelectedIndices:n,selectedSize:o,pSelectedScores:s,pValidOutputs:i}}var mT;function dM(r){mT=r.wasm.cwrap(Fo,"number",["number","number","number","number","number"])}function hM(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i}=n,{boxes:a,scores:u}=t,l=e.dataIdMap.get(a.dataId).id,c=e.dataIdMap.get(u.dataId).id,p=mT(l,c,s,o,i),{pSelectedIndices:m,selectedSize:f,pSelectedScores:d,pValidOutputs:h}=ni(e,p);return e.wasm._free(d),e.wasm._free(h),e.makeOutput([f],"int32",m)}var fT={kernelName:Fo,backendName:"wasm",setupFunc:dM,kernelFunc:hM};var dT;function gM(r){dT=r.wasm.cwrap(Po,"number",["number","number","number","number","number","bool"])}function xM(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:a}=n,{boxes:u,scores:l}=t,c=e.dataIdMap.get(u.dataId).id,p=e.dataIdMap.get(l.dataId).id,m=dT(c,p,s,o,i,a),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=ni(e,m);e.wasm._free(h);let y=e.makeOutput([d],"int32",f),I=e.makeOutput([],"int32",g);return[y,I]}var hT={kernelName:Po,backendName:"wasm",setupFunc:gM,kernelFunc:xM};var gT;function _M(r){gT=r.wasm.cwrap(Lo,"number",["number","number","number","number","number","number"])}function yM(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i,softNmsSigma:a}=n,{boxes:u,scores:l}=t,c=e.dataIdMap.get(u.dataId).id,p=e.dataIdMap.get(l.dataId).id,m=gT(c,p,s,o,i,a),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=ni(e,m);e.wasm._free(g);let y=e.makeOutput([d],"int32",f),I=e.makeOutput([d],"float32",h);return[y,I]}var xT={kernelName:Lo,backendName:"wasm",setupFunc:_M,kernelFunc:yM};var bM=!1,_T=we(Cn,bM,"bool");var yT;function wM(r){yT=r.wasm.cwrap(Mo,null,["number","number","number","number","number"])}function vM(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{depth:s,onValue:i,offValue:a}=n,u=t.makeOutput([...o.shape,s],"int32"),l=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(o.dataId).id;return yT(p,s,i,a,l),u}var bT={kernelName:Mo,backendName:"wasm",setupFunc:wM,kernelFunc:vM};function IM(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(1),n}var wT={kernelName:ba,backendName:"wasm",kernelFunc:IM};function CM(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return np({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,i=e[0].dtype;e.forEach(c=>{w.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=e.map(c=>{let p=np({inputs:{input:c},backend:t,attrs:{dim:o}});return a.push(p),p}),l=Dg({inputs:u,backend:t,attrs:{axis:o}});return a.forEach(c=>t.disposeData(c.dataId)),l}var vT={kernelName:wa,backendName:"wasm",kernelFunc:CM};var IT;function TM(r){IT=r.wasm.cwrap(Bo,null,["number","array","number","number","array","array","number","number"])}function SM(r){let{inputs:{x:e},backend:t,attrs:{paddings:n,constantValue:o}}=r,s=n.map((h,g)=>h[0]+e.shape[g]+h[1]);if(w.sizeFromShape(e.shape)===0)return Fg({backend:t,attrs:{shape:s,value:o,dtype:e.dtype}});let i=t.dataIdMap.get(e.dataId).id,a=t.makeOutput(s,e.dtype),l=t.dataIdMap.get(a.dataId).id,c=new Uint8Array(new Int32Array(e.shape).buffer),p=n.map(h=>h[0]),m=n.map(h=>h[1]),f=new Uint8Array(new Int32Array(p).buffer),d=new Uint8Array(new Int32Array(m).buffer);return IT(i,c,e.shape.length,ke[e.dtype],f,d,o,l),a}var op={kernelName:Bo,backendName:"wasm",kernelFunc:SM,setupFunc:TM};var kM=!1,CT=we(va,kM);var TT;function NM(r){TT=r.wasm.cwrap(Uo,null,["number","number","number"])}function EM(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=t.dataIdMap.get(n.dataId).id,i=t.dataIdMap.get(o.dataId).id,a=t.makeOutput(n.shape,"float32"),u=t.dataIdMap.get(a.dataId).id;return TT(s,i,u),a}var ST={kernelName:Uo,backendName:"wasm",setupFunc:NM,kernelFunc:EM};var kT;function AM(r){kT=r.wasm.cwrap(Tn,null,["number","number","number","number"])}function RM(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=t,a=e.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=ht(i,o,e),d=p;if(f){let _=e.dataIdMap.get(c.dataId).id;_!==a&&(l=c,u=_,d=k.getInnerMostAxes(d.length,l.shape.length))}k.assertAxesAreInnerMostDims("prod",d,l.shape.length);let[h,g]=k.computeOutAndReduceShapes(l.shape,d),y=w.sizeFromShape(g),I=e.makeOutput(h,l.dtype);if(w.sizeFromShape(l.shape)!==0){let _=e.dataIdMap.get(I.dataId).id;kT(u,y,ke[I.dtype],_)}if(f&&e.disposeData(c.dataId),s){let _=k.expandShapeToKeepDim(I.shape,m);I.shape=_}return I}var NT={kernelName:Tn,backendName:"wasm",setupFunc:AM,kernelFunc:RM};var $M=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:i}=t,a=gu(n,o,s,i),u=e.makeOutput([a.length],i);return e.typedArrayFromHeap(u).set(a),u},ET={kernelName:Ia,backendName:"wasm",kernelFunc:$M};var DM=!0,AT=we(ma,DM);var RT=me(Ca);var $T=me(Sa);var DT;function OM(r){DT=r.wasm.cwrap(Wo,null,["number","number","number","number","number","number","number","number","number","number"])}function FM(r){let{backend:e,inputs:t,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,[c,p,m,f]=o.shape,d=[c,u,l,f],h=e.dataIdMap.get(o.dataId),g;h.dtype!=="float32"&&(g=Ss({backend:e,inputs:{x:o},attrs:{dtype:"float32"}}),h=e.dataIdMap.get(g.dataId));let y=h.id,I=e.makeOutput(d,"float32");if(w.sizeFromShape(o.shape)===0)return I;let _=e.dataIdMap.get(I.dataId).id;return DT(y,c,p,m,f,u,l,s?1:0,i?1:0,_),g!=null&&e.disposeData(g.dataId),I}var OT={kernelName:Wo,backendName:"wasm",setupFunc:OM,kernelFunc:FM};var FT;function PM(r){FT=r.wasm.cwrap(Vo,null,["number","array","number","array","number","number"])}function LM(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,i=w.parseAxisParam(s,o.shape);if(o.shape.length===0)return Ts({inputs:{x:o},backend:t});let a=t.makeOutput(o.shape,o.dtype),u=t.dataIdMap.get(o.dataId).id,l=t.dataIdMap.get(a.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),p=new Uint8Array(new Int32Array(o.shape).buffer);FT(u,c,i.length,p,o.shape.length,l);let m=Ge({inputs:{x:a},attrs:{shape:o.shape},backend:t});return t.disposeData(a.dataId),m}var PT={kernelName:Vo,backendName:"wasm",kernelFunc:LM,setupFunc:PM};var LT;function MM(r){LT=r.wasm.cwrap(Qo,null,["number","number","number","number","number","number","number","number","array","number","number"])}function BM(r){let{inputs:e,backend:t,attrs:n}=r,{image:o}=e,{radians:s,fillValue:i,center:a}=n,u=t.makeOutput(o.shape,o.dtype),l=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(u.dataId).id,[p,m,f,d]=o.shape,[h,g]=k.getImageCenter(a,m,f),y=i===0,I=255,_=typeof i=="number"?[i,i,i,y?0:I]:[...i,I],N=new Uint8Array(new Int32Array(_).buffer);return LT(l,p,m,f,d,s,h,g,N,_.length,c),u}var MT={kernelName:Qo,backendName:"wasm",kernelFunc:BM,setupFunc:MM};var BT=me(ka);var UT=me(Sn);var WT;function UM(r){WT=r.wasm.cwrap(Go,null,["number","number","number","number","number","number","array","number","number"])}function WM(r){let{backend:e,inputs:t,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,a=e.makeOutput(i,s.dtype);if(w.sizeFromShape(i)===0)return a;let{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:m}=Lc.calculateShapes(s,o,i),d=e.dataIdMap.get(o.dataId).id,g=e.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(p).buffer),I=e.dataIdMap.get(a.dataId).id;return WT(d,g,ke[s.dtype],u,l,c,y,m,I),a}var VT={kernelName:Go,backendName:"wasm",setupFunc:UM,kernelFunc:WM};var GT;function VM(r){GT=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function GM(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,i=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(s.dataId).id,l=t.makeOutput(o.shape,o.dtype),c=t.dataIdMap.get(l.dataId).id,p=n.shape.length,m=o.shape.length,f=p===0||p>1||m===1?1:w.sizeFromShape(o.shape.slice(1));return GT(i,a,u,f,c),l}var zT={kernelName:Na,backendName:"wasm",kernelFunc:GM,setupFunc:VM};var HT;function zM(r){HT=r.wasm.cwrap(kn,null,["number","number"])}function HM(r){let{backend:e,inputs:{x:t}}=r,n=e.dataIdMap.get(t.dataId).id,o=e.makeOutput(t.shape,t.dtype),s=e.dataIdMap.get(o.dataId).id;return w.sizeFromShape(o.shape)===0||HT(n,s),o}var jT={kernelName:"Sigmoid",backendName:"wasm",setupFunc:zM,kernelFunc:HM};var qT=me(Ea);var KT;function jM(r){KT=r.wasm.cwrap(jo,null,["number","number","number","number"])}function qM(r){let{backend:e,inputs:{logits:t},attrs:{dim:n}}=r,o=e.dataIdMap.get(t.dataId).id,s=e.makeOutput(t.shape,t.dtype),i=e.dataIdMap.get(s.dataId).id,a=t.shape[n],u=w.sizeFromShape(t.shape)/a;return w.sizeFromShape(s.shape)===0||KT(o,i,a,u),s}var XT={kernelName:jo,backendName:"wasm",setupFunc:jM,kernelFunc:qM};function KM(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:i}=n,a=w.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let F=1+s.length;F<o.shape.length;++F)u.push([0,0]);let l=op.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),c=k.getReshaped(l.shape,s,a,!1),p=k.getPermuted(c.length,s.length,!1),m=k.getReshapedPermuted(l.shape,s,a,!1),h=Ge({inputs:{x:l},backend:t,attrs:{shape:c}}),I=vr({inputs:{x:h},backend:t,attrs:{perm:p}}),R=Ge({inputs:{x:I},backend:t,attrs:{shape:m}});return t.disposeData(l.dataId),t.disposeData(h.dataId),t.disposeData(I.dataId),R}var YT={kernelName:Aa,backendName:"wasm",kernelFunc:KM};function XM(r){let{inputs:e,attrs:t,backend:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:i}=t,a=w.parseAxisParam(i,o.shape)[0],u=k.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),c=o.shape.slice();return u.map(p=>{let m=[...c];m[a]=p;let f=Hr({inputs:{x:o},attrs:{begin:l,size:m},backend:n});return l[a]+=p,f})}var JT={kernelName:Ra,backendName:"wasm",kernelFunc:XM};var QT=me(Nn);var ZT=me(xc);var YM=!0,e0=we(En,YM);var t0;function JM(r){t0=r.wasm.cwrap(Jo,null,["number","number","number"])}function QM(r){let{backend:e,inputs:t,attrs:n}=r,{alpha:o}=n,{x:s}=t,i=e.dataIdMap.get(s.dataId).id,a=e.makeOutput(s.shape,s.dtype),u=e.dataIdMap.get(a.dataId).id;return t0(i,o,u),a}var r0={kernelName:Jo,backendName:"wasm",setupFunc:JM,kernelFunc:QM};var n0;function ZM(r){n0=r.wasm.cwrap(qo,null,["number","array","number","array","array","array","array","array","number","number"])}function eB(r){let{backend:e,inputs:t,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a}=n;a==null&&(a=new Array(s.length));let{beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n,f=k.slice_util.maskToAxes(c);if(f.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(c!==0&&p!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(c!==0&&m!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let d=o.shape.length-s.length,h=k.slice_util.maskToAxes(p),g=o.shape.slice();h.forEach(G=>{s[G]=0,i[G]=1,g.splice(G,0,1)});let y=Ge({inputs:{x:o},attrs:{shape:g},backend:e}),{begin:I,end:_,strides:N}=k.slice_util.getNormalizedAxes(y.shape,f,d,s,i,a,u,l,c);s=I,i=_,a=N;let R=k.slice_util.maskToAxes(m);R.forEach(G=>{i[G]=s[G]+1,a[G]=1});let F=k.slice_util.computeOutShape(s,i,a),D=F.filter((G,j)=>R.indexOf(j)===-1);if(a.every(G=>G===1)){let G=Hr({inputs:{x:y},attrs:{begin:s,size:F},backend:e});e.disposeData(y.dataId);let j=Ge({inputs:{x:G},attrs:{shape:D},backend:e});return e.disposeData(G.dataId),j}let U=e.makeOutput(D,"float32");if(!D.some(G=>G===0)){let G=e.dataIdMap.get(y.dataId).id,j=new Uint8Array(new Int32Array(w.computeStrides(y.shape)).buffer),ee=new Uint8Array(new Int32Array(s).buffer),Q=new Uint8Array(new Int32Array(i).buffer),ie=new Uint8Array(new Int32Array(a).buffer),le=new Uint8Array(new Int32Array(D).buffer),Ce=new Uint8Array(new Int32Array(w.computeStrides(D)).buffer),de=e.dataIdMap.get(U.dataId).id;n0(G,j,y.shape.length,ee,Q,ie,le,Ce,D.length,de)}e.disposeData(y.dataId);let M=Ge({inputs:{x:U},attrs:{shape:D},backend:e});return e.disposeData(U.dataId),M}var o0={kernelName:qo,backendName:"wasm",setupFunc:ZM,kernelFunc:eB};var tB=!0,s0=we(An,tB);var a0;function rB(r){a0=r.wasm.cwrap(Ho,null,["number, number, number"])}function nB(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=t,a=e.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=ht(i,o,e),d=p;if(f){let _=e.dataIdMap.get(c.dataId).id;_!==a&&(l=c,u=_,d=k.getInnerMostAxes(d.length,l.shape.length))}k.assertAxesAreInnerMostDims("sum",d,l.shape.length);let[h,g]=k.computeOutAndReduceShapes(l.shape,d),y=w.sizeFromShape(g),I=e.makeOutput(h,l.dtype);if(w.sizeFromShape(l.shape)!==0){let _=e.dataIdMap.get(I.dataId).id;a0(u,y,_)}if(f&&e.disposeData(c.dataId),s){let _=k.expandShapeToKeepDim(I.shape,m);I.shape=_}return I}var i0={kernelName:Ho,backendName:"wasm",setupFunc:rB,kernelFunc:nB};var u0=me($a);var l0=me(Da);var c0;function oB(r){c0=r.wasm.cwrap(Ur,null,["number","array","number","array","number","number"])}function sB(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,s=t.dataIdMap.get(o.dataId).id,{reps:i}=n,a=new Array(o.shape.length);for(let m=0;m<a.length;m++)a[m]=o.shape[m]*i[m];let u=new Uint8Array(new Int32Array(o.shape).buffer),l=new Uint8Array(new Int32Array(a).buffer),c=t.makeOutput(a,o.dtype),p=t.dataIdMap.get(c.dataId).id;return c0(s,u,o.shape.length,l,a.length,ke[c.dtype],p),c}var p0={kernelName:Ur,backendName:"wasm",setupFunc:oB,kernelFunc:sB};var m0;function aB(r){m0=r.wasm.cwrap(Ko,null,["number","array","number","number","number","bool","number","number"])}var iB=({inputs:r,backend:e,attrs:t})=>{let{x:n}=r,{k:o,sorted:s}=t,i=e.dataIdMap.get(n.dataId).id,a=new Uint8Array(new Int32Array(n.shape).buffer),u=n.shape.slice();u[u.length-1]=o;let l=e.makeOutput(u,n.dtype),c=e.dataIdMap.get(l.dataId).id,p=e.makeOutput(u,"int32"),m=e.dataIdMap.get(p.dataId).id;return m0(i,a,n.shape.length,ke[n.dtype],o,s,c,m),[l,p]},f0={kernelName:Ko,backendName:"wasm",setupFunc:aB,kernelFunc:iB};var d0;function uB(r){d0=r.wasm.cwrap(Xo,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])}function lB(r){let{backend:e,inputs:t,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,p,m,f]=o.shape,[d,h]=l??[p,m],g=[c,d,h,f],y=new Uint8Array(new Int32Array(w.computeStrides(o.shape)).buffer),I=e.makeOutput(g,o.dtype),_=e.dataIdMap.get(I.dataId).id,R=e.dataIdMap.get(o.dataId).id,D=e.dataIdMap.get(s.dataId).id,O=i==="nearest"?1:2,U;switch(a){case"constant":U=1;break;case"reflect":U=2;break;case"wrap":U=3;break;case"nearest":U=4;break;default:U=1;break}return d0(R,D,s.shape[0]>1,c,d,h,f,m,p,y,o.shape.length-1,O,U,u,_),I}var h0={kernelName:Xo,backendName:"wasm",setupFunc:uB,kernelFunc:lB};function cB(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape[s],a=o.shape.length,u=new Array(a-1),l=0;for(let f=0;f<a;f++)f!==s&&(u[l++]=o.shape[f]);let c=new Array(i),p=new Array(a).fill(0),m=o.shape.slice();m[s]=1;for(let f=0;f<c.length;f++)p[s]=f,c[f]=Hr({inputs:{x:o},attrs:{begin:p,size:m},backend:t});return c.map(({dataId:f,dtype:d})=>({dataId:f,dtype:d,shape:u}))}var g0={kernelName:Oa,backendName:"wasm",kernelFunc:cB};function pB(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(0),n}var x0={kernelName:Fa,backendName:"wasm",kernelFunc:pB};var mB=[hI,gI,_I,II,TI,kI,EI,$I,sC,aC,iC,lC,cC,mC,dC,hC,gC,_C,bC,vC,CC,TC,SC,kC,NC,EC,RC,$C,DC,dI,FC,LC,BC,WC,GC,zC,HC,yI,qC,KC,XC,YC,JC,ZC,eT,rT,oT,aT,iT,lT,cT,pT,fT,hT,xT,_T,bT,wT,vT,op,CT,ST,NT,ET,AT,RT,$T,AI,OT,PT,MT,UT,BT,VT,zT,jT,qT,oC,XT,YT,JT,QT,ZT,e0,r0,o0,s0,i0,u0,l0,p0,f0,h0,wI,g0,x0];for(let r of mB)Ic(r);var Lg=$();Lg.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])));Lg.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(Lg.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(r){return!1}});var Vg=gl(b0());var w0='var Module={};function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;this.alert=threadAlert;Module["instantiateWasm"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module["wasmModule"],info);Module["wasmModule"]=null;receiveInstance(instance);return instance.exports};function moduleLoaded(){}this.onmessage=function(e){try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance;moduleLoaded()})}else if(e.data.cmd==="objectTransfer"){Module["PThread"].receiveObjectTransfer(e.data)}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0);var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module["establishStackSpace"](top,max);Module["_emscripten_tls_init"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].setThreadStatus(Module["_pthread_self"](),1);try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(!Module["getNoExitRuntime"]())Module["PThread"].threadExit(result)}catch(ex){if(ex==="Canceled!"){Module["PThread"].threadCancel()}else if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["getNoExitRuntime"]()){}else{Module["PThread"].threadExit(ex.status)}}else{Module["PThread"].threadExit(-2);throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["PThread"].threadCancel()}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);throw ex}};if(typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string"){self={location:{href:__filename}};var onmessage=this.onmessage;var nodeWorkerThreads=require("worker_threads");global.Worker=nodeWorkerThreads.Worker;var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var nodeFS=require("fs");var nodeRead=function(filename){return nodeFS.readFileSync(filename,"utf8")};function globalEval(x){global.require=require;global.Module=Module;eval.call(null,x)}importScripts=function(f){globalEval(nodeRead(f))};postMessage=function(msg){parentPort.postMessage(msg)};if(typeof performance==="undefined"){performance={now:function(){return Date.now()}}}}';var I0=gl(v0());var up=class extends cn{constructor(e){super();this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.init(),this.dataIdMap=new ra(this,Bn())}write(e,t,n){let o={id:this.dataIdNextNumber++};return this.move(o,e,t,n,1),o}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=w.now();return e(),{kernelMs:w.now()-t}}move(e,t,n,o,s){let i=this.dataIdNextNumber++;if(o==="string"){let c=t;this.dataIdMap.set(e,{id:i,stringBytes:c,shape:n,dtype:o,memoryOffset:null,refCount:s});return}let a=w.sizeFromShape(n),u=a*w.bytesPerElement(o),l=this.wasm._malloc(u);this.dataIdMap.set(e,{id:i,memoryOffset:l,shape:n,dtype:o,refCount:s}),this.wasm.tfjs.registerTensor(i,a,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),l)}async read(e){return this.readSync(e)}readSync(e){let{memoryOffset:t,dtype:n,shape:o,stringBytes:s}=this.dataIdMap.get(e);if(n==="string")return s;let i=this.wasm.HEAPU8.slice(t,t+w.sizeFromShape(o)*w.bytesPerElement(n));return fB(i.buffer,n)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let o;if(n==null)o=this.write(null,e,t);else{let s=this.dataIdNextNumber++;o={id:s},this.dataIdMap.set(o,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=w.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:o,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let o=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),i=w.sizeFromShape(e);switch(t){case"float32":return new Float32Array(o,s,i);case"int32":return new Int32Array(o,s,i);case"bool":return new Uint8Array(o,s,i);default:throw new Error(`Unknown dtype ${t}`)}}};function dB(r){return(e,t)=>(w.fetch(r,{credentials:"same-origin"}).then(n=>{n.ok||e.env.a(`failed to load wasm binary file at '${r}'`),n.arrayBuffer().then(o=>{WebAssembly.instantiate(o,e).then(s=>{t(s.instance,s.module)})})}),{})}function C0(r,e,t){if(Gg!=null)return Gg;let n="tfjs-backend-wasm.wasm";return r&&e?n="tfjs-backend-wasm-threaded-simd.wasm":r&&(n="tfjs-backend-wasm-simd.wasm"),_u!=null&&_u[n]!=null?_u[n]:t+n}async function S0(){let[r,e]=await Promise.all([$().getAsync("WASM_HAS_SIMD_SUPPORT"),$().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((t,n)=>{let o={};o.locateFile=(a,u)=>{if(a.endsWith(".worker.js")){let l=w0,c=new Blob([l],{type:"application/javascript"});return URL.createObjectURL(c)}return a.endsWith(".wasm")?C0(r,e,yu??u):u+a},T0&&(o.instantiateWasm=dB(C0(r,e,yu??"")));let s=!1;o.onAbort=()=>{if(s||lp)return;lp=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let i;e&&r&&Gg==null?(o.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+Vg.default.toString()],{type:"text/javascript"}),i=(0,Vg.default)(o)):i=(0,I0.default)(o),i.then(a=>{s=!0,lp=!1;let u=null;a.tfjs={init:a.cwrap("init",null,[]),registerTensor:a.cwrap("register_tensor",null,["number","number","number"]),disposeData:a.cwrap("dispose_data",u,["number"]),dispose:a.cwrap("dispose",u,[])},t({wasm:a})})})}function fB(r,e){switch(e){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${e}`)}}var hB=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Gg=null,yu=null,_u={},lp=!1,T0=!1;function zg(r,e=!1){if(lp)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")yu=r;else{_u=r;let t=hB.filter(n=>_u[n]==null);if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}T0=e}var gB=2;qa("wasm",async()=>{let{wasm:r}=await S0();return new up(r)},gB);var Hg=!1,k0=null;async function N0(r,e){let t=await Jy();Hg||zg(t.WASM_URL+"/",!0);let n=e||(()=>jg.FetchBestBinary());if(!Hg||Un()!=="wasm"){k0||(k0=await n());let o=$().platform.fetch,s=async i=>{let a=await n();return new Response(a,{status:200})};$().platform.fetch=s,console.log("Setting up wasm backend."),await Uc("wasm"),$().platform.fetch=o}Hg=!0}var E0=class{constructor(){}async FetchBestBinary(){return Yt()&&console.warn("Should not happen"),this.fetchPromise_?this.fetchPromise_:this.fetchPromise_=new Promise(async(e,t)=>{try{let n=await this.GetBestBinaryName_(),o=Xe().WASM_URL+"/"+n,i=await(await fetch(o)).blob();e(i)}catch(n){t(n)}})}async GetBestBinaryName_(){let[e,t]=await Promise.all([this.IsSimdAvailable_(),this.IsWasmMultiThreadingAvailable_]);return e&&t?"tfjs-backend-wasm-threaded-simd.wasm":e?"tfjs-backend-wasm-simd.wasm":"tfjs-backend-wasm.wasm"}async IsSimdAvailable_(){if(typeof this.wasmSimdAvailable_=="boolean")return this.wasmSimdAvailable_;let e=await $().getAsync("WASM_HAS_SIMD_SUPPORT");return this.wasmSimdAvailable_=e,this.wasmSimdAvailable_}async IsWasmMultiThreadingAvailable_(){if(typeof this.wasmThreadsAvailable_=="boolean")return this.wasmThreadsAvailable_;let e=await $().getAsync("WASM_HAS_MULTITHREAD_SUPPORT");return this.wasmThreadsAvailable_=e,this.wasmThreadsAvailable_}},jg=new E0;var ks={},qg={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function A0(r,e){ks[r]=e}function Mt(r){if(!(r in ks)){let t=xB(r);if(t!==null)ks[r]=t;else return console.log("Could not get context for WebGL version",r),null}let e=ks[r];return e.isContextLost()?(delete ks[r],Mt(r)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),ks[r])}function _B(r){if(typeof OffscreenCanvas!="undefined"&&r===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function xB(r){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=_B(r);return e.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete ks[r]},!1),r===1?e.getContext("webgl",qg)||e.getContext("experimental-webgl",qg):e.getContext("webgl2",qg)}var jn;(function(r){r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH"})(jn||(jn={}));var at;(function(r){r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD"})(at||(at={}));var tt;(function(r){r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(tt||(tt={}));function Ns(r,e){return[e,r]}function R0(r,e){return r*e}function bu(r){let e=w.sizeFromShape(r),t=Math.ceil(e/4);return w.sizeToSquarishShape(t)}function Ir(r,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(r/2))]}function $0(r,e){let[t,n]=Ir(r,e);return t*n*4}function wu(r,e){let t=r,n,o,s,i,a,u,l,c,p,m;return $().getNumber("WEBGL_VERSION")===2?(n=t.R32F,o=t.R16F,s=t.RGBA16F,i=t.RGBA32F,a=t.RED,l=4,c=1,p=t.HALF_FLOAT,m=t.FLOAT):(n=r.RGBA,o=r.RGBA,s=r.RGBA,i=t.RGBA,a=r.RGBA,l=4,c=4,p=e!=null?e.HALF_FLOAT_OES:null,m=r.FLOAT),u=r.RGBA,{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:m}}function Z(r,e){let t=e();return $().getBool("DEBUG")&&yB(r),t}function yB(r){let e=r.getError();if(e!==r.NO_ERROR)throw new Error("WebGL Error: "+bB(r,e))}var wB=596e-10,vB=65504;function D0(r){return!!($().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||wB<Math.abs(r)&&Math.abs(r)<vB)}function bB(r,e){switch(e){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function vu(r,e){return jr(r,()=>r.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function O0(r,e){let t=jr(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Z(r,()=>r.shaderSource(t,e)),Z(r,()=>r.compileShader(t)),r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function F0(r,e){let t=jr(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Z(r,()=>r.shaderSource(t,e)),Z(r,()=>r.compileShader(t)),r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw IB(e,r.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}var CB=/ERROR: [0-9]+:([0-9]+):/g;function IB(r,e){let t=CB.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(r);return}let n=+t[1],o=r.split(`
`),s=o.length.toString().length+2,i=o.map((p,m)=>w.rightPad((m+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let u=i.slice(0,n-1),l=i.slice(n-1,n),c=i.slice(n);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${w.rightPad(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function P0(r){return jr(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function L0(r,e){if(Z(r,()=>r.linkProgram(e)),r.getProgramParameter(e,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function cp(r,e){if(Z(r,()=>r.validateProgram(e)),r.getProgramParameter(e,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function M0(r,e){let t=jr(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Z(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),Z(r,()=>r.bufferData(r.ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function B0(r,e){let t=jr(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Z(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,t)),Z(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function U0(r){return jr(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function W0(r,e){let t=$().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||e<=0){let n=`[${r}x${e}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>t||e>t){let n=`[${r}x${e}]`,o=`[${t}x${t}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function V0(r){return jr(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Kg(r,e,t,n,o,s,i){let a=r.getAttribLocation(e,t);return a===-1?!1:(Z(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),Z(r,()=>r.vertexAttribPointer(a,o,r.FLOAT,!1,s,i)),Z(r,()=>r.enableVertexAttribArray(a)),!0)}function SB(r,e,t){TB(r,t),Z(r,()=>r.activeTexture(r.TEXTURE0+t)),Z(r,()=>r.bindTexture(r.TEXTURE_2D,e))}function G0(r,e,t){return jr(r,()=>r.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function z0(r,e,t){return r.getUniformLocation(e,t)}function H0(r,e,t,n){Z(r,()=>SB(r,e,n)),Z(r,()=>r.uniform1i(t,n))}function pp(r,e,t){Z(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),Z(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0))}function Xg(r,e){Z(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),Z(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function Iu(r){let e=r.checkFramebufferStatus(r.FRAMEBUFFER);if(e!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+kB(r,e))}function kB(r,e){switch(e){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function jr(r,e,t){let n=Z(r,()=>e());if(n==null)throw new Error(t);return n}function TB(r,e){let t=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=e+r.TEXTURE0;if(n<r.TEXTURE0||n>t){let o=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${o}.`)}}function qn(r,e=2){return w.sizeFromShape(r.slice(0,r.length-e))}function Kn(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function mp(r){let e=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(e=[qn(r),...Kn(r)]),e}function j0(r,e=!1){let t=$().getNumber("WEBGL_MAX_TEXTURE_SIZE");e&&(t=t*2,r=r.map((o,s)=>s>=r.length-2?w.nearestLargerEven(r[s]):r[s]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=w.squeezeShape(r).newShape);let n=w.sizeFromShape(r);if(r.length<=1&&n<=t)return[1,n];if(r.length===2&&r[0]<=t&&r[1]<=t)return r;if(r.length===3&&r[0]*r[1]<=t&&r[2]<=t)return[r[0]*r[1],r[2]];if(r.length===3&&r[0]<=t&&r[1]*r[2]<=t)return[r[0],r[1]*r[2]];if(r.length===4&&r[0]*r[1]*r[2]<=t&&r[3]<=t)return[r[0]*r[1]*r[2],r[3]];if(r.length===4&&r[0]<=t&&r[1]*r[2]*r[3]<=t)return[r[0],r[1]*r[2]*r[3]];if(e){let o=qn(r),s=2,i=2;return r.length&&([s,i]=Kn(r)),n=o*(s/2)*(i/2),w.sizeToSquarishShape(n).map(a=>a*2)}return w.sizeToSquarishShape(n)}function fp(r){return r%2==0}function Es(r,e){if(r=r.slice(-2),e=e.slice(-2),w.arraysEqual(r,e)||!r.length||!e.length||r[0]===0||r[1]===0||e[0]===0||e[1]===0)return!0;if(r.length!==e.length){let t=r.slice(-1)[0],n=e.slice(-1)[0];if(t===n||fp(t)&&fp(n)&&(r[0]===1||e[0]===1))return!0}return r[1]===e[1]&&fp(r[0])&&fp(e[0])}var Yg,Jg;function q0(r){if(Yg==null){let e=Mt(r);Yg=e.getParameter(e.MAX_TEXTURE_SIZE)}return Yg}function K0(r){if(Jg==null){let e=Mt(r);Jg=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Jg)}function X0(r){if(r===0)return 0;let e,t=Mt(r);return Bt(t,"EXT_disjoint_timer_query_webgl2")&&r===2?e=2:Bt(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Bt(r,e){return r.getExtension(e)!=null}function Qg(r){try{if(Mt(r)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Y0(r){if(r===0)return!1;let e=Mt(r);if(r===1){if(!Bt(e,"OES_texture_float"))return!1}else if(!Bt(e,"EXT_color_buffer_float"))return!1;return Zg(e)}function J0(r){if(r===0)return!1;let e=Mt(r);if(r===1){if(!Bt(e,"OES_texture_float")||!Bt(e,"WEBGL_color_buffer_float"))return!1}else{if(Bt(e,"EXT_color_buffer_float"))return Zg(e);let n="EXT_color_buffer_half_float";if(Bt(e,n)){let o=e.getExtension(n);return NB(e,o)}return!1}return Zg(e)}function Zg(r){let e=wu(r),t=r.createTexture();r.bindTexture(r.TEXTURE_2D,t);let n=1,o=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatFloat,n,o,0,e.textureFormatFloat,e.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(t),r.deleteFramebuffer(s),i}function NB(r,e){let t=wu(r,e),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n);let o=1,s=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatHalfFloat,o,s,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);let i=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,i),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(i),a}function Q0(r){return r!==2?!1:Mt(r).fenceSync!=null}function Cr(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&w.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}var re=$();re.registerFlag("HAS_WEBGL",()=>re.getNumber("WEBGL_VERSION")>0);re.registerFlag("WEBGL_VERSION",()=>Qg(2)?2:Qg(1)?1:0);re.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);re.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>re.get("WEBGL_VERSION")===2);re.registerFlag("WEBGL_CPU_FORWARD",()=>!0);re.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);re.registerFlag("WEBGL_PACK",()=>re.getBool("HAS_WEBGL"));re.registerFlag("WEBGL_PACK_NORMALIZATION",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_CLIP",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_REDUCE",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_LAZILY_UNPACK",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_CONV_IM2COL",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>q0(re.getNumber("WEBGL_VERSION")));re.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>K0(re.getNumber("WEBGL_VERSION")));re.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=re.getNumber("WEBGL_VERSION");return r===0?0:X0(r)});re.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>re.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!is.isMobile());re.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Y0(re.getNumber("WEBGL_VERSION")));re.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>re.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:re.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));re.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>J0(re.getNumber("WEBGL_VERSION")));re.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Q0(re.getNumber("WEBGL_VERSION")));re.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>re.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);re.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});re.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>is.isMobile()&&re.getBool("IS_CHROME")?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});re.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);re.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);re.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);re.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);function Ae(){let r,e,t,n,o,s,i,a,u,l;return $().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",e="in",t="out",n="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",e="attribute",t="varying",n="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:e,varyingVs:t,varyingFs:n,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}function nr(r,e,t="index"){let n=w.computeStrides(e);return n.map((o,s)=>{let i=`int ${r[s]} = ${t} / ${o}`,a=s===n.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${i}; ${a};`}).join("")}function As(r,e,t="index"){let n=w.computeStrides(e);return n.map((o,s)=>{let i=`int ${r[s]} = ${t} / outShapeStrides[${s}]`,a=s===n.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function EB(r,e){let t=r.length,n=r.map(s=>`${e}[${s}]`),o=new Array(t-1);o[t-2]=n[t-1];for(let s=t-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function Z0(r,e,t="index"){let n=r.map((s,i)=>i),o=EB(n,e);return o.map((s,i)=>{let a=`int ${r[i]} = ${t} / ${o[i]}`,u=i===o.length-1?`int ${r[i+1]} = ${t} - ${r[i]} * ${o[i]}`:`index -= ${r[i]} * ${o[i]}`;return`${a}; ${u};`}).join("")}function si(r){let e=w.computeStrides(r).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function ai(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var dp=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:eS}=k;function tS(r,e,t){let n=[];if(r.forEach(f=>{let d=w.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?n.push(`uniform float ${f.name}${d>1?`[${d}]`:""};`):(n.push(`uniform sampler2D ${f.name};`),n.push(`uniform int offset${f.name};`)),t.enableShapeUniforms){let{uniformShape:h}=hp(t.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(h.length){case 1:n.push(`uniform int ${f.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}n.push(`uniform ivec2 ${f.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break;default:break}n.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(f=>{n.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let o=n.join(`
`),s=r.map(f=>AB(f,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),i=e.texShape,a=Ae(),u=DB(a),l,c,p=PB(a);return e.isPacked?(l=RB(e.logicalShape,i,t.enableShapeUniforms),c=FB(a)):(l=$B(e.logicalShape,i,t.enableShapeUniforms),c=OB(a)),t.packedInputs&&(p+=LB),[p,u,c,o,l,s,t.userCode].join(`
`)}function ii(r,e=!1){let t=r.shapeInfo.logicalShape;switch(t.length){case 0:return MB(r,e);case 1:return BB(r,e);case 2:return UB(r,e);case 3:return WB(r,e);case 4:return VB(r,e);case 5:return GB(r);case 6:return zB(r);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function rS(r,e){switch(r.shapeInfo.logicalShape.length){case 0:return HB(r);case 1:return jB(r,e);case 2:return qB(r,e);case 3:return KB(r,e);default:return XB(r,e)}}function AB(r,e,t=!1,n){let o="";t?o+=rS(r,n):o+=ii(r,n);let s=r.shapeInfo.logicalShape,i=e.logicalShape;return s.length<=i.length&&(t?o+=YB(r,e):o+=JB(r,e)),o}function RB(r,e,t){switch(r.length){case 0:return nS();case 1:return QB(r,e,t);case 2:return t3(r,e,t);case 3:return ZB(r,e,t);default:return e3(r,e,t)}}function $B(r,e,t){switch(r.length){case 0:return nS();case 1:return r3(r,e,t);case 2:return i3(r,e,t);case 3:return n3(r,e,t);case 4:return o3(r,e,t);case 5:return s3(r,e);case 6:return a3(r,e);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function DB(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function OB(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function FB(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function PB(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${u3}
    ${l3}
    ${c3}
  `}var u3=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,l3=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,c3=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,LB=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function nS(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function QB(r,e,t){let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return n[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function r3(r,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function ZB(r,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(r[2]/2),s=o*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function n3(r,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${As(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let n=nr(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function e3(r,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(r[r.length-1]/2),s=o*Math.ceil(r[r.length-2]/2),i=s,a="",u="b, r, c";for(let l=2;l<r.length-1;l++)i*=r[r.length-l-1],a=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+a,u=`b${l}, `+u;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${r.length}(${u});
    }
  `}function o3(r,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${As(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let n=nr(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function s3(r,e){let t=nr(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function a3(r,e){let t=nr(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function t3(r,e,t){let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(w.arraysEqual(r,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let o=Math.ceil(r[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function i3(r,e,t){return w.arraysEqual(r,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:r[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Rs(r){return`offset${r}`}function HB(r){let e=r.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),n=Ae();return`
    vec4 ${t}() {
      return ${n.texture2D}(${e}, halfCR);
    }
  `}function MB(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;let[o,s]=r.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${t}, halfCR);
      }
    `;let i=Rs(t);if(e)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${i});
      return sampleTexture(${t}, uv);
    }
  `;let[a,u]=r.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${i});
      return sampleTexture(${t}, uv);
    }
  `}function jB(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=r.shapeInfo.texShape,s=Ae();if(e)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function BB(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${ui(r)}
      }
    `;let o=r.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;let a=Rs(t);return i===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function qB(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=s[0],a=s[1],u=Ae();if(s!=null&&w.arraysEqual(t,s))return e?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(e)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function UB(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape;if(s!=null&&w.arraysEqual(t,s)){if(e)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let m=s[0],f=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${m}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:i,keptDims:a}=w.squeezeShape(t),u=i;if(u.length<t.length){let m=li(r,u),f=["row","col"];return`
      ${ii(m,e)}
      float ${o}(int row, int col) {
        return ${o}(${ci(f,a)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${ui(r)}
      }
    `;let l=s[0],c=s[1],p=Rs(n);return c===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${n}, uv);
    }
  `:l===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:e?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${p};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${n}, uv);
  }
`}function KB(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){let m=t.slice(1),f=[1,2],d=li(r,m),h=["b","row","col"];return`
        ${rS(d,e)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${ci(h,f)});
        }
      `}let a=Ae();if(e)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `;let u=i[0],l=i[1],c=Math.ceil(t[2]/2),p=c*Math.ceil(t[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${p}, ${c}, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `}function WB(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[1]*t[2],i=t[2],{newShape:a,keptDims:u}=w.squeezeShape(t),l=a;if(l.length<t.length){let h=li(r,l),g=["row","col","depth"];return`
        ${ii(h,e)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${ci(g,u)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${ui(r)}
      }
    `;let c=r.shapeInfo.texShape,p=c[0],m=c[1],f=r.shapeInfo.flatOffset;if(m===s&&f==null)return e?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(m===i&&f==null)return e?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${n}, uv);
    }
  `;let d=Rs(n);return e?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * ${s} + col * ${i} + depth + ${d};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${d};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${n}, uv);
      }
  `}function XB(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=Ae();if(e)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${t}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,i=s.length,a=r.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=u[0],c=u[1],p=Math.ceil(s[i-1]/2),m=p*Math.ceil(s[i-2]/2),f="int b, int row, int col",d=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let h=2;h<i-1;h++)f=`int b${h}, `+f,m*=s[i-h-1],d=`b${h} * ${m} + `+d;return`
    vec4 ${n}(${f}) {
      int index = ${d};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${o.texture2D}(${t}, uv);
    }
  `}function VB(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[3],i=t[2]*s,a=t[1]*i,{newShape:u,keptDims:l}=w.squeezeShape(t);if(u.length<t.length){let I=li(r,u),_=["row","col","depth","depth2"];return`
      ${ii(I,e)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${ci(_,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${ui(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1],d=`int stride2 = ${n}Shape[3];`,h=`int stride1 = ${n}Shape[2] * stride2;`,g=`int stride0 = ${n}Shape[1] * stride1;`;if(f===a&&c==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${d}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===s&&c==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;let y=Rs(n);return e?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${d}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${y});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${f}, index + ${y});
      return sampleTexture(${n}, uv);
    }
  `}function GB(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e[4],s=e[3]*o,i=e[2]*s,a=e[1]*i,{newShape:u,keptDims:l}=w.squeezeShape(e);if(u.length<e.length){let h=li(r,u),g=["row","col","depth","depth2","depth3"];return`
      ${ii(h)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${ci(g,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${ui(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1];if(f===a&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;let d=Rs(t);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${d};
      vec2 uv = uvFromFlat(${m}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function zB(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:o,keptDims:s}=w.squeezeShape(e);if(o.length<e.length){let g=li(r,o),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${ii(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${ci(y,s)});
      }
    `}let i=e[5],a=e[4]*i,u=e[3]*a,l=e[2]*u,c=e[1]*l;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${ui(r)}
      }
    `;let p=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,f=m[0],d=m[1];if(d===c&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===i&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;let h=Rs(t);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${h};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function ui(r){let e=r.name,t=w.sizeFromShape(r.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function YB(r,e){let t=r.name,n=t.charAt(0).toUpperCase()+t.slice(1),o="get"+n+"AtOutCoords",s=r.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=eS(r.shapeInfo.logicalShape,e.logicalShape),u=oe(i),l=i-s,c,p=["x","y","z","w","u","v"];s===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(I=>`coords.${p[I+l]} = 0;`).join(`
`);let m="";i<2&&s>0?m="coords":m=r.shapeInfo.logicalShape.map((I,_)=>`coords.${p[_+l]}`).join(", ");let f="return outputValue;",h=w.sizeFromShape(r.shapeInfo.logicalShape)===1,y=w.sizeFromShape(e.logicalShape)===1;if(s===1&&!h&&!y)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!y)i===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){let I=s-2,_=s-1;a.indexOf(I)>-1&&a.indexOf(_)>-1?f="return vec4(outputValue.x);":a.indexOf(I)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(_)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${n}(${m});
      ${f}
    }
  `}function JB(r,e){let t=r.name,n=t.charAt(0).toUpperCase()+t.slice(1),o="get"+n+"AtOutCoords",s=e.texShape,i=r.shapeInfo.texShape,a=r.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!r.shapeInfo.isUniform&&a===u&&r.shapeInfo.flatOffset==null&&w.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${t}, resultUV);
      }
    `;let l=oe(u),c=eS(r.shapeInfo.logicalShape,e.logicalShape),p=u-a,m,f=["x","y","z","w","u","v"];a===0?m="":u<2&&c.length>=1?m="coords = 0;":m=c.map(h=>`coords.${f[h+p]} = 0;`).join(`
`);let d="";return u<2&&a>0?d="coords":d=r.shapeInfo.logicalShape.map((h,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${m}
      return get${n}(${d});
    }
  `}function oe(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function hp(r,e,t){let{newShape:n,keptDims:o}=w.squeezeShape(e),s=e.length,i=r&&s===3&&e[0]===1,a=i?e.slice(1):n,u=!r&&s>1&&!w.arraysEqual(e,t)&&n.length<s||i;return{useSqueezeShape:u,uniformShape:u?a:e,keptDims:o}}function li(r,e){let t=JSON.parse(JSON.stringify(r));return t.shapeInfo.logicalShape=e,t}function ci(r,e){return e.map(t=>r[t]).join(", ")}function oS(r,e,t,n){let o=t.map((_,N)=>{let R={logicalShape:_.shape,texShape:_.isUniform?null:_.texData.texShape,isUniform:_.isUniform,isPacked:_.isUniform?!1:_.texData.isPacked,flatOffset:null};return _.texData!=null&&_.texData.slice!=null&&_.texData.slice.flatOffset>0&&(R.flatOffset=_.texData.slice.flatOffset),{name:e.variableNames[N],shapeInfo:R}}),s=o.map(_=>_.shapeInfo),i={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},a=tS(o,i,e),u=r.createProgram(a),l=null,c=r.getUniformLocation(u,"NAN",!1);$().getNumber("WEBGL_VERSION")===1&&(l=r.getUniformLocation(u,"INFINITY",!1));let p=!1,m={},f={},d={};for(let _=0;_<e.variableNames.length;_++){let N=e.variableNames[_];m[N]=r.getUniformLocation(u,N,p),m[`offset${N}`]=r.getUniformLocation(u,`offset${N}`,p),e.enableShapeUniforms&&(f[`${N}Shape`]=r.getUniformLocation(u,`${N}Shape`,p),d[`${N}TexShape`]=r.getUniformLocation(u,`${N}TexShape`,p))}let h,g,y;e.enableShapeUniforms&&(h=r.getUniformLocation(u,"outShape",p),y=r.getUniformLocation(u,"outShapeStrides",p),g=r.getUniformLocation(u,"outTexShape",p));let I=[];return e.customUniforms&&e.customUniforms.forEach((_,N)=>{I[N]=r.getUniformLocation(u,_.name,p)}),{program:e,source:a,webGLProgram:u,uniformLocations:m,customUniformLocations:I,inShapeInfos:s,outShapeInfo:i,infLoc:l,nanLoc:c,inShapesLocations:f,inTexShapesLocations:d,outShapeLocation:h,outShapeStridesLocation:y,outTexShapeLocation:g}}function sS(r,e){if(r.length!==e.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${e.length} inputs`);r.forEach((t,n)=>{let o=t.logicalShape,s=e[n],i=s.shape;if(!w.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(t.isUniform&&s.isUniform)return;let a=t.texShape,u=s.isUniform?null:s.texData.texShape;if(!w.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function aS(r,e,t,n,o){e.program.enableShapeUniforms||(sS(e.inShapeInfos,t),sS([e.outShapeInfo],[n]));let s=n.texData.texture,i=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(s,i[0],i[1]):r.setOutputMatrixTexture(s,i[0],i[1]),r.setProgram(e.webGLProgram),$().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&r.gl.uniform1f(e.infLoc,Infinity),e.nanLoc!==null&&r.gl.uniform1f(e.nanLoc,NaN),t.forEach((u,l)=>{let c=e.program.variableNames[l],p=e.uniformLocations[c],m=e.uniformLocations[`offset${c}`],f=e.inShapesLocations[`${c}Shape`],d=e.inTexShapesLocations[`${c}TexShape`];if(f){let{uniformShape:h}=hp(e.program.packedInputs,u.shape,u.texData.texShape);switch(h.length){case 1:r.gl.uniform1iv(f,new Int32Array(h));break;case 2:r.gl.uniform2iv(f,new Int32Array(h));break;case 3:r.gl.uniform3iv(f,new Int32Array(h));break;case 4:r.gl.uniform4iv(f,new Int32Array(h));break;default:break}}if(d&&r.gl.uniform2i(d,u.texData.texShape[0],u.texData.texShape[1]),p!=null){if(u.isUniform){if(w.sizeFromShape(u.shape)<2)r.gl.uniform1f(p,u.uniformValues[0]);else{let h=u.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),r.gl.uniform1fv(p,h)}return}u.texData.slice!=null&&m!=null&&r.gl.uniform1i(m,u.texData.slice.flatOffset),r.setInputMatrixTexture(u.texData.texture,p,l)}});let a=e.outShapeLocation;if(a)switch(n.shape.length){case 1:r.gl.uniform1iv(a,new Int32Array(n.shape));break;case 2:r.gl.uniform2iv(a,new Int32Array(n.shape));break;case 3:r.gl.uniform3iv(a,new Int32Array(n.shape));break;case 4:r.gl.uniform4iv(a,new Int32Array(n.shape));break;default:break}if(e.outShapeStridesLocation){let u=w.computeStrides(n.shape);switch(n.shape.length){case 2:r.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:r.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:r.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break;default:break}}e.outTexShapeLocation&&r.gl.uniform2i(e.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),e.program.customUniforms&&o&&e.program.customUniforms.forEach((u,l)=>{let c=e.customUniformLocations[l],p=o[l];if(u.type==="float")r.gl.uniform1fv(c,p);else if(u.type==="vec2")r.gl.uniform2fv(c,p);else if(u.type==="vec3")r.gl.uniform3fv(c,p);else if(u.type==="vec4")r.gl.uniform4fv(c,p);else if(u.type==="int")r.gl.uniform1iv(c,p);else if(u.type==="ivec2")r.gl.uniform2iv(c,p);else if(u.type==="ivec3")r.gl.uniform3iv(c,p);else if(u.type==="ivec4")r.gl.uniform4iv(c,p);else throw Error(`uniform type ${u.type} is not supported yet.`)}),r.executeProgram()}function iS(r,e,t){let n="";e.concat(t).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!i.isUniform){let u=i.texData.texShape,{useSqueezeShape:l,uniformShape:c,keptDims:p}=hp(r.packedInputs,i.shape,u),m="",f="",d="";if(c.length===1&&r.packedInputs){let R=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${R[0]>1}_${R[1]>1}`}else if(c.length===2&&!r.packedInputs)f=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!r.packedInputs){let R=w.computeStrides(c);d=`${R[0]===u[1]}_${R[R.length-1]===u[1]}`}let h=i.shape.length,g=c.length===2&&w.arraysEqual(i.shape,u),y=w.sizeFromShape(i.shape)===1,I=k.getBroadcastDims(i.shape,t.shape),_=!r.packedInputs&&h===t.shape.length&&w.arraysEqual(u,t.texData.texShape),N=r.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${h}_${_}_${l?p:""}_${c.length}_${y}_${I}_${g}_${m}_${f}_${d}_${N}_${a}`}else{let u=i.isUniform?"uniform":i.texData.texShape;n+=`${i.shape}_${u}_${a}`}});let o=r.userCode,s=r.constructor.name;return s+="_"+n+"_"+o+`${$().getNumber("WEBGL_VERSION")}`,s}function Fe(r){return $().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var ex=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=jn.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Ae();this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?As(["r","c","d"],e):nr(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}};var tx=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=jn.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Ae();this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?As(["r","c","d"],e):nr(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}};var rx=class{constructor(e){this.variableNames=["A"],this.outTexUsage=at.DOWNLOAD;let t=Ae();this.outputShape=e,this.userCode=`
      ${dp}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}};var nx=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=at.DOWNLOAD;let t=Ae();this.outputShape=e,this.userCode=`
      ${dp}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}};var ox=class{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Ae();this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length);let o="result";t&&(o="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?ai():si(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${n.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${n.output} = vec4(${o}, 0., 0., 0.);
      }
    `}};var sx=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Ae();this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length);let o="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let u=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?ai():si(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s};
        }
    `}};function uS(r){let e=Ae(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return O0(r,t)}function lS(r){let e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return M0(r,e)}function cS(r){let e=new Uint16Array([0,1,2,2,1,3]);return B0(r,e)}function Cu(r,e,t,n,o,s){W0(e,t);let i=U0(r),a=r.TEXTURE_2D;return Z(r,()=>r.bindTexture(a,i)),Z(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),Z(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),Z(r,()=>r.texParameteri(a,r.TEXTURE_MIN_FILTER,r.NEAREST)),Z(r,()=>r.texParameteri(a,r.TEXTURE_MAG_FILTER,r.NEAREST)),Z(r,()=>r.texImage2D(a,0,n,e,t,0,o,s,null)),Z(r,()=>r.bindTexture(r.TEXTURE_2D,null)),i}function ax(r){return r.internalFormatFloat}function pS(r,e,t,n){let[o,s]=Ns(e,t);return Cu(r,o,s,ax(n),n.textureFormatFloat,r.FLOAT)}function ix(r){return r.internalFormatHalfFloat}function mS(r,e,t,n){let[o,s]=Ns(e,t);return Cu(r,o,s,ix(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function ux(r){return r.downloadTextureFormat}function fS(r,e,t,n){let[o,s]=Ns(e,t);return Cu(r,o,s,ux(n),r.RGBA,r.UNSIGNED_BYTE)}function lx(r){return r.internalFormatPackedFloat}function dS(r,e,t,n){let[o,s]=Ir(e,t);return Cu(r,o,s,lx(n),r.RGBA,r.FLOAT)}function cx(r){return r.internalFormatPackedHalfFloat}function hS(r,e,t,n){let[o,s]=Ir(e,t);return Cu(r,o,s,cx(n),r.RGBA,n.textureTypeHalfFloat)}function gS(r,e,t){let n=0,o=3*4,s=3*4+2*4;return Z(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),Kg(r,e,"clipSpacePos",t,3,s,n)&&Kg(r,e,"uv",t,2,s,o)}function xS(r,e,t,n,o,s){Z(r,()=>r.bindTexture(r.TEXTURE_2D,e));let i,a,u;o instanceof Uint8Array?(i=new Uint8Array(t*n*4),a=r.UNSIGNED_BYTE,u=r.RGBA):(i=new Float32Array(t*n*4),a=r.FLOAT,u=s.internalFormatPackedFloat),i.set(o),Z(r,()=>r.texImage2D(r.TEXTURE_2D,0,u,t,n,0,r.RGBA,a,i)),Z(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function _S(r,e,t){Z(r,()=>r.bindTexture(r.TEXTURE_2D,e)),t.data instanceof Uint8Array?Z(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,t.width,t.height,0,r.RGBA,r.UNSIGNED_BYTE,t.data)):Z(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,t)),Z(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function yS(r,e,t,n){let o=r.createBuffer();Z(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,o));let a=4*4*e*t;return Z(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,a,r.STREAM_READ)),Z(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,0)),Z(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),o}function bS(r,e,t){let n=r,o=new Float32Array(t);return n.bindBuffer(n.PIXEL_PACK_BUFFER,e),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function wS(r,e,t,n){let[o,s]=Ns(e,t),i=4,a=new Uint8Array(R0(e*t,i));return Z(r,()=>r.readPixels(0,0,o,s,n.downloadTextureFormat,r.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function vS(r,e,t,n,o,s,i,a){let u=r,l=new Float32Array($0(s,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function IS(r,e,t){let n=new Float32Array(e*t*4);return Z(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,n)),n}var pi=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let t=$().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,A0(t,e)):this.gl=Mt(t);let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if($().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=vu(this.gl,s),Bt(this.gl,i))this.textureHalfFloatExtension=vu(this.gl,i);else if($().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Bt(this.gl,o))this.colorBufferHalfFloatExtension=vu(this.gl,o);else if($().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Bt(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Bt(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=lS(this.gl),this.indexBuffer=cS(this.gl),this.framebuffer=V0(this.gl),this.textureConfig=wu(this.gl,this.textureHalfFloatExtension)}get debug(){return $().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;Z(e,()=>e.finish()),Z(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Z(e,()=>e.deleteFramebuffer(this.framebuffer)),Z(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Z(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Z(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),pS(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),mS(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),fS(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),_S(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,o){this.throwIfDisposed(),xS(this.gl,e,t,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),hS(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),dS(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Xg(this.gl,this.framebuffer),this.outputTexture=null),Z(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>wS(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,o,s,i){return vS(this.gl,e,t,n,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return bS(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let o=yS(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if($().getBool("WEBGL_FENCE_API_ENABLED")){let o=e,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},t=s}else $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>IS(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl,n=F0(t,e);this.vertexShader==null&&(this.vertexShader=uS(t));let o=P0(t);return Z(t,()=>t.attachShader(o,this.vertexShader)),Z(t,()=>t.attachShader(o,n)),L0(t,o),this.debug&&cp(t,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=gS(t,this.program,this.vertexBuffer)),o}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&Z(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&cp(this.gl,this.program),Z(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?G0(this.gl,e,t):z0(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Z(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),H0(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[o,s]=Ir(t,n);this.setOutputMatrixTextureDriver(e,o,s)}setOutputMatrixWriteRegion(e,t,n,o){this.setOutputMatrixWriteRegionDriver(n,e,o,t)}setOutputPackedMatrixWriteRegion(e,t,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&cp(this.gl,this.program),Iu(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;this.debug&&this.debugValidate(),Z(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Z(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=vu(this.gl,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await w.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=p3(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&w.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),pp(this.gl,e,this.framebuffer),this.debug&&Iu(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(pp(this.gl,this.outputTexture,this.framebuffer),this.debug&&Iu(this.gl)):Xg(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let o=this.gl;pp(o,e,this.framebuffer),this.debug&&Iu(o),this.outputTexture=e,Z(o,()=>o.viewport(0,0,t,n)),Z(o,()=>o.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,o){this.throwIfDisposed(),Z(this.gl,()=>this.gl.scissor(e,t,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function p3(r){let e=0;for(;e<r.length&&r[e]();++e);return e-1}var{addImpl:CS,bincountImpl:gp,bincountReduceImpl:TS,ceilImpl:SS,concatImpl:kS,equalImpl:NS,expImpl:ES,expm1Impl:AS,floorImpl:RS,gatherNdImpl:$S,gatherV2Impl:DS,greaterImpl:OS,greaterEqualImpl:FS,lessImpl:PS,lessEqualImpl:LS,linSpaceImpl:MS,logImpl:BS,maxImpl:US,maximumImpl:WS,minimumImpl:VS,multiplyImpl:GS,negImpl:zS,notEqualImpl:HS,prodImpl:jS,rangeImpl:qS,rsqrtImpl:KS,sigmoidImpl:XS,simpleAbsImpl:xp,sliceImpl:YS,sparseFillEmptyRowsImpl:JS,sparseReshapeImpl:QS,sparseSegmentReductionImpl:_p,sqrtImpl:ZS,stridedSliceImpl:ek,stringNGramsImpl:tk,stringSplitImpl:rk,stringToHashBucketFastImpl:nk,subImpl:ok,tileImpl:sk,topKImpl:ak,transposeImpl:$s,uniqueImpl:ik}=$g;function px(r,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${r}.${t}`)}function Me(r,e){return e===1?[r]:px(r,e)}function uk(r,e){if(r===1)return"rc";let t="";for(let n=0;n<r;n++)t+=e[n],n<r-1&&(t+=",");return t}var mx=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;let t=e.length;if(t===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let n=Me("rc",t),o=oe(t),s=m3(t,e,n),i=f3(t,e[e.length-1],e[e.length-2],n),a=d3(e,n);this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${a}));
          }
        }
      `}}};function h3(r,e){let t=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<r;i++)s=`${e[e.length-1-i]},`+s;t.push(s)}return t}function m3(r,e,t){if(r===1)return`rc > ${e[0]}`;let n="";for(let o=r-2;o<r;o++)n+=`${t[o]} >= ${e[o]}`,o<r-1&&(n+="||");return n}function f3(r,e,t,n){if(r===1)return"";let o=n.slice(-2);return`
    int r = ${o[0]};
    int c = ${o[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${e};
    bool rEdge = rp1 >= ${t};
  `}function d3(r,e){let t=r.length,n=h3(t,e);return t===1?`getA(rc),
            rc + 1 >= ${r[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${n[0]}),
          cEdge ? 0. : getA(${n[1]}),
          rEdge ? 0. : getA(${n[2]}),
          rEdge || cEdge ? 0. : getA(${n[3]})`}var Tu=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length);let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2==1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${g3(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?ai():si(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function g3(r,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?Z0(["r","c","d"],"inputShape"):nr(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var fx=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){let o=ck(t,n),s=pk(e,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=lk(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let u=this.freeTextures[s].shift();return this.usedTextures[s].push(u),u}let a;return o===tt.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===tt.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===tt.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===tt.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===tt.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,t,n,o){if(this.freeTextures==null)return;let s=ck(n,o),i=pk(t,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=lk(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),u=$().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let l=this.usedTextures[i],c=l.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function x3(r,e){let t=r;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===r.RGBA)return 16;if(e===t.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}function lk(r,e,t,n,o){let s=_3(e,n),i;if(o){let[u,l]=Ir(r[0],r[1]);i=u*l}else{let[u,l]=Ns(r[0],r[1]);i=u*l}let a=x3(t,s);return i*a}function _3(r,e){switch(r){case tt.PACKED_2X2_FLOAT32:return lx(e);case tt.PACKED_2X2_FLOAT16:return cx(e);case tt.UNPACKED_FLOAT32:return ax(e);case tt.UNPACKED_FLOAT16:return ix(e);case tt.PACKED_4X1_UNSIGNED_BYTE:return ux(e);default:throw new Error(`Unknown physical texture type ${r}`)}}function y3(r){return $().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?tt.PACKED_2X2_FLOAT32:tt.UNPACKED_FLOAT32:r?tt.PACKED_2X2_FLOAT16:tt.UNPACKED_FLOAT16}function ck(r,e){if(r===at.UPLOAD)return tt.PACKED_2X2_FLOAT32;if(r===at.RENDER||r==null)return y3(e);if(r===at.DOWNLOAD||r===at.PIXELS)return tt.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function pk(r,e,t){return`${r[0]}_${r[1]}_${e}_${t}`}var St=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Je="if (isnan(x)) return x;",mk="return x;",dx="return abs(x);";var fk="return (x >= 0.0) ? x : (exp(x) - 1.0);",dk=Je+`
  return (x < 0.0) ? 0.0 : x;
`,hk=Je+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Su="return x;",gk="return 1.0 / (1.0 + exp(-1.0 * x));";var xk="return x;",_k=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,yk=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,bk=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,wk="return 1.0 / (1.0 + exp(-1.0 * x));",or=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var hx=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;let t=e.length,n=Me("rc",t),o=oe(t),s=uk(t,n),i=n.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var b3=wr.whereImpl,w3=1e-7,v3=1e-4,yp={};function I3(r){return r in yp||(yp[r]={}),yp[r]}var C3=$().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),T3=600;function S3(){return $().global.screen==null?1024:$().global.screen.height*$().global.screen.width*window.devicePixelRatio*T3/1024/1024}var qr=class extends cn{constructor(e){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!$().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(e==null){let t=Mt($().getNumber("WEBGL_VERSION"));this.binaryCache=I3($().getNumber("WEBGL_VERSION")),this.gpgpu=new pi(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new fx(this.gpgpu),this.numMBBeforeWarning=S3(),this.texData=new ra(this,Bn())}nextDataId(){return qr.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if(($().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||$().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.texData.set(o,{shape:t,dtype:n,values:e,usage:at.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,o,s){if($().getBool("DEBUG")&&this.checkNumericalProblems(t),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:o,values:t,usage:at.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:o,complexTensorInfos:s,slice:i,shape:a,isPacked:u}=t;if(i!=null){let m;u?m=new or(a,Su):m=new St(a,Su);let f=this.runWebGLProgram(m,[{dataId:e,shape:a,dtype:o}],o),d=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),d}if(n!=null)return this.convertAndCacheOnCPU(e);if(o==="string")return n;let l=this.activeTimers!=null,c;l&&(c=w.now());let p;if(o==="complex64"){let m=this.readSync(s.real.dataId),f=this.readSync(s.imag.dataId);p=k.mergeRealAndImagArrays(m,f)}else p=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=w.now()-c),this.convertAndCacheOnCPU(e,p)}async read(e){if(this.pendingRead.has(e)){let d=this.pendingRead.get(e);return new Promise(h=>d.push(h))}let t=this.texData.get(e),{values:n,shape:o,slice:s,dtype:i,complexTensorInfos:a,isPacked:u}=t;if(s!=null){let d;u?d=new or(o,Su):d=new St(o,Su);let h=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:i}],i),g=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(n!=null)return this.convertAndCacheOnCPU(e);if(!$().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&$().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,c;if(i!=="complex64"&&$().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);let d=this.texData.get(c.dataId);l=this.gpgpu.createBufferFromTexture(d.texture,...bu(o))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(i==="complex64"){let d=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),h=d[0],g=d[1];p=k.mergeRealAndImagArrays(h,g)}else if(l==null)p=this.getValuesFromTexture(e);else{let d=w.sizeFromShape(o);p=this.gpgpu.downloadFloat32MatrixFromBuffer(l,d)}if(c!=null&&this.disposeIntermediateTensorInfo(c),l!=null){let d=this.gpgpu.gl;Z(d,()=>d.deleteBuffer(l))}let m=this.convertAndCacheOnCPU(e,p),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach(d=>d(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Bn().removeDataId(e,this),this.pendingDeletes--),m}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(o=>w.decodeString(o))}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return ye(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let n=e[t];if(!D0(n))throw $().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:o}=this.texData.get(e),s=w.sizeFromShape(t);if($().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(e),f=this.texData.get(m.dataId),d=this.gpgpu.downloadMatrixFromPackedTexture(f.texture,...bu(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(m),d}let i=$().getBool("WEBGL_PACK")&&o===!0,a=i?mp(t):t,u=i?new nx(a):new rx(a),l=this.runWebGLProgram(u,[{shape:a,dtype:n,dataId:e}],"float32"),c=this.texData.get(l.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),p}timerAvailable(){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){let t=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=w.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=w.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,o&&(this.programTimersStack=null);let a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(s);a.kernelMs=w.sum(u),a.getExtraProfileInfo=()=>u.map((l,c)=>({name:i[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:w.now(),endMs:null}}endTimer(e){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=w.now(),e)}async getQueryTime(e){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:o,usage:s,isPacked:i,slice:a}=this.texData.get(e),u=a&&a.origDataId||e,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(o,n),this.textureManager.releaseTexture(t,o,s,i)));let c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=C3){return $().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&w.sizeFromShape(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){k.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return b3(e.shape,t)}packedUnaryOp(e,t,n){let o=new or(e.shape,t),s=this.compileAndRun(o,[e],n);return Bn().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let o=xp(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if($().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,dx,e.dtype);let t=new St(e.shape,dx),n=this.compileAndRun(t,[e]);return Bn().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&w.isString(n[0])){let s=n.map(i=>w.encodeString(i));o=this.write(s,e,t)}else o=this.write(n,e,t);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:t}}makeOutput(e,t,n){let{dataId:o}=this.makeTensorInfo(e,t,n);return Bn().makeTensorFromDataId(o,e,t,this)}unpackTensor(e){let t=new hx(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new mx(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[qn(e.shape),...Kn(e.shape)],o={dtype:e.dtype,shape:n,dataId:e.dataId},s=[qn(t),...Kn(t)],i=new Tu(s,n),a=!0,u=[n],l=this.runWebGLProgram(i,[o],e.dtype,u,a);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e){let t=this.texData.get(e),{isPacked:n,shape:o,dtype:s}=t,i=mp(o),a,u=bu(i);n?a=new tx(i):a=new ex(i);let l=!0,c=[u],p=this.runWebGLProgram(a,[{shape:i,dtype:s,dataId:e}],s,c,l);return{dtype:s,shape:o,dataId:p.dataId}}runWebGLProgram(e,t,n,o,s=!1){let i=this.makeTensorInfo(e.outputShape,n),a=this.texData.get(i.dataId);if(e.packedOutput&&(a.isPacked=!0),e.outPackingScheme===jn.DENSE){let g=bu(e.outputShape);a.texShape=g.map(y=>y*2)}if(e.outTexUsage!=null&&(a.usage=e.outTexUsage),w.sizeFromShape(i.shape)===0)return a.values=w.getTypedArrayFromDType(i.dtype,0),i;let u=[],l=t.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let y=this.texData.get(g.dataId);if(y.texture==null){if(!e.packedInputs&&w.sizeFromShape(g.shape)<=$().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:y.values};e.packedInputs&&(y.isPacked=!0,y.shape=g.shape)}else if(!!y.isPacked!=!!e.packedInputs)g=y.isPacked?this.unpackTensor(g):this.packTensor(g),u.push(g),y=this.texData.get(g.dataId);else if(y.isPacked&&!Es(y.shape,g.shape)){let I=g,_=g.shape;g.shape=y.shape,g=this.packedReshape(g,_),u.push(g),y=this.texData.get(g.dataId),I.shape=_}return this.uploadToGPU(g.dataId),{shape:g.shape,texData:y,isUniform:!1}});this.uploadToGPU(i.dataId);let c={shape:i.shape,texData:a,isUniform:!1},p=iS(e,l,c),m=this.getAndSaveBinary(p,()=>oS(this.gpgpu,e,l,c)),f=this.activeTimers!=null,d;f&&(d=this.startTimer()),aS(this.gpgpu,m,l,c,o),u.forEach(g=>this.disposeIntermediateTensorInfo(g)),f&&(d=this.endTimer(d),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(d)}));let h=$().get("WEBGL_FLUSH_THRESHOLD");if(h>0){let g=w.now();g-this.lastGlFlushTime>h&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!$().getBool("WEBGL_LAZILY_UNPACK")&&a.isPacked&&s===!1){let g=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),g}return i}compileAndRun(e,t,n,o,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,o,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||($().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=xe(()=>{if(!$().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=$().getBool("DEBUG");$().set("DEBUG",!1);let t=this.abs(He(1e-8)).dataSync()[0];if($().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?w3:v3}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:o,values:s,texture:i,usage:a,isPacked:u}=t;if(i!=null)return;let l=this.activeTimers!=null,c;l&&(c=w.now());let p=t.texShape;if(p==null&&(p=j0(n,u),t.texShape=p),s!=null){let m=mp(n),f,d=p[1],h=p[0],g=s instanceof Uint8Array;u?([d,h]=Ir(p[0],p[1]),f=new sx(m,g)):f=new ox(m,g);let y=this.makeTensorInfo([h,d],o);g?this.texData.get(y.dataId).usage=at.PIXELS:this.texData.get(y.dataId).usage=at.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),d,h,s);let I=[[h,d]],_=!0,N=this.runWebGLProgram(f,[y],o,I,_),R=this.texData.get(N.dataId);t.texture=R.texture,t.texShape=R.texShape,t.isPacked=R.isPacked,t.usage=R.usage,this.disposeIntermediateTensorInfo(y),this.texData.delete(N.dataId),t.values=null,l&&(this.uploadWaitMs+=w.now()-c)}else{let m=this.acquireTexture(p,a,o,u);t.texture=m}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:o}=n;return this.releaseGPUData(e),t!=null&&(n.values=k3(t,o)),n.values}acquireTexture(e,t,n,o){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,o)}computeBytes(e,t){return e[0]*e[1]*w.bytesPerElement(t)}};qr.nextDataId=0;function k3(r,e){if(e==="float32"||e==="complex64")return r;if(e==="int32"||e==="bool"){let t=e==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<t.length;++n)t[n]=Math.round(r[n]);return t}else throw new Error(`Unknown dtype ${e}`)}is.isBrowser()&&qa("webgl",()=>new qr,2);var bp=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var Kt=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=k.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var Xn=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;var sr=class{constructor(e,t,n,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=k.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length;this.enableShapeUniforms=Fe(s);let i="";if(o)if(s===0||w.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${oe(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let u=Me("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function Be(r){let{inputs:e,backend:t}=r,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var vk={kernelName:Br,backendName:"webgl",kernelFunc:Be};function kt(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.makeTensorInfo(n.shape,"complex64"),i=t.texData.get(s.dataId),a=Be({inputs:{x:n},backend:t}),u=Be({inputs:{x:o},backend:t});return i.complexTensorInfos={real:a,imag:u},s}var Ik={kernelName:Mi,backendName:"webgl",kernelFunc:kt};var gx="return (a < 0.) ? b * a : a;",xx=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function N3(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n,i=t.makeTensorInfo([],"float32",w.createScalarValue(s,"float32")),a=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sr(xx,o.shape,i.shape):new Kt(gx,o.shape,i.shape),u=t.runWebGLProgram(a,[o,i],o.dtype);return t.disposeIntermediateTensorInfo(i),u}var Ck={kernelName:No,backendName:"webgl",kernelFunc:N3};var _x="return (a < 0.) ? b * a : a;",yx=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function E3(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sr(yx,n.shape,o.shape):new Kt(_x,n.shape,o.shape);return t.runWebGLProgram(s,[n,o],n.dtype)}var Tk={kernelName:Uo,backendName:"webgl",kernelFunc:E3};var wp="if (isnan(x)) return x;",Sk=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,kk=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function X({opSnippet:r,packedOpSnippet:e,cpuKernelImpl:t,dtype:n}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,u=n||i.dtype;if(a.shouldExecuteOnCPU([i])&&t!=null){let p=a.texData.get(i.dataId),m=t(p.values,u);return a.makeTensorInfo(i.shape,u,m)}let l=$().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null,c;return l?c=new or(i.shape,e):c=new St(i.shape,r),a.runWebGLProgram(c,[i],u)}}function fe({opSnippet:r,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:u,b:l}=i,c=a;if(n&&u.dtype==="complex64"){let d=c.texData.get(u.dataId),h=c.texData.get(l.dataId),[g,y]=[[d.complexTensorInfos.real,h.complexTensorInfos.real],[d.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(_=>{let[N,R]=_,F={dataId:N.dataId,dtype:N.dtype,shape:u.shape},D={dataId:R.dataId,dtype:R.dtype,shape:l.shape},O=new Kt(r,u.shape,l.shape);return c.runWebGLProgram(O,[F,D],ut(N.dtype,R.dtype))}),I=kt({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),I}let p=s||ut(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&o!=null){let d=c.texData.get(u.dataId).values,h=c.texData.get(l.dataId).values,g=u.dtype==="string"?k.fromUint8ToStringArray(d):d,y=u.dtype==="string"?k.fromUint8ToStringArray(h):h,[I,_]=o(u.shape,l.shape,g,y,p),N=c.makeTensorInfo(_,p),R=c.texData.get(N.dataId);return R.values=I,N}let m=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null,f;return m?f=new sr(e,u.shape,l.shape,t):f=new Kt(r,u.shape,l.shape),c.runWebGLProgram(f,[u,l],p)}}function Yn(r,e=!1){if(r==="linear")return e?xk:mk;if(r==="relu")return e?yk:dk;if(r==="elu")return e?_k:fk;if(r==="relu6")return e?bk:hk;if(r==="prelu")return e?yx:_x;if(r==="leakyrelu")return e?xx:gx;if(r==="sigmoid")return e?wk:gk;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var ku=class{constructor(e,t,n,o=!1,s=!1,i=!1,a=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Fe(this.outputShape.length);let c=o?e[1]:e[2],p=Math.ceil(c/2),m=o?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",d=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",y="";a&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");let I=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let _="rc.x",N="rc.x";e[0]<t[0]?_=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(N=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${p}; i++) {
          int batchA = ${_};
          int batchB = ${N};
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${d[0]} * ${h[0]});
          result += (${d[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${I}

        ${y}

        setOutput(result);
      }
    `}};var bx={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},vp=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=k.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var Nk="return a * b;";function Nu(r){let{inputs:e,backend:t}=r,{a:n,b:o}=e,s=k.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let a=t.texData.get(n.dataId),u=t.texData.get(o.dataId),l=new vp(bx.REAL,n.shape,o.shape),c=new vp(bx.IMAG,n.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:n.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:o.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:o.shape}],m=t.runWebGLProgram(l,p,"float32"),f=t.runWebGLProgram(c,p,"float32"),d=kt({inputs:{real:m,imag:f},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),d}if(t.shouldExecuteOnCPU([n,o])){let a=t.texData.get(n.dataId),u=t.texData.get(o.dataId),[l,c]=GS(n.shape,o.shape,a.values,u.values,s),p=t.makeTensorInfo(c,s),m=t.texData.get(p.dataId);return m.values=l,p}let i;return $().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new sr(Nk,n.shape,o.shape):i=new Kt(Nk,n.shape,o.shape),t.runWebGLProgram(i,[n,o],s)}var Ek={kernelName:In,backendName:"webgl",kernelFunc:Nu};function Ak(r,e,t){let n=[qn(r.shape),...Kn(r.shape)],o={dtype:r.dtype,shape:n,dataId:r.dataId},s=[qn(e),...Kn(e)],i=new Tu(s,n),a=!0,u=[n],l=t.runWebGLProgram(i,[o],r.dtype,u,a);return{dataId:l.dataId,shape:e,dtype:l.dtype}}function V(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{shape:s}=n,i=t,a=w.sizeFromShape(o.shape),u=w.inferFromImplicitShape(s,a),l=w.sizeFromShape(u);w.assert(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(o.dataId);return c.isPacked&&!Es(o.shape,u)&&!(c.texture!==null&&Es(c.shape,u))?Ak(o,u,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype})}var Rk={kernelName:Ta,backendName:"webgl",kernelFunc:V};var Ip=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=e;this.outputShape=[o,i];let a=Math.floor(n/4)*4,u=n%4,l="sumValue += dot(values, ones);";if(t!=null){let p=1/t;l=`sumValue += dot(values * ${w.isInt(p)?p.toPrecision(2):p}, ones);`}let c="";s%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};var wx=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=e;this.outputShape=[o,i];let a="0.0",u="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",u="min"):t==="max"&&(a="-1.0 / 1e-20",u="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let c=Math.floor(n/4)*4,p=n%4,m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";t==="all"?(a="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):t==="any"&&(a="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function A3(r){let e=[];for(;e.length===0||e[e.length-1].outSize!==1;){let t=e.length?e[e.length-1].outSize:r[1],n=k.computeOptimalWindowSize(t);e.push({inSize:t,windowSize:n,outSize:Math.ceil(t/n)})}return e}function Ot(r,e,t,n){let o=A3(r.shape),s=r;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:u,outSize:l}=o[i],c,p;t==="mean"?c=i===0?new Ip({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},a):new Ip({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l}):c=new wx({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},t),p=s,s=n.runWebGLProgram(c,[s],e),p.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(p)}return s}var vx=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.rank=n.length;let o=oe(this.rank),s=R3(t);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function R3(r){let e=r.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(e);for(let o=0;o<r.length;o++)n[r[o]]=t[o];return n.join()}var Ix=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let c=0;c<n.length;c++)n[c]=e[t[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=oe(this.rank),s=px("rc",this.rank),i=new Array(this.rank);for(let c=0;c<t.length;c++)i[t[c]]=s[c];let a=`vec2(${i.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function Jn(r,e,t){let n=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ix(r.shape,e):new vx(r.shape,e);return t.runWebGLProgram(n,[r],r.dtype)}function $k(r,e,t,n){let o=e,s=r.shape.length,i=w.parseAxisParam(o,r.shape),a=i,u=k.getAxesPermutation(a,s),l=u!=null,c=r;l&&(c=Jn(r,u,n),a=k.getInnerMostAxes(a.length,s)),k.assertAxesAreInnerMostDims("sum",a,s);let[p,m]=k.computeOutAndReduceShapes(c.shape,a),f=p;t&&(f=k.expandShapeToKeepDim(p,i));let d=w.sizeFromShape(m),g=w.sizeFromShape(r.shape)/d,y=V({inputs:{x:c},attrs:{shape:[g,d]},backend:n}),I=ss(r.dtype),_=Ot(y,I,"sum",n),N=V({inputs:{x:_},attrs:{shape:f},backend:n});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(_),l&&n.disposeIntermediateTensorInfo(c),N}function Ds(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n;return $k(o,s,i,t)}var Dk={kernelName:Ho,backendName:"webgl",kernelFunc:Ds};function Ne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{perm:s}=n,i=t,a=o.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=o.shape[s[c]];let l;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,m=$s(p,o.shape,o.dtype,s,u);l=i.makeTensorInfo(u,o.dtype);let f=i.texData.get(l.dataId);f.values=m}else l=Jn(o,s,i);return l}var Ok={kernelName:Yo,backendName:"webgl",kernelFunc:Ne};var Cx=1e3;function Os({a:r,b:e,transposeA:t,transposeB:n,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){let l=r.shape.length,c=e.shape.length,p=t?r.shape[l-2]:r.shape[l-1],m=n?e.shape[c-1]:e.shape[c-2],f=t?r.shape[l-1]:r.shape[l-2],d=n?e.shape[c-2]:e.shape[c-1],h=r.shape.slice(0,-2),g=e.shape.slice(0,-2),y=w.sizeFromShape(h),I=w.sizeFromShape(g),_=y===I||y===1||I===1;w.assert(l>=2&&c>=2&&_,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${h}) and (${g}).`);let R=(y>I?r.shape.slice(0,-2):e.shape.slice(0,-2)).concat([f,d]);w.assert(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);let F=t?[y,p,f]:[y,f,p],D=n?[I,d,m]:[I,m,d],O=V({inputs:{x:r},backend:o,attrs:{shape:F}}),U=V({inputs:{x:e},backend:o,attrs:{shape:D}}),M=[O,U],G=Math.max(y,I),j=t?O.shape[1]:O.shape[2],ee=s!=null,Q=i!=null,ie=u==="leakyrelu",le=u!=null?Yn(u,!0):null,Ce=ee||Q||ie||le!=null,de;if((f===1||d===1)&&j>Cx&&Ce===!1){let se=O,it=U;t&&(se=Ne({inputs:{x:O},backend:o,attrs:{perm:[0,2,1]}}),M.push(se)),n&&(it=Ne({inputs:{x:U},backend:o,attrs:{perm:[0,2,1]}}),M.push(it));let rt=d!==1,We=d===1,_t=se;rt&&(_t=V({inputs:{x:se},backend:o,attrs:{shape:[G,j,1]}}),M.push(_t));let lr=d===1?2:1,Nt=it;We&&(Nt=V({inputs:{x:it},backend:o,attrs:{shape:[G,1,j]}}),M.push(Nt));let rn=Nu({inputs:{a:_t,b:Nt},backend:o});de=Ds({inputs:{x:rn},backend:o,attrs:{axis:lr,keepDims:!0}}),M.push(rn)}else{let se=ut(r.dtype,e.dtype),it=new ku(F,D,[G,f,d],t,n,ee,le,Q,ie),rt=[O,U];if(s!=null&&rt.push(s),Q&&rt.push(i),ie){let We=o.makeTensorInfo([],"float32",w.createScalarValue(a,"float32"));rt.push(We),M.push(We)}de=o.runWebGLProgram(it,rt,se)}let Qe=V({inputs:{x:de},backend:o,attrs:{shape:R}});M.push(de);for(let se of M)o.disposeIntermediateTensorInfo(se);return Qe}function $3(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n;return Os({a:o,b:s,transposeA:u,transposeB:l,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:c})}var Fk={kernelName:Rn,backendName:"webgl",kernelFunc:$3};var Pk="return abs(x);";function D3(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=t.texData.get(n.dataId),i=xp(s.values);return t.makeTensorInfo(n.shape,n.dtype,i)}let o;return $().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new or(n.shape,Pk):o=new St(n.shape,Pk),t.runWebGLProgram(o,[n],n.dtype)}var Lk={kernelName:co,backendName:"webgl",kernelFunc:D3};var O3=Je+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,F3=X({opSnippet:O3}),Mk={kernelName:Nl,backendName:"webgl",kernelFunc:F3};var P3=Je+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,L3=X({opSnippet:P3}),Bk={kernelName:El,backendName:"webgl",kernelFunc:L3};var Uk="return a + b;",M3=fe({opSnippet:Uk,packedOpSnippet:Uk,supportsComplex:!0,cpuKernelImpl:CS}),Wk={kernelName:fr,backendName:"webgl",kernelFunc:M3};var Tx=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var Sx=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function Cp(r){let{inputs:e,backend:t}=r,n=e;if(n.length===1)return Be({inputs:{x:n[0]},backend:t});if(n.length>$().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(n.length/2),l=Cp({inputs:n.slice(0,u),backend:t}),c=Cp({inputs:n.slice(u),backend:t});return Cp({inputs:[l,c],backend:t})}let o=n.map(u=>u.dtype).reduce((u,l)=>ut(u,l)),s=n.map(u=>u.shape),a=$().getBool("WEBGL_PACK")?new Sx(n[0].shape,s):new Tx(n[0].shape,s);return t.runWebGLProgram(a,n,o)}var Vk={kernelName:po,backendName:"webgl",kernelFunc:Cp};function B3(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n,a=o.shape.length,u=w.parseAxisParam(s,o.shape),l=u,c=k.getAxesPermutation(l,a),p=o;c!=null&&(p=Ne({inputs:{x:o},backend:t,attrs:{perm:c}}),l=k.getInnerMostAxes(l.length,a)),k.assertAxesAreInnerMostDims("all",l,a);let[m,f]=k.computeOutAndReduceShapes(p.shape,l),d=w.sizeFromShape(f),h=V({inputs:{x:p},backend:t,attrs:{shape:[-1,d]}}),g=Ot(h,h.dtype,"all",t),y;if(i){let I=k.expandShapeToKeepDim(m,u);y=V({inputs:{x:g},backend:t,attrs:{shape:I}})}else y=V({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(p),y}var Gk={kernelName:mo,backendName:"webgl",kernelFunc:B3};function U3(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n,a=o.shape.length,u=w.parseAxisParam(s,o.shape),l=u,c=k.getAxesPermutation(l,a),p=o;c!=null&&(p=Ne({inputs:{x:o},backend:t,attrs:{perm:c}}),l=k.getInnerMostAxes(l.length,a)),k.assertAxesAreInnerMostDims("any",l,a);let[m,f]=k.computeOutAndReduceShapes(p.shape,l),d=w.sizeFromShape(f),h=V({inputs:{x:p},backend:t,attrs:{shape:[-1,d]}}),g=Ot(h,h.dtype,"any",t),y;if(i){let I=k.expandShapeToKeepDim(m,u);y=V({inputs:{x:g},backend:t,attrs:{shape:I}})}else y=V({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(p),y}var zk={kernelName:fo,backendName:"webgl",kernelFunc:U3};var kx=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=t==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var Nx=class{constructor(e,t,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,w.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],i=Math.ceil(s/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,u=a.length,l=oe(u),c=Me("coords",u),p,m;if(i===1){m=u+1;let O=oe(m);p=`
        ${O} sourceLocR = ${O}(${c.join()}, 0);
        ++${c[u-1]};
        ${O} sourceLocG = ${O}(${c.join()}, 0);
        ++${c[u-2]};
        ${O} sourceLocA = ${O}(${c.join()}, 0);
        --${c[u-1]};
        ${O} sourceLocB = ${O}(${c.join()}, 0);
        --${c[u-2]};`}else m=u,p=`
        ${l} sourceLocR = coords;
        ++${c[u-1]};
        ${l} sourceLocG = coords;
        ++${c[u-2]};
        ${l} sourceLocA = coords;
        --${c[u-1]};
        ${l} sourceLocB = coords;
        --${c[u-2]};`;let f=["x","y","z","w","u","v"].slice(0,m),d="."+f[m-1],h=f.map(O=>"int "+O),g=Me("sourceLocR",m-1).concat("inIdx.r"),y=Me("sourceLocG",m-1).concat("inIdx.g"),I=Me("sourceLocB",m-1).concat("inIdx.b"),_=Me("sourceLocA",m-1).concat("inIdx.a"),N=n==="max"?"greaterThan":"lessThan",R=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${I.join()}),
                             getBestIndicesAChannel(${_.join()})));`,F=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${I.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${_.join()}) : 0.)`,D=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${D}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u-1]} < ${a[u-1]-1};
        bool hasNextRow = ${c[u-2]} < ${a[u-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},
          sourceLocB${d}, sourceLocA${d}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${F};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${R}
          vec4 candidate = ${F};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${N}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function Hk(r,e,t,n=null){let o=e.shape[0],s=e.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let i=k.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},u=new kx(a,t,n==null),l=[e];n!=null&&l.push(n);let c=r.runWebGLProgram(u,l,"int32");if(c.shape[1]===1)return c;let p=Hk(r,e,t,c);return r.disposeIntermediateTensorInfo(c),p}function jk(r,e,t,n=null){let o=n!=null?n.shape:e.shape,s=o[o.length-1],i=k.computeOptimalWindowSize(s),a=new Nx(o,i,t,n==null),u=n==null?[e]:[e,n],l=r.runWebGLProgram(a,u,"int32");if(l.shape.length===e.shape.length){let c=jk(r,e,t,l);return r.disposeIntermediateTensorInfo(l),c}return l}function Tp(r,e,t,n){let o=[t];if(k.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,e.shape.length),!$().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){let s=[],i=r.texData.get(e.dataId),a=i!==null&&i.isPacked,u=e;a&&(u=r.unpackTensor(e),s.push(u));let[l,c]=k.computeOutAndReduceShapes(u.shape,o),p=w.sizeFromShape(c),m=V({inputs:{x:u},backend:r,attrs:{shape:[-1,p]}});s.push(m);let f=Hk(r,m,n);s.push(f);let d=V({inputs:{x:f},backend:r,attrs:{shape:l}});return s.forEach(h=>r.disposeIntermediateTensorInfo(h)),d}return jk(r,e,n)}function W3(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,i=w.parseAxisParam(s,o.shape),a=k.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Ne({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(u),i=k.getInnerMostAxes(i.length,u.shape.length)),k.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);let c=Tp(t,u,i[0],"max");return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),c}var qk={kernelName:ho,backendName:"webgl",kernelFunc:W3};function V3(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,i=w.parseAxisParam(s,o.shape),a=k.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Ne({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(u),i=k.getInnerMostAxes(i.length,u.shape.length)),k.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);let c=Tp(t,u,i[0],"min");return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),c}var Kk={kernelName:Al,backendName:"webgl",kernelFunc:V3};var G3=Je+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,z3=X({opSnippet:G3}),Xk={kernelName:Rl,backendName:"webgl",kernelFunc:z3};var H3=Je+"return log(x + sqrt(x * x + 1.0));",j3=X({opSnippet:H3}),Yk={kernelName:$l,backendName:"webgl",kernelFunc:j3};var q3=Je+`
  return atan(x);
`,K3=X({opSnippet:q3}),Jk={kernelName:Dl,backendName:"webgl",kernelFunc:K3};var X3=Sk+`
  return atan(a, b);
`,Y3=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+kk+`
  return result;
`,J3=fe({opSnippet:X3,packedOpSnippet:Y3}),Qk={kernelName:Fl,backendName:"webgl",kernelFunc:J3};var Q3=Je+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Z3=X({opSnippet:Q3}),Zk={kernelName:Ol,backendName:"webgl",kernelFunc:Z3};var Tr=class{constructor(e,t,n,o=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,a=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,f=e.padInfo.top,d=e.padInfo.left;this.outputShape=e.outShape;let h=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,I="0.0";if(h||(I="-1.0 / 1e-20"),n){let O=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${f}, ${d});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${O} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:y:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let _="max",N=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(N="avgValue / count");let R=Math.floor(i/4)*4,F=i%4,D=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${f}, ${d});
      const float initializationValue = ${I};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${I});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${R}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${D}
          }

          int xC = xCCorner + ${R};
          if (${F===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${D}
          } else if (${F===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${D}
          } else if (${F===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${D}
          }
        }
        setOutput(${N});
      }
    `}},Fs=class{constructor(e,t,n,o=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,a=e.strideDepth,u=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,p=e.dilationHeight,m=e.dilationWidth,f=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,I=e.padInfo.left;this.outputShape=e.outShape;let _=t==="avg",N="0.0";if(_||(N="-1.0 / 1e-20"),n){let M=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${I});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${d};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${M} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${d} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let R="max",F=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(F="avgValue / count");let D=Math.floor(i/4)*4,O=i%4,U=`
      if (${_}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${R}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${I});
      const float initializationValue = ${N};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${N});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${D}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${U}
            }

            int xC = xCCorner + ${D};
            if (${O===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${U}
            } else if (${O===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${U}
            } else if (${O===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${U}
            }
          }
          setOutput(${F});
        }
      }
    `}};function eU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;Cr(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;w.assert(k.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=k.computePool2DInfo(o.shape,s,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&w.arraysEqual(c.inShape,c.outShape))return Be({inputs:{x:o},backend:t});let p=new Tr(c,"avg",!1);return t.runWebGLProgram(p,[o],"float32")}var eN={kernelName:go,backendName:"webgl",kernelFunc:eU};function tU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n,c=[1,1,1],p=k.computePool3DInfo(o.shape,s,i,c,a,u,l),m=new Fs(p,"avg",!1);return t.runWebGLProgram(m,[o],"float32")}var tN={kernelName:Pl,backendName:"webgl",kernelFunc:tU};var Ex=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=u-1-e.padInfo.top,p=l-1-e.padInfo.left,m=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Ax=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,p=e.effectiveFilterDepth,m=e.effectiveFilterHeight,f=e.effectiveFilterWidth,d=p-1-e.padInfo.front,h=m-1-e.padInfo.top,g=f-1-e.padInfo.left,y=1/(t*n*o);this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function rU(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],m=k.computePool3DInfo(i.shape,a,u,p,l,c),f=new Ax(m);return t.runWebGLProgram(f,[o],i.dtype)}var rN={kernelName:Sb,backendName:"webgl",kernelFunc:rU};function nU(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,i=s;Cr([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,c=k.computePool2DInfo(i.shape,a,u,1,l),p=new Ex(c);return t.runWebGLProgram(p,[o],i.dtype)}var nN={kernelName:Tb,backendName:"webgl",kernelFunc:nU};function oU(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:i,transposeB:a}=n;return Os({a:o,b:s,transposeA:i,transposeB:a,backend:t})}var oN={kernelName:xo,backendName:"webgl",kernelFunc:oU};var Rx=class{constructor(e,t,n,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],k.assertAndGetBroadcastShape(e,t),k.assertAndGetBroadcastShape(e,n);let a="0.0";o!=null&&(k.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";s!=null&&(k.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var $x=class{constructor(e,t,n,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],k.assertAndGetBroadcastShape(e,t),k.assertAndGetBroadcastShape(e,n);let a="vec4(0.0)";o!=null&&(k.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";s!=null&&(k.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var sU=({inputs:r,backend:e,attrs:t})=>{let{x:n,mean:o,variance:s,offset:i,scale:a}=r;w.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);let l=[n,o,s],c=null;i!=null&&(c=i.shape,l.push(i));let p=null;a!=null&&(p=a.shape,l.push(a));let m=$().getBool("WEBGL_PACK_NORMALIZATION")?new $x(n.shape,o.shape,s.shape,c,p,u):new Rx(n.shape,o.shape,s.shape,c,p,u);return e.runWebGLProgram(m,l,l[0].dtype)},sN={kernelName:So,backendName:"webgl",kernelFunc:sU};var Dx=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=oe(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=aU(this.rank),o,s=e.map((i,a)=>`sourceLoc.${Ox[a]} = start[${a}] + coords.${Ox[a]};`);o=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `}},Ox=["x","y","z","w","u","v"];function aU(r){if(r===1)return"sourceLoc";if(r<=6)return Ox.slice(0,r).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var Fx=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=oe(this.rank),n=Me("coords",this.rank),o=Me("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,p)=>`start[${p}]`).join()});`:e.map((c,p)=>`${o[p]} = ${n[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `}};function iU(r,e,t,n){let o=n.texData.get(r.dataId),s=n.makeTensorInfo(t,r.dtype),i=n.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=t,i.dtype=r.dtype;let a=st.computeFlatOffset(e,w.computeStrides(r.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||r.dataId};let u=n.dataRefCount.get(i.slice.origDataId)||1;return n.dataRefCount.set(i.slice.origDataId,u+1),s}function ar(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:i}=n,[a,u]=st.parseSliceParams(o,s,i);if(st.assertParamsValid(o,a,u),w.sizeFromShape(u)===0)return t.makeTensorInfo(u,o.dtype,[]);if(t.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=t.texData.get(o.dataId),m=YS(p.values,a,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,m)}let{isPacked:l}=t.texData.get(o.dataId),c=st.isSliceContinous(o.shape,a,u);if(l||!c){let p=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Fx(u):new Dx(u),m=[a];return t.runWebGLProgram(p,[o],o.dtype,m)}return t.uploadToGPU(o.dataId),iU(o,a,u,t)}var aN={kernelName:zo,backendName:"webgl",kernelFunc:ar};var uU=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:i}=n;w.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((I,_)=>I*_),u=k.getReshaped(o.shape,s,a),l=k.getPermuted(u.length,s.length),c=k.getReshapedPermuted(o.shape,s,a),p=k.getSliceBeginCoords(i,s.length),m=k.getSliceSize(c,i,s.length),f=[],d=V({inputs:{x:o},backend:t,attrs:{shape:u}}),h=Ne({inputs:{x:d},backend:t,attrs:{perm:l}}),g=V({inputs:{x:h},backend:t,attrs:{shape:c}}),y=ar({inputs:{x:g},backend:t,attrs:{begin:p,size:m}});return f.push(d),f.push(h),f.push(g),f.forEach(I=>t.disposeIntermediateTensorInfo(I)),y},iN={kernelName:ua,backendName:"webgl",kernelFunc:uU};function lU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:i}=n,a=t.readSync(o.dataId),u=t.readSync(s.dataId),l=gp(a,u,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,l)}var uN={kernelName:Ll,backendName:"webgl",kernelFunc:lU};var cU="return float(a != b);",Px=fe({opSnippet:cU,cpuKernelImpl:HS,dtype:"bool"}),lN={kernelName:Cn,backendName:"webgl",kernelFunc:Px};function Kr(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.texData.get(n.dataId);return Be({inputs:{x:o.complexTensorInfos.real},backend:t})}var cN={kernelName:Bi,backendName:"webgl",kernelFunc:Kr};var pU="return float(int(x));";function pN(r,e){let t=new St(r.shape,pU),n=e.runWebGLProgram(t,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function Lx(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return Be({inputs:{x:o},backend:t});let i=rr(o.shape),a=Lx({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=kt({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeIntermediateTensorInfo(a),u}if(o.dtype==="complex64"){let i=Kr({inputs:{input:o},backend:t}),a=Lx({inputs:{x:i},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(i),a}if(!w.hasEncodingLoss(o.dtype,s)){let i=Be({inputs:{x:o},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(s==="int32")return pN(o,t);if(s==="bool"){let i=t.makeTensorInfo([],"bool",w.getTypedArrayFromDType("bool",1)),u=Px({inputs:{a:o,b:i},backend:t});return t.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var mN={kernelName:Mr,backendName:"webgl",kernelFunc:Lx};var fN="return ceil(x);",mU=X({opSnippet:fN,packedOpSnippet:fN,cpuKernelImpl:SS}),dN={kernelName:mn,backendName:"webgl",kernelFunc:mU};var Mx=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var Bx=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function fU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:i}=n,a;$().getBool("WEBGL_PACK_CLIP")?a=new Bx(o.shape):a=new Mx(o.shape);let u=[[s],[i]];return t.runWebGLProgram(a,[o],o.dtype,u)}var hN={kernelName:_o,backendName:"webgl",kernelFunc:fU};var Ux=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function gN(r,e){return{dataId:e.dataId,dtype:e.dtype,shape:r.shape}}function dU(r){let{inputs:e,backend:t}=r,{x:n}=e,o=t.texData.get(n.dataId),s=new Ux(n.shape),i=[gN(n,o.complexTensorInfos.real),gN(n,o.complexTensorInfos.imag)];return t.runWebGLProgram(s,i,i[0].dtype)}var xN={kernelName:Ml,backendName:"webgl",kernelFunc:dU};var Wx=class{constructor(e){this.outputShape=[],this.outputShape=k.computeOutShape(e,1),this.variableNames=e.map((i,a)=>`T${a}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){let a=t[i-1];n.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=t.length,s=t[t.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var Vx=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=k.computeOutShape(e,t);let n=this.outputShape,o=n.length,s=oe(o),i=Me("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=e.map((h,g)=>`T${g}`);let u=new Array(e.length-1);u[0]=e[0][t];for(let h=1;h<u.length;h++)u[h]=u[h-1]+e[h][t];let l=a[t],c=a.slice(-2),p=a.join(),m=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let h=1;h<u.length;h++){let g=u[h-1];m+=`
        if (${l} < ${u[h]}  && ${l} >= ${u[h-1]}) {
          return getChannel(
            getT${h}(${Sp(a,l,g)}),
            vec2(${Sp(c,l,g)}));
        }`}let f=u.length,d=u[u.length-1];m+=`
        return getChannel(
          getT${f}(${Sp(a,l,d)}),
          vec2(${Sp(c,l,d)}));`,this.userCode=`
      float getValue(${a.map(h=>"int "+h)}) {
        ${m}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${n[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${n[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${n[o-2]} &&
            ${i[o-1]} < ${n[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function Sp(r,e,t){let n=r.indexOf(e);return r.map((s,i)=>i===n?`${s} - ${t}`:s).join()}function Ps(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.texData.get(n.dataId);return Be({inputs:{x:o.complexTensorInfos.imag},backend:t})}var _N={kernelName:Xl,backendName:"webgl",kernelFunc:Ps};function Ls(r,e,t){let n=r[0].dtype;if(n==="complex64"){let c=r.map(h=>Kr({inputs:{input:h},backend:t})),p=r.map(h=>Ps({inputs:{input:h},backend:t})),m=Ls(c,e,t),f=Ls(p,e,t),d=kt({inputs:{real:m,imag:f},backend:t});return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),p.forEach(h=>t.disposeIntermediateTensorInfo(h)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),d}let o=t.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let c=r.map(y=>{let I=w.sizeFromShape(y.shape.slice(e));return V({inputs:{x:y},backend:t,attrs:{shape:[-1,I]}})}),p=c.map(y=>({vals:t.readSync(y.dataId),shape:y.shape})),m=k.computeOutShape(c.map(y=>y.shape),1),f=c[0].shape[0]===1,d=kS(p,m,n,f),h=k.computeOutShape(r.map(y=>y.shape),e),g=t.makeTensorInfo(h,n,d);return c.forEach(y=>t.disposeIntermediateTensorInfo(y)),g}if(r.length>$().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let c=Math.floor(r.length/2),p=Ls(r.slice(0,c),e,t),m=Ls(r.slice(c),e,t),f=Ls([p,m],e,t);return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),f}if($().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1){let c=new Vx(r.map(p=>p.shape),e);return t.runWebGLProgram(c,r,n)}let{tensors2D:s,outShape:i}=hU(r,e,t),a=new Wx(s.map(c=>c.shape)),u=t.runWebGLProgram(a,s,n);s.forEach(c=>t.disposeIntermediateTensorInfo(c));let l=V({inputs:{x:u},attrs:{shape:i},backend:t});return t.disposeIntermediateTensorInfo(u),l}function hU(r,e,t){let n=k.computeOutShape(r.map(s=>s.shape),e);return{tensors2D:r.map(s=>V({inputs:{x:s},attrs:{shape:[-1,w.sizeFromShape(s.shape.slice(e))]},backend:t})),outShape:n}}function Gx(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=w.parseAxisParam(o,e[0].shape)[0],i=k.computeOutShape(e.map(l=>l.shape),s);if(w.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let a=e.filter(l=>w.sizeFromShape(l.shape)>0);if(a.length===1)return Be({inputs:{x:a[0]},backend:t});let u=a.map(l=>l.shape);return k.assertParamsConsistent(u,s),Ls(a,s,t)}var yN={kernelName:la,backendName:"webgl",kernelFunc:Gx};var Eu=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let i=e.padInfo.top,a=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,p=e.dilationWidth,m=e.filterHeight,f=e.filterWidth,d=Math.floor(e.inChannels/4)*4,h=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,I=g?2:3,_=g?3:1,N="",R="";n&&(o?N=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?N=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:N=`
          float activation(float x) {
            ${n}
          }
        `,R="result = activation(result);");let F=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${N}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${_}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${I}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${d}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${d}) *
                    getW(wR, wC, ${d}, d2);
              } else {
                dotProd +=
                    getX(batch, ${d}, xR, xC) *
                    getW(wR, wC, ${d}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2),
                getW(wR, wC, ${d} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1),
                  getX(batch, xR, xC, ${d} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC),
                  getX(batch, ${d} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${F}
        ${R}
        setOutput(result);
      }
    `}},zx=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,o=e.padInfo.left,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,p=e.filterDepth,m=e.filterHeight,f=e.filterWidth,d=Math.floor(e.inChannels/4)*4,h=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${t}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${d}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${d}) *
                  getW(wF, wR, wC, ${d}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1),
                  getX(batch, xF, xR, xC, ${d} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2),
                  getW(wF, wR, wC, ${d} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var Hx=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length);let{dataFormat:n}=t,o=Ae(),s=n==="channelsLast",i=s?0:1,a=s?1:2,u=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`,l="";for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)l+=`
          blockIndex = rc.y + ${p};
          pos = rc.x + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+p}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+p}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `}};function kp({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let u=r.shape,l=n.texData.get(r.dataId),c=t.inChannels,p=u[0]*u[1]*u[2],m=t.outChannels,f=t.dataFormat==="channelsLast",d=!1,h=!1,g,y=[];if(!((p===1||m===1)&&c>Cx)&&l.isPacked&&f&&l.texture!=null&&u[2]%2!=0&&w.arraysEqual(l.shape.slice(-3),u.slice(-3))){let N=u[0]*u[1]*(u[2]+1),R={dataId:r.dataId,shape:[1,N,t.inChannels],dtype:r.dtype},F=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,w.assert(Es(l.shape,R.shape),()=>`packed reshape ${l.shape} to ${R.shape} isn't free`);let D=V({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(D);let O=Os({a:R,b:D,backend:n,transposeA:d,transposeB:h,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),U=n.texData.get(O.dataId);w.assert(U.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=F,U.shape=t.outShape,g=Be({inputs:{x:O},backend:n}),g.shape=t.outShape,y.push(O)}else{let N=f?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],R=V({inputs:{x:r},backend:n,attrs:{shape:[1,N,t.inChannels]}}),F=V({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),D=Os({a:R,b:F,transposeA:d,transposeB:h,backend:n,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});g=V({inputs:{x:D},backend:n,attrs:{shape:t.outShape}}),y.push(R),y.push(F),y.push(D)}for(let N of y)n.disposeIntermediateTensorInfo(N);return g}function Np({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:u,filterHeight:l,inChannels:c,outWidth:p,outHeight:m,dataFormat:f}=t,d=f==="channelsLast",h=u*l*c,g=m*p,y=[h,g],I=!0,_=!1,N=[],R=V({inputs:{x:r},backend:n,attrs:{shape:r.shape.slice(1)}}),F=V({inputs:{x:e},backend:n,attrs:{shape:[1,h,w.sizeFromShape(e.shape)/h]}});N.push(R),N.push(F);let D=new Hx(y,t),O=[R.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],U=n.runWebGLProgram(D,[R],"float32",O),M=V({inputs:{x:U},backend:n,attrs:{shape:[1,y[0],y[1]]}});N.push(U),N.push(M);let G=o!=null,j=s!=null,ee=a==="leakyrelu",Q=a?Yn(a,!0):null,ie=new ku(M.shape,F.shape,[1,g,t.outChannels],I,_,G,Q,j,ee),le=[M,F];if(o&&le.push(o),j&&le.push(s),ee){let se=n.makeTensorInfo([],"float32",w.createScalarValue(i,"float32"));le.push(se),N.push(se)}let Ce=n.runWebGLProgram(ie,le,"float32"),de=d?[1,m,p,t.outChannels]:[1,t.outChannels,m,p],Qe=V({inputs:{x:Ce},backend:n,attrs:{shape:de}});N.push(Ce);for(let se of N)n.disposeIntermediateTensorInfo(se);return Qe}function gU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n,p=k.convertConv2DDataFormat(u),m=k.computeConv2DInfo(o.shape,s.shape,i,l,a,c,!1,p),f;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))f=kp({x:o,filter:s,convInfo:m,backend:t});else if($().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)f=Np({x:o,filter:s,convInfo:m,backend:t});else{let h=new Eu(m);f=t.runWebGLProgram(h,[o,s],"float32")}let d=V({inputs:{x:f},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(f),d}var bN={kernelName:yo,backendName:"webgl",kernelFunc:gU};var jx=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${i}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},qx=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,i=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,u=n-1-e.padInfo.left,l=i?1:2,c=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Kx=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,s=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Xx=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=t-1-e.padInfo.front,l=n-1-e.padInfo.top,c=o-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function xU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=n,p=k.convertConv2DDataFormat(u),m=k.computeConv2DInfo(o.shape,c,i,1,a,l,!1,p),f=new jx(m);return t.runWebGLProgram(f,[o,s],"float32")}var wN={kernelName:Bl,backendName:"webgl",kernelFunc:xU};function _U(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=n,p=k.convertConv2DDataFormat(l),m=k.computeConv2DInfo(i,s.shape,a,1,u,c,!1,p),f=new qx(m);return t.runWebGLProgram(f,[o,s],"float32")}var vN={kernelName:bo,backendName:"webgl",kernelFunc:_U};function yU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dilations:u}=n,l=k.computeConv3DInfo(o.shape,s.shape,i,u,a),c=new zx(l);return t.runWebGLProgram(c,[o,s],"float32")}var IN={kernelName:Ul,backendName:"webgl",kernelFunc:yU};function bU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:i,pad:a,filterShape:u}=n,l=k.computeConv3DInfo(o.shape,u,i,1,a),c=new Kx(l);return t.runWebGLProgram(c,[o,s],"float32")}var CN={kernelName:Nb,backendName:"webgl",kernelFunc:bU};function wU(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{pad:i,strides:a,inputShape:u}=n,l=k.computeConv3DInfo(u,s.shape,a,1,i),c=new Xx(l);return t.runWebGLProgram(c,[o,s],"float32")}var TN={kernelName:Eb,backendName:"webgl",kernelFunc:wU};var vU=wp+`
  return cos(x);
`,IU=X({opSnippet:vU}),SN={kernelName:ca,backendName:"webgl",kernelFunc:IU};var CU=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,TU=X({opSnippet:CU}),kN={kernelName:pa,backendName:"webgl",kernelFunc:TU};var Yx=class{constructor(e,t,n,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,u,l]=e,[c]=t,[p,m]=n;this.outputShape=[c,p,m,l];let f=o==="bilinear"?1:0,[d,h]=[`${a-1}.0`,`${u-1}.0`],[g,y,I]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[_,N,R]=m>1?[`${(u-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${_});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${N};

        float in_y = ${I};
        if( in_y < 0.0 || in_y > ${d} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${R};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var SU=r=>{let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:i}=e,{cropSize:a,method:u,extrapolationValue:l}=n,c=new Yx(o.shape,s.shape,a,u,l);return t.runWebGLProgram(c,[o,s,i],"float32")},NN={kernelName:vo,backendName:"webgl",kernelFunc:SU};var Ep=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;let o=e.length,s=t?"0.0":`getX(${EN(o,"coords")})`,i=e[e.length-1],a="",u="";t?(a=n?`end != ${i-1}`:"end != 0",u=n?"end + 1":"end - 1"):(a=n?`end + pow2 < ${i}`:"end >= pow2",u=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${oe(o)} coords = getOutputCoords();
        int end = ${AN(o,"coords")};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${a}) {
          int idx = ${u};
          ${AN(o,"coords")} = idx;
          val += getX(${EN(o,"coords")});
        }
        setOutput(val);
      }
    `}};function EN(r,e){if(r===1)return`${e}`;if(r===2)return`${e}.x, ${e}.y`;if(r===3)return`${e}.x, ${e}.y, ${e}.z`;if(r===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function AN(r,e){if(r===1)return`${e}`;if(r===2)return`${e}.y`;if(r===3)return`${e}.z`;if(r===4)return`${e}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function kU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length,l=k.getAxesPermutation([s],u),c=o;l!=null&&(c=Ne({inputs:{x:o},backend:t,attrs:{perm:l}}));let p=k.getInnerMostAxes(1,u)[0];if(p!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${o.shape.length-1} but got axis=${s}`);let m=c.shape[p],f=Be({inputs:{x:c},backend:t});for(let d=0;d<=Math.ceil(Math.log2(m))-1;d++){let h=new Ep(c.shape,!1,a),g=[[d]],y=f;f=t.runWebGLProgram(h,[f],f.dtype,g),t.disposeIntermediateTensorInfo(y)}if(i){let d=new Ep(c.shape,i,a),h=f;f=t.runWebGLProgram(d,[f],f.dtype),t.disposeIntermediateTensorInfo(h)}if(l!=null){let d=k.getUndoAxesPermutation(l),h=Ne({inputs:{x:f},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(c),h}return f}var RN={kernelName:wo,backendName:"webgl",kernelFunc:kU};function NU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=t.readSync(o.dataId),l=t.readSync(s.dataId),c=gp(u,l,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let u=t.bufferSync(o),l=t.bufferSync(s),c=TS(u,l,i,a);return t.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var $N={kernelName:Wl,backendName:"webgl",kernelFunc:NU};var Jx=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function EU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:i}=n;w.assert(s>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${s}`);let a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=u*s,m=l*s,f=c/(s*s),d=i==="NHWC"?[a,p,m,f]:[a,f,p,m],h=new Jx(d,s,i);return t.runWebGLProgram(h,[o],o.dtype)}var DN={kernelName:Io,backendName:"webgl",kernelFunc:EU};var Au=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Fe(this.outputShape.length);let i=e.filterHeight,a=e.filterWidth,u=e.outChannels/e.inChannels,l="",c="";n&&(o?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");let p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `}};var Ru=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Fe(this.outputShape.length);let i=e.outChannels/e.inChannels,a=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,p=e.filterWidth,m=p,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<p;y++)f+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;for(let y=0;y<c;y++){for(let I=0;I<p;I++)f+=`
          xTexelC${I*2} = vec4(0.0);
          xTexelC${I*2}Ready = 0;
          xTexelC${I*2+1} = vec4(0.0);
          xTexelC${I*2+1}Ready = 0;
          xC${I} = vec4(0.0);`;f+=`
        xR = xRCorner + ${y} * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let I=0;I<(m+1)/2;I++){let _=I*2;if(f+=`
          xC = xCCorner + ${_*l};
          `,u===1){if(_<p&&(a%2==1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_}Ready == 0) {
                  xTexelC${_} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${_}.zw = vec2(0.0);
                  }
                  xTexelC${_}Ready = 1;
                }
              `,l===1&&_>0?f+=`
                xC${_} = vec4(xTexelC${_-2}.zw, xTexelC${_}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${_} = vec4(previous.zw, xTexelC${_}.xy);
                  } else {
                    xC${_} = vec4(0.0, 0.0, xTexelC${_}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${_}Ready == 0) {
                  xTexelC${_} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${_}.zw = vec2(0.0);
                  }
                  xTexelC${_}Ready = 1;
                }

                xC${_} = xTexelC${_};
                `,_+1<p)){let N=a%2==0?w.nearestLargerEven(l):l;l%2==0&&a%2==1||l%2!=0&&a%2!=1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${N};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {
                    xTexelC${_+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${_+1}.zw = vec2(0.0);
                    }
                    xTexelC${_+1}Ready = 1;
                  }
                  `,l>1&&(f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_}Ready == 0) {
                      xTexelC${_} = getX(batch, xR, xCOffset, d1);
                      xTexelC${_}Ready = 1;
                    }
                    `),f+=`
                  xC${_+1} = vec4(xTexelC${_}.zw, xTexelC${_+1}.xy);
                  `):N===1?f+=`
                    xC${_+1} = xTexelC${_};
                    `:f+=`
                    xCOffset = xC + ${N};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {
                      xTexelC${_+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${_+1}.zw = vec2(0.0);
                      }
                      xTexelC${_+1}Ready = 1;
                    }

                    xC${_+1} = xTexelC${_+1};
                    `}}else _<p&&(a%2==1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_}Ready == 0) {
                  xTexelC${_} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${_}.zw = vec2(0.0);
                  }
                  xTexelC${_}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${_+1}Ready == 0) {
                  xTexelC${_+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${_+1}.zw = vec2(0.0);
                  }
                  xTexelC${_+1}Ready = 1;
                }

                xC${_} = vec4(xTexelC${_}.zw, xTexelC${_+1}.zw);
              `,_+1<p&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${_+1} = vec4(xTexelC${_+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${_}Ready == 0) {
                  xTexelC${_} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${_}.zw = vec2(0.0);
                  }
                  xTexelC${_}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {
                  xTexelC${_+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${_+1}.zw = vec2(0.);
                  }
                  xTexelC${_+1}Ready = 1;
                }

                xC${_} = vec4(
                  xTexelC${_}.xy, xTexelC${_+1}.xy);
              `,_+1<p&&(f+=`
                  xC${_+1} = vec4(xTexelC${_}.zw, xTexelC${_+1}.zw);
                `)));_<p&&(f+=`
            wTexel = getW(${y}, ${_}, d1, q);
            dotProd += xC${_} * vec4(wTexel.xz, wTexel.xz);
          `,_+1<p&&(f+=`
              wTexel = getW(${y}, ${_+1}, d1, q);
              dotProd += xC${_+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
        }
      `}let d="",h="";n&&(o?d=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?d=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:d=`vec4 activation(vec4 x) {
          ${n}
        }`,h="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function AU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n,c=u;c==null&&(c=[1,1]),w.assert(k.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let p=k.computeConv2DInfo(o.shape,s.shape,i,c,a,l,!0),m;$().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?m=new Ru(p):m=new Au(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return t.runWebGLProgram(m,[o,s],"float32",f)}var ON={kernelName:Co,backendName:"webgl",kernelFunc:AU};var Qx=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Zx=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,i=t-1-e.padInfo.top,a=n-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function RU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=n,p=k.computeConv2DInfo(o.shape,c,i,a,u,l,!0),m=new Qx(p);return t.runWebGLProgram(m,[o,s],"float32")}var FN={kernelName:Vl,backendName:"webgl",kernelFunc:RU};function $U(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=n,p=k.computeConv2DInfo(c,s.shape,i,a,u,l,!0),m=new Zx(p);return t.runWebGLProgram(m,[o,s],"float32")}var PN={kernelName:Gl,backendName:"webgl",kernelFunc:$U};var e_=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function DU(r){let{inputs:e,backend:t}=r,{x:n}=e,o=[...n.shape,...n.shape],s=w.sizeFromShape(n.shape),i=V({inputs:{x:n},backend:t,attrs:{shape:[s]}}),a=new e_(s),u=t.runWebGLProgram(a,[i],i.dtype),l=V({inputs:{x:u},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),l}var LN={kernelName:Ab,backendName:"webgl",kernelFunc:DU};var t_=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:u,dilationHeight:l,dilationWidth:c}=e,{top:p,left:m}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function OU(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dilations:u}=n,l=k.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",u),c,p=new t_(l);c=t.runWebGLProgram(p,[o,s],"float32");let m=V({inputs:{x:c},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(c),m}var MN={kernelName:zl,backendName:"webgl",kernelFunc:OU};function FU(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:i,summedDims:a,idDims:u}=k.decodeEinsumEquation(o,s.length);k.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:c}=k.getEinsumComputePath(a,u),p=c.length,m=null,f=i.length,d=[];for(let h=0;h<p;++h){for(let g of c[h]){let{permutationIndices:y,expandDims:I}=k.getEinsumPermutation(f,u[g]),_;k.isIdentityPermutation(y)?_=s[g]:(_=Ne({inputs:{x:s[g]},backend:t,attrs:{perm:y}}),d.push(_));let N=_.shape.slice();for(let R=0;R<I.length;++R)N.splice(I[R],0,1);w.arraysEqual(_.shape,N)||(_=V({inputs:{x:_},backend:t,attrs:{shape:N}}),d.push(_)),m===null?m=_:(m=Nu({inputs:{a:_,b:m},backend:t}),d.push(m))}h<p-1&&(l[h]>=0&&(m=Ds({inputs:{x:m},backend:t,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&t.disposeIntermediateTensorInfo(h);return m}var BN={kernelName:Hl,backendName:"webgl",kernelFunc:FU};var PU="return (x >= 0.0) ? x : (exp(x) - 1.0);",LU=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,MU=X({opSnippet:PU,packedOpSnippet:LU}),UN={kernelName:fa,backendName:"webgl",kernelFunc:MU};var BU="return (b >= 1.0) ? a : a * (b + 1.0);",UU=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,WU=r=>{let{inputs:e,backend:t}=r,{dy:n,y:o}=e,s=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sr(UU,n.shape,o.shape):new Kt(BU,n.shape,o.shape);return t.runWebGLProgram(s,[n,o],n.dtype)},WN={kernelName:Rb,backendName:"webgl",kernelFunc:WU};var VU=`
  return vec4(equal(a, b));
`,GU="return float(a == b);",zU=fe({opSnippet:GU,packedOpSnippet:VU,dtype:"bool",cpuKernelImpl:NS}),VN={kernelName:fn,backendName:"webgl",kernelFunc:zU};var HU=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${k.ERF_P};
  float a1 = ${k.ERF_A1};
  float a2 = ${k.ERF_A2};
  float a3 = ${k.ERF_A3};
  float a4 = ${k.ERF_A4};
  float a5 = ${k.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,jU=X({opSnippet:HU}),GN={kernelName:jl,backendName:"webgl",kernelFunc:jU};var zN="return exp(x);",r_=X({opSnippet:zN,packedOpSnippet:zN,cpuKernelImpl:ES}),HN={kernelName:dn,backendName:"webgl",kernelFunc:r_};function Ap(r){let{inputs:e,attrs:t,backend:n}=r,{dim:o}=t,{input:s}=e,i=s.shape.length,a=s.shape.slice(),u=o;return o<0&&(w.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+o+1),a.splice(u,0,1),V({inputs:{x:s},backend:n,attrs:{shape:a}})}var jN={kernelName:da,backendName:"webgl",kernelFunc:Ap};var qN="return exp(x) - 1.0;",qU=X({opSnippet:qN,packedOpSnippet:qN,cpuKernelImpl:AS}),KN={kernelName:ha,backendName:"webgl",kernelFunc:qU};var Rp=class{constructor(e,t,n){this.variableNames=["real","imag"];let o=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${o}.0`:"1.0",a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function $p(r,e,t){let n=t.texData.get(r.dataId),o=w.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=V({inputs:{x:r},backend:t,attrs:{shape:[i,s]}}),u=a.shape,l=new Rp("real",u,e),c=new Rp("imag",u,e),p=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],m=t.runWebGLProgram(l,p,"float32"),f=t.runWebGLProgram(c,p,"float32"),d=kt({inputs:{real:m,imag:f},backend:t});t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f);let h=V({inputs:{x:d},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(d),h}function KU(r){let{inputs:e,backend:t}=r,{input:n}=e;return $p(n,!1,t)}var XN={kernelName:ql,backendName:"webgl",kernelFunc:KU};var n_=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Xr(r){let{backend:e,attrs:t}=r,{shape:n,value:o}=t,{dtype:s}=t;if(s=s||w.inferDtype(o),s==="string"){let i=w.getArrayFromDType(s,w.sizeFromShape(n));return i.fill(o),e.makeTensorInfo(n,s,i)}else{let i=new n_(n,o),a=[[o]];return e.runWebGLProgram(i,[],s,a)}}var YN={kernelName:ga,backendName:"webgl",kernelFunc:Xr};var o_=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var JN={kernelName:To,backendName:"webgl",kernelFunc:({inputs:r,backend:e})=>{let{image:t}=r,n=e,o=new o_(t.shape);return n.runWebGLProgram(o,[t],t.dtype)}};var QN="return floor(x);",XU=X({opSnippet:QN,packedOpSnippet:QN,cpuKernelImpl:RS}),ZN={kernelName:hn,backendName:"webgl",kernelFunc:XU};var YU=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,JU=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,QU=fe({opSnippet:YU,packedOpSnippet:JU,dtype:"int32"}),eE={kernelName:xa,backendName:"webgl",kernelFunc:QU};var s_=class{constructor(e){this.variableNames=["A"];let t=Ae(),[n,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var a_=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=Ae(),[n,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}};var tE={kernelName:Ui,backendName:"webgl",kernelFunc:ZU},mi;function ZU(r){let{inputs:e,backend:t,attrs:n}=r,{pixels:o}=e,{numChannels:s}=n,i=typeof HTMLVideoElement!="undefined"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement,[u,l]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[l,u],p=[l,u,s];(a||i)&&(mi==null&&(mi=document.createElement("canvas").getContext("2d")),mi.canvas.width=u,mi.canvas.height=l,mi.drawImage(o,0,0,u,l),o=mi.canvas);let m=t.makeTensorInfo(c,"int32");t.texData.get(m.dataId).usage=at.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),o);let f=$().getBool("WEBGL_PACK")?new a_(p):new s_(p),d=t.runWebGLProgram(f,[m],"int32");return t.disposeData(m.dataId),d}function eW(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=k.convertConv2DDataFormat(c),g=k.computeConv2DInfo(o.shape,s.shape,u,p,l,m,!1,h),y,I=[];if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=kp({x:o,filter:s,convInfo:g,backend:t,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:d});else if($().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)y=Np({x:o,filter:s,convInfo:g,backend:t,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:d});else{let N=i!=null,R=a!=null,F=f==="leakyrelu",D=f?Yn(f,!1):null,O=new Eu(g,N,D,R,F),U=[o,s];if(i&&U.push(i),a&&U.push(a),F){let M=t.makeTensorInfo([],"float32",w.createScalarValue(d,"float32"));U.push(M),I.push(M)}y=t.runWebGLProgram(O,U,"float32")}let _=V({inputs:{x:y},backend:t,attrs:{shape:g.outShape}});return I.push(y),I.forEach(N=>t.disposeIntermediateTensorInfo(N)),_}var rE={kernelName:$n,backendName:"webgl",kernelFunc:eW};function tW(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:c,dimRoundingMode:p,activation:m,leakyreluAlpha:f}=n,d=[],h=c;h==null&&(h=[1,1]),w.assert(k.eitherStridesOrDilationsAreOne(u,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${h}'`);let g=k.computeConv2DInfo(o.shape,s.shape,u,h,l,p,!0),y=$().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,I=m?Yn(m,y):null,_=[o,s],N=i!=null,R=a!=null,F=m==="leakyrelu";if(N&&_.push(i),R&&_.push(a),F){let M=t.makeTensorInfo([],"float32",w.createScalarValue(f,"float32"));_.push(M),d.push(M)}let D;y?D=new Ru(g,N,I,R,F):D=new Au(g,N,I,R,F);let O=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],U=t.runWebGLProgram(D,_,"float32",O);return d.forEach(M=>t.disposeIntermediateTensorInfo(M)),U}var nE={kernelName:Dn,backendName:"webgl",kernelFunc:tW};var i_=class{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;let o=oe(t.length),s=oe(n.length),i=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${o} strides = ${o}(${this.strides});
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${i};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}};function rW(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=o.shape,i=s[s.length-1],a=w.sizeFromShape(n.shape),[u,l,c,p]=k.prepareAndValidate(n,o),m=V({inputs:{x:o},backend:t,attrs:{shape:[l,i]}}),f=V({inputs:{x:n},backend:t,attrs:{shape:[w.sizeFromShape(n.shape)/c,c]}});if(t.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let y=t.readSync(o.dataId),I=t.bufferSync(n),_=$S(y,I,n.dtype,l,i,c,p,n.shape,a);return t.makeTensorInfo(u,n.dtype,_.values)}let d=new i_(i,p,[l,c]),h=t.runWebGLProgram(d,[f,m],f.dtype),g=V({inputs:{x:h},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),g}var oE={kernelName:ko,backendName:"webgl",kernelFunc:rW};var u_=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=oe(this.rank),o=nW(e,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}};function nW(r,e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push("int(getIndices(resRC.x, resRC.z))"):n.push(`${t[o]}`);return n.join()}function l_(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:i,batchDims:a}=n,u=w.parseAxisParam(i,o.shape)[0],l=k.segment_util.collectGatherOpShapeInfo(o,s,u,a),c=w.sizeFromShape(s.shape),p=[],m=V({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=V({inputs:{x:s},backend:t,attrs:{shape:[l.batchSize,c/l.batchSize]}});p.push(m),p.push(f);let d=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let I=t.bufferSync(f),_=t.bufferSync(m),N=DS(_,I,d);return p.forEach(R=>t.disposeIntermediateTensorInfo(R)),t.makeTensorInfo(l.outputShape,N.dtype,N.values)}let h=new u_(m.shape,d),g=t.runWebGLProgram(h,[m,f],m.dtype);p.push(g);let y=V({inputs:{x:g},backend:t,attrs:{shape:l.outputShape}});return p.forEach(I=>t.disposeIntermediateTensorInfo(I)),y}var sE={kernelName:_a,backendName:"webgl",kernelFunc:l_};var oW="return float(a > b);",sW=`
  return vec4(greaterThan(a, b));
`,aW=fe({opSnippet:oW,packedOpSnippet:sW,cpuKernelImpl:OS,dtype:"bool"}),aE={kernelName:gn,backendName:"webgl",kernelFunc:aW};var iW="return float(a >= b);",uW=`
  return vec4(greaterThanEqual(a, b));
`,lW=fe({opSnippet:iW,packedOpSnippet:uW,dtype:"bool",cpuKernelImpl:FS}),iE={kernelName:xn,backendName:"webgl",kernelFunc:lW};function cW(r){let{inputs:e,backend:t}=r,{input:n}=e;return $p(n,!0,t)}var uE={kernelName:Kl,backendName:"webgl",kernelFunc:cW};var pW="return float(!isnan(x) && !isinf(x));",mW=X({opSnippet:pW,dtype:"bool"}),lE={kernelName:$b,backendName:"webgl",kernelFunc:mW};var fW="return float(isinf(x));",dW=X({opSnippet:fW,dtype:"bool"}),cE={kernelName:Db,backendName:"webgl",kernelFunc:dW};var hW="return float(isnan(x));",gW=X({opSnippet:hW,dtype:"bool"}),pE={kernelName:Yl,backendName:"webgl",kernelFunc:gW};var xW="return float(a < b);",_W=`
  return vec4(lessThan(a, b));
`,yW=fe({opSnippet:xW,packedOpSnippet:_W,cpuKernelImpl:PS,dtype:"bool"}),mE={kernelName:_n,backendName:"webgl",kernelFunc:yW};var bW="return float(a <= b);",wW=`
  return vec4(lessThanEqual(a, b));
`,vW=fe({opSnippet:bW,packedOpSnippet:wW,cpuKernelImpl:LS,dtype:"bool"}),fE={kernelName:yn,backendName:"webgl",kernelFunc:vW};function IW(r){let{backend:e,attrs:t}=r,{start:n,stop:o,num:s}=t,i=MS(n,o,s);return e.makeTensorInfo([i.length],"float32",i)}var dE={kernelName:Jl,backendName:"webgl",kernelFunc:IW};var CW=`if (x < 0.0) return NAN;
  return log(x);`,TW=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,SW=X({opSnippet:CW,packedOpSnippet:TW,cpuKernelImpl:BS}),hE={kernelName:bn,backendName:"webgl",kernelFunc:SW};var kW="return log(1.0 + x);",NW=X({opSnippet:kW}),gE={kernelName:Ql,backendName:"webgl",kernelFunc:NW};var EW="return float(a >= 1.0 && b >= 1.0);",AW=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,RW=fe({opSnippet:EW,packedOpSnippet:AW,dtype:"bool"}),xE={kernelName:ya,backendName:"webgl",kernelFunc:RW};var $W="return float(!(x >= 1.0));",DW=X({opSnippet:$W}),_E={kernelName:Zl,backendName:"webgl",kernelFunc:DW};var OW="return float(a >= 1.0 || b >= 1.0);",FW=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,PW=fe({opSnippet:OW,packedOpSnippet:FW,dtype:"bool"}),yE={kernelName:ec,backendName:"webgl",kernelFunc:PW};var c_=class{constructor(e,t,n,o,s){this.variableNames=["x"],this.outputShape=[];let i=t,a=e[3]-1;this.outputShape=e;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};var p_=class{constructor(e,t,n,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=t,a=e[3]-1;this.outputShape=e;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}};var LW=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{depthRadius:s,bias:i,alpha:a,beta:u}=n,l=$().getBool("WEBGL_PACK_NORMALIZATION")?new p_(o.shape,s,i,a,u):new c_(o.shape,s,i,a,u);return t.runWebGLProgram(l,[o],o.dtype)},bE={kernelName:tc,backendName:"webgl",kernelFunc:LW};var m_=class{constructor(e,t,n,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var MW=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o,y:s,dy:i}=e,{depthRadius:a,bias:u,alpha:l,beta:c}=n,p=new m_(o.shape,a,u,l,c);return t.runWebGLProgram(p,[o,s,i],o.dtype)},wE={kernelName:Ob,backendName:"webgl",kernelFunc:MW};function vE(r,e,t,n){let o=w.sizeFromShape(e),i=w.sizeFromShape(r.shape)/o,a=V({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=Ot(a,r.dtype,"max",n),l=V({inputs:{x:u},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}function f_(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:i}=n,a=o.shape.length,u=w.parseAxisParam(s,o.shape),l=u,c=k.getAxesPermutation(l,a),p=c!=null,m=t.shouldExecuteOnCPU([o]),f=o;if(p){if(m){let _=t.texData.get(f.dataId).values,N=new Array(a);for(let D=0;D<N.length;D++)N[D]=o.shape[c[D]];let R=$s(_,o.shape,o.dtype,c,N);f=t.makeTensorInfo(N,o.dtype);let F=t.texData.get(f.dataId);F.values=R}else f=Jn(o,c,t);l=k.getInnerMostAxes(l.length,a)}k.assertAxesAreInnerMostDims("max",l,a);let[d,h]=k.computeOutAndReduceShapes(f.shape,l),g=d;i&&(g=k.expandShapeToKeepDim(d,u));let y;if(m){let _=t.texData.get(f.dataId).values,N=US(_,w.sizeFromShape(h),g,o.dtype);y=t.makeTensorInfo(g,o.dtype);let R=t.texData.get(y.dataId);R.values=N}else y=vE(f,h,g,t);return p&&t.disposeIntermediateTensorInfo(f),y}var IE={kernelName:Eo,backendName:"webgl",kernelFunc:f_};var BW=bp+`
  return max(a, b);
`,UW=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Xn+`
  return result;
`,WW=fe({opSnippet:BW,packedOpSnippet:UW,cpuKernelImpl:WS}),CE={kernelName:wn,backendName:"webgl",kernelFunc:WW};function VW(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;Cr(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;w.assert(k.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=k.computePool2DInfo(o.shape,s,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&w.arraysEqual(c.inShape,c.outShape))return Be({inputs:{x:o},backend:t});let p=new Tr(c,"max",!1);return t.runWebGLProgram(p,[o],o.dtype)}var TE={kernelName:Ao,backendName:"webgl",kernelFunc:VW};function GW(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=n,c=[1,1,1],p=k.computePool3DInfo(o.shape,s,i,c,a,l,u),m=new Fs(p,"max",!1);return t.runWebGLProgram(m,[o],o.dtype)}var SE={kernelName:rc,backendName:"webgl",kernelFunc:GW};var d_=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,o=e.dilationHeight,s=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=s-1-e.padInfo.top,u=i-1-e.padInfo.left,l=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},h_=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterDepth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,p=u-1-e.padInfo.front,m=l-1-e.padInfo.top,f=c-1-e.padInfo.left,d=u*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${d} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function zW(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],m=k.computePool3DInfo(i.shape,a,u,p,l,c),f=new Fs(m,"max",!0),d=t.runWebGLProgram(f,[i],i.dtype),h=new h_(m),g=t.runWebGLProgram(h,[o,d],i.dtype);return t.disposeIntermediateTensorInfo(d),g}var kE={kernelName:Pb,backendName:"webgl",kernelFunc:zW};function HW(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s,output:i}=e,a=s;Cr([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=n,m=k.computePool2DInfo(a.shape,u,l,1,c,p),f=!0,d=new Tr(m,"max",f),h=t.runWebGLProgram(d,[a],a.dtype),g=new d_(m),y=t.runWebGLProgram(g,[o,h],a.dtype);return t.disposeIntermediateTensorInfo(h),y}var NE={kernelName:Fb,backendName:"webgl",kernelFunc:HW};function EE(r,e,t,n){let o=new Tr(t,"max",!1),s=n.runWebGLProgram(o,[r],"float32");o=new Tr(t,"max",!0,!0,e);let i=n.runWebGLProgram(o,[r],"float32");return[s,i]}var AE={kernelName:nc,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=e,u=t;w.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let l=[1,1];w.assert(k.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let c=k.computePool2DInfo(n.shape,o,s,l,i),[p,m]=EE(n,a,c,u);return[p,m]}};function RE(r,e,t,n){let o=w.sizeFromShape(e),i=w.sizeFromShape(r.shape)/o,a=V({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=Ot(a,"float32","mean",n),l=V({inputs:{x:u},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}var $E={kernelName:Ro,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{keepDims:o,axis:s}=e,i=t,a=n.shape.length,u=w.parseAxisParam(s,n.shape),l=u,c=k.getAxesPermutation(l,a),p=c!=null,m=i.shouldExecuteOnCPU([n]),f=[],d=n;if(p){if(m){let N=i.texData.get(d.dataId).values,R=new Array(a);for(let O=0;O<R.length;O++)R[O]=n.shape[c[O]];let F=$s(N,n.shape,n.dtype,c,R);d=i.makeTensorInfo(R,n.dtype);let D=i.texData.get(d.dataId);D.values=F}else d=Jn(n,c,i);f.push(d),l=k.getInnerMostAxes(l.length,a)}k.assertAxesAreInnerMostDims("sum",l,a);let[h,g]=k.computeOutAndReduceShapes(d.shape,l),y=h;o&&(y=k.expandShapeToKeepDim(h,u));let I=RE(d,g,y,i);for(let _ of f)i.disposeIntermediateTensorInfo(_);return I}};function jW(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n,a=o.shape.length,u=w.parseAxisParam(s,o.shape),l=u,c=k.getAxesPermutation(l,a),p=o;c!=null&&(p=Ne({inputs:{x:o},backend:t,attrs:{perm:c}}),l=k.getInnerMostAxes(l.length,o.shape.length)),k.assertAxesAreInnerMostDims("min",l,a);let[m,f]=k.computeOutAndReduceShapes(p.shape,l),d=w.sizeFromShape(f),h=V({inputs:{x:p},backend:t,attrs:{shape:[-1,d]}}),g=Ot(h,h.dtype,"min",t),y;if(i){let I=k.expandShapeToKeepDim(m,u);y=V({inputs:{x:g},backend:t,attrs:{shape:I}})}else y=V({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(p),y}var DE={kernelName:$o,backendName:"webgl",kernelFunc:jW};var qW=bp+`
  return min(a, b);
`,KW=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Xn+`
  return result;
`,XW=fe({opSnippet:qW,packedOpSnippet:KW,cpuKernelImpl:VS}),OE={kernelName:vn,backendName:"webgl",kernelFunc:XW};var g_=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((c,p)=>c[0]+e[p]+c[1]);let o=e.length,s=oe(o),i=t.map(c=>c[0]).join(","),a=t.map((c,p)=>c[0]+e[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),l=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};var x_=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((d,h)=>d[0]+e[h]+d[1]);let o=e.length,s=oe(o),i=t.map(d=>d[0]).join(","),a=t.map((d,h)=>d[0]+e[h]).join(","),u=Me("rc",o),l=Me("source",o),c=`${u[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,m=n==="reflect"?0:1,f="";if(o===1){let d=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
      `}else{let d=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
        rc = outputLoc;
        ${u[o-2]} += 1;
        if(${u[o-2]} < ${this.outputShape[o-2]}) {
          ${d}
          result[2] = getChannel(getX(${l.join()}), ${p});
          ${u[o-1]} += 1;
          if(${c}) {
            ${d}
            result[3] = getChannel(getX(${l.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var YW=({inputs:r,backend:e,attrs:t})=>{let{x:n}=r,{paddings:o,mode:s}=t,i=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new x_(n.shape,o,s):new g_(n.shape,o,s);return e.runWebGLProgram(i,[n],n.dtype)},FE={kernelName:Do,backendName:"webgl",kernelFunc:YW};var JW=`if (b == 0.0) return NAN;
  return mod(a, b);`,QW=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+Xn+`
  return result;
`,ZW=fe({opSnippet:JW,packedOpSnippet:QW}),PE={kernelName:oc,backendName:"webgl",kernelFunc:ZW};var __=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};var e4=`
if (a == b) {
  return 1.0;
};
return a / b;`,t4=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,y_=fe({opSnippet:e4,packedOpSnippet:t4,checkOutOfBounds:!0}),LE={kernelName:ma,backendName:"webgl",kernelFunc:y_};var ME="return a - b;",b_=fe({opSnippet:ME,packedOpSnippet:ME,supportsComplex:!0,cpuKernelImpl:ok}),BE={kernelName:An,backendName:"webgl",kernelFunc:b_};function w_(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,i=w.parseAxisParam([s],o.shape),a=f_({inputs:{x:o},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),u=k.expandShapeToKeepDim(a.shape,i),l=V({inputs:{x:a},backend:t,attrs:{shape:u}}),c=b_({inputs:{a:o,b:l},backend:t}),p=r_({inputs:{x:c},backend:t}),m=Ds({inputs:{x:p},backend:t,attrs:{axis:i,keepDims:!1}}),f=V({inputs:{x:m},backend:t,attrs:{shape:u}}),d=y_({inputs:{a:p,b:f},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),d}var UE={kernelName:jo,backendName:"webgl",kernelFunc:w_};function r4(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{numSamples:s,seed:i,normalized:a}=n,u=a?o:w_({inputs:{logits:o},backend:t,attrs:{dim:o.shape.length-1}}),l=u.shape[0],c=u.shape[1],p=new __(l,c,s),m=[[i]],f=t.runWebGLProgram(p,[u],"int32",m);return a||t.disposeIntermediateTensorInfo(u),f}var WE={kernelName:sc,backendName:"webgl",kernelFunc:r4};var VE="return -x;";function n4(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])){let s=t.texData.get(n.dataId),[i,a]=zS(s.values,n.shape,n.dtype);return t.makeTensorInfo(a,n.dtype,i)}let o;return $().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new or(n.shape,VE):o=new St(n.shape,VE),t.runWebGLProgram(o,[n],n.dtype)}var GE={kernelName:Oo,backendName:"webgl",kernelFunc:n4};var o4=wr.nonMaxSuppressionV3Impl;function s4(r){k.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n,l=t.readSync(o.dataId),c=t.readSync(s.dataId),{selectedIndices:p}=o4(l,c,i,a,u);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}var zE={kernelName:Fo,backendName:"webgl",kernelFunc:s4};var a4=wr.nonMaxSuppressionV4Impl;function i4(r){k.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n,c=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:m,validOutputs:f}=a4(c,p,i,a,u,l);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var HE={kernelName:Po,backendName:"webgl",kernelFunc:i4};var u4=wr.nonMaxSuppressionV5Impl;function l4(r){k.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n,c=t.readSync(o.dataId),p=t.readSync(s.dataId),m=i,f=a,d=u,h=l,{selectedIndices:g,selectedScores:y}=u4(c,p,m,f,d,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var jE={kernelName:Lo,backendName:"webgl",kernelFunc:l4};var v_=class{constructor(e,t,n,o){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var c4=r=>{let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{depth:s,onValue:i,offValue:a}=n,u=w.sizeFromShape(o.shape),l=new v_(u,s,i,a),c=V({inputs:{x:o},backend:t,attrs:{shape:[u]}}),p=t.runWebGLProgram(l,[c],o.dtype);t.disposeIntermediateTensorInfo(c);let m=[...o.shape,s],f=V({inputs:{x:p},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(p),f},qE={kernelName:Mo,backendName:"webgl",kernelFunc:c4};function $u(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="complex64"){let o=Kr({inputs:{input:n},backend:t}),s=$u({inputs:{x:o},backend:t}),i=Ps({inputs:{input:n},backend:t}),a=$u({inputs:{x:i},backend:t}),u=kt({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),u}else return Xr({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}var KE={kernelName:Fa,backendName:"webgl",kernelFunc:$u};function XE(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=Kr({inputs:{input:n},backend:t}),s=XE({inputs:{x:o},backend:t}),i=Ps({inputs:{input:n},backend:t}),a=$u({inputs:{x:i},backend:t}),u=kt({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),u}else return Xr({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:t})}var YE={kernelName:ba,backendName:"webgl",kernelFunc:XE};function p4(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return Ap({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,i=e[0].dtype;e.forEach(c=>{w.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=e.map(c=>{let p=Ap({inputs:{input:c},backend:t,attrs:{dim:o}});return a.push(p),p}),l=Gx({inputs:u,backend:t,attrs:{axis:o}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),l}var JE={kernelName:wa,backendName:"webgl",kernelFunc:p4};var I_=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,c)=>l[0]+e[c]+l[1]);let o=e.length,s=oe(o),i=t.map(l=>l[0]).join(","),a=t.map((l,c)=>l[0]+e[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};var C_=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((h,g)=>h[0]+e[g]+h[1]);let o=e.length,s=oe(o),i=t.map(h=>h[0]).join(","),a=t.map((h,g)=>h[0]+e[g]).join(","),u=Me("rc",o),l=Me("source",o),c=`${u[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,m=[`${s} rc = outputLoc;`,`${u[o-1]} += 1;
       if(${c}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${u[o-2]} += 1;
       if(${u[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${u[o-1]} += 1;
         if(${c}) {`],f=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",d="";for(let h=0,g=o===1?2:4;h<g;h++)d+=`
        ${m[h]}
        if (${f}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${l.join()}), ${p});
        }
      `;d+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var T_=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:i}=n;if(w.sizeFromShape(o.shape)===0){let l=s.map((c,p)=>c[0]+o.shape[p]+c[1]);return Xr({backend:t,attrs:{shape:l,value:i,dtype:o.dtype}})}let a=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new C_(o.shape,s,i):new I_(o.shape,s,i),u=[[i]];return t.runWebGLProgram(a,[o],o.dtype,u)},QE={kernelName:Bo,backendName:"webgl",kernelFunc:T_};var m4=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,f4=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+Xn+`
  return result;
`,d4=fe({opSnippet:m4,packedOpSnippet:f4}),ZE={kernelName:va,backendName:"webgl",kernelFunc:d4};function h4(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n,a=o.shape.length,u=[],l=w.parseAxisParam(s,o.shape),c=l,p=k.getAxesPermutation(c,a),m=o;p!=null&&(m=Ne({inputs:{x:o},backend:t,attrs:{perm:p}}),c=k.getInnerMostAxes(c.length,a),u.push(m)),k.assertAxesAreInnerMostDims("prod",c,a);let f;if(t.shouldExecuteOnCPU([m])){let d=t.texData.get(m.dataId).values,{outVals:h,outShape:g,outDtype:y}=jS(m.shape,m.dtype,d,c);f=t.makeTensorInfo(g,y,h)}else{let[d,h]=k.computeOutAndReduceShapes(m.shape,c),g=w.sizeFromShape(h),y=V({inputs:{x:m},backend:t,attrs:{shape:[-1,g]}}),I=ss(o.dtype),_=Ot(y,I,"prod",t);f=V({inputs:{x:_},backend:t,attrs:{shape:d}}),u.push(y),u.push(_)}if(i){u.push(f);let d=k.expandShapeToKeepDim(f.shape,l);f=V({inputs:{x:f},backend:t,attrs:{shape:d}})}return u.forEach(d=>t.disposeIntermediateTensorInfo(d)),f}var e1={kernelName:Tn,backendName:"webgl",kernelFunc:h4};var S_=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:i}=t,a=qS(n,o,s,i);return e.makeTensorInfo([a.length],i,a)},t1={kernelName:Ia,backendName:"webgl",kernelFunc:S_};var g4="return 1.0 / x;",x4=X({opSnippet:g4}),r1={kernelName:ac,backendName:"webgl",kernelFunc:x4};var _4=Je+`
  return (x < 0.0) ? 0.0 : x;
`,y4=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,b4=X({opSnippet:_4,packedOpSnippet:y4}),n1={kernelName:Ca,backendName:"webgl",kernelFunc:b4};var w4=Je+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,v4=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,I4=X({opSnippet:w4,packedOpSnippet:v4}),o1={kernelName:Sa,backendName:"webgl",kernelFunc:I4};var k_=class{constructor(e,t,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,u,l]=e;this.outputShape=[i,t,n,l];let c=[o&&t>1?a-1:a,o&&n>1?u-1:u],p=[o&&t>1?t-1:t,o&&n>1?n-1:n],m;s?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var N_=class{constructor(e,t,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,u,l]=e;this.outputShape=[i,t,n,l];let c=[o&&t>1?a-1:a,o&&n>1?u-1:u],p=[o&&t>1?t-1:t,o&&n>1?n-1:n],m;s?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function C4(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=$().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new N_(o.shape,u,l,s,i):new k_(o.shape,u,l,s,i);return t.runWebGLProgram(c,[o],"float32")}var s1={kernelName:Wo,backendName:"webgl",kernelFunc:C4};var E_=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,o,s]=t,[,i,a]=e,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=u[0]/l[0],p=u[1]/l[1],m=1/c,f=1/p,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function T4(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:i}=n,a=new E_(s.shape,o.shape,i);return t.runWebGLProgram(a,[s],s.dtype)}var a1={kernelName:Mb,backendName:"webgl",kernelFunc:T4};var A_=class{constructor(e,t,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,u,l]=e;this.outputShape=[i,t,n,l];let c=[o&&t>1?a-1:a,o&&n>1?u-1:u],p=[o&&t>1?t-1:t,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var R_=class{constructor(e,t,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,u,l]=e;this.outputShape=[i,t,n,l];let c=[o&&t>1?a-1:a,o&&n>1?u-1:u],p=[o&&t>1?t-1:t,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function S4(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=$().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new R_(o.shape,u,l,s,i):new A_(o.shape,u,l,s,i);return t.runWebGLProgram(c,[o],o.dtype)}var i1={kernelName:ic,backendName:"webgl",kernelFunc:S4};var $_=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,o,s]=t,[,i,a]=e,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=u[0]/l[0],p=u[1]/l[1],m=1/c,f=1/p,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function k4(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:i}=n,a=new $_(s.shape,o.shape,i);return t.runWebGLProgram(a,[s],s.dtype)}var u1={kernelName:Lb,backendName:"webgl",kernelFunc:k4};var D_=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let o=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,s=e.map((a,u)=>o(u)).join(","),i=oe(n);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var O_=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let o=Me("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,a=oe(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(o.slice())};
          if(${s}){
            result.g = ${l(o.slice())};
          }
          if(${i}) {
            result.b = ${c(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(d){return m(d)}function l(d){return d[n-1]="("+d[n-1]+" + 1)",m(d)}function c(d){return d[n-2]="("+d[n-2]+" + 1)",m(d)}function p(d){return d[n-1]="("+d[n-1]+" + 1)",d[n-2]="("+d[n-2]+" + 1)",m(d)}function m(d){let h=e.map((I,_)=>f(_,d)),g=h.join(","),y=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function f(d,h){return t.indexOf(d)!==-1&&e[d]!==1?`${e[d]} - ${h[d]} - 1`:`${h[d]}`}}};function N4(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,i=o.shape.length,a=w.parseAxisParam(s,o.shape);if(i===0)return Be({inputs:{x:o},backend:t});let u=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new O_(o.shape,a):new D_(o.shape,a);return t.runWebGLProgram(u,[o],o.dtype)}var l1={kernelName:Vo,backendName:"webgl",kernelFunc:N4};var F_=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],o=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var c1={kernelName:Qo,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=e,a=t,u=new F_(n.shape,s),[l,c]=k.getImageCenter(i,n.shape[1],n.shape[2]),p=[[l,c,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(u,[n],n.dtype,p)}};var E4=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,A4=X({opSnippet:E4}),p1={kernelName:ka,backendName:"webgl",kernelFunc:A4};var R4="return inversesqrt(x);",$4=X({opSnippet:R4,cpuKernelImpl:KS}),m1={kernelName:Sn,backendName:"webgl",kernelFunc:$4};var Du=class{constructor(e,t,n,o,s,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let u=oe(s.length),l=oe(i.length),c="";n===1?c="i":n===2&&(c="i, j");let p=`getIndices(${c})`,m="";o===1?m="i":o===2&&(m="i, coords[1]");let f=`getUpdates(${m})`,d=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${d};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function D4(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=k.calculateShapes(s,o,i),m=[p/l,l];if(p===0)return t.makeTensorInfo(i,o.dtype);let f=V({inputs:{x:o},backend:t,attrs:{shape:[u,a]}}),d=V({inputs:{x:s},backend:t,attrs:{shape:[u,l]}}),h=t.makeTensorInfo([],"float32",new Float32Array([0])),g=new Du(u,a,f.shape.length,d.shape.length,c,m),y=t.runWebGLProgram(g,[d,f,h],d.dtype),I=V({inputs:{x:y},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(h),I}var f1={kernelName:Go,backendName:"webgl",kernelFunc:D4};var P_=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let c=0;c<t.length;c++)l.push(`${a[c]}`),c<e&&u.push(`${a[c]}`);o=u.join(),s=l.join()}let i=oe(n);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function O4(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,i=new P_(n.shape.length,o.shape,o.shape.length);return t.runWebGLProgram(i,[n,o,s],ut(o.dtype,s.dtype))}var d1={kernelName:Na,backendName:"webgl",kernelFunc:O4};var F4=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${k.SELU_SCALEALPHA};
  float scale = ${k.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,P4=X({opSnippet:F4}),h1={kernelName:uc,backendName:"webgl",kernelFunc:P4};var g1="return 1.0 / (1.0 + exp(-1.0 * x));",L4=X({opSnippet:g1,packedOpSnippet:g1,cpuKernelImpl:XS}),x1={kernelName:kn,backendName:"webgl",kernelFunc:L4};var M4=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,B4=X({opSnippet:M4}),_1={kernelName:cc,backendName:"webgl",kernelFunc:B4};var U4=wp+`
  return sin(x);
`,W4=X({opSnippet:U4}),y1={kernelName:Ea,backendName:"webgl",kernelFunc:W4};var V4=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,G4=X({opSnippet:V4}),b1={kernelName:lc,backendName:"webgl",kernelFunc:G4};var z4=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,H4=X({opSnippet:z4}),w1={kernelName:pc,backendName:"webgl",kernelFunc:H4};var j4=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:i}=n;w.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((y,I)=>y*I),u=[[0,0]];u.push(...i);for(let y=1+s.length;y<o.shape.length;++y)u.push([0,0]);let l=[],c=T_({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),p=k.getReshaped(c.shape,s,a,!1),m=k.getPermuted(p.length,s.length,!1),f=k.getReshapedPermuted(c.shape,s,a,!1),d=V({inputs:{x:c},backend:t,attrs:{shape:p}}),h=Ne({inputs:{x:d},backend:t,attrs:{perm:m}}),g=V({inputs:{x:h},backend:t,attrs:{shape:f}});return l.push(c),l.push(d),l.push(h),l.forEach(y=>t.disposeIntermediateTensorInfo(y)),g},v1={kernelName:Aa,backendName:"webgl",kernelFunc:j4};function q4(r){let{inputs:e,backend:t}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=t.readSync(n.dataId),u=t.readSync(o.dataId),l=t.readSync(s.dataId),c=t.readSync(i.dataId)[0],[p,m,f,d,h]=JS(a,n.shape,n.dtype,u,o.dtype,l,c);return[t.makeTensorInfo(m,n.dtype,p),t.makeTensorInfo([m[0]],o.dtype,f),t.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),t.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var I1={kernelName:mc,backendName:"webgl",kernelFunc:q4};function K4(r){let{inputs:e,backend:t}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(t.readSync(o.dataId)),a=t.readSync(n.dataId),u=Array.from(t.readSync(s.dataId)),[l,c,p]=QS(a,n.shape,n.dtype,i,u);return[t.makeTensorInfo(c,n.dtype,l),t.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var C1={kernelName:fc,backendName:"webgl",kernelFunc:K4};function X4(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=t.readSync(n.dataId),a=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,c]=_p(i,n.shape,n.dtype,a,u,!0);return t.makeTensorInfo(c,n.dtype,l)}var T1={kernelName:dc,backendName:"webgl",kernelFunc:X4};function Y4(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=t.readSync(n.dataId),a=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,c]=_p(i,n.shape,n.dtype,a,u);return t.makeTensorInfo(c,n.dtype,l)}var S1={kernelName:hc,backendName:"webgl",kernelFunc:Y4};function J4(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=e,{outputShape:a}=n,{sliceRank:u,numUpdates:l,strides:c,outputSize:p}=k.calculateShapes(s,o,a),m=!1,f=new Du(l,u,o.shape.length,s.shape.length,c,[p,1],m),d=t.runWebGLProgram(f,[s,o,i],s.dtype),h=V({inputs:{x:d},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(d),h}var k1={kernelName:gc,backendName:"webgl",kernelFunc:J4};function Q4(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:i}=n,a=w.parseAxisParam(i,o.shape)[0],u=k.prepareSplitSize(o,s,a),l=o.shape.length,c=new Array(l).fill(0),p=o.shape.slice();return u.map(m=>{let f=[...p];f[a]=m;let d=ar({inputs:{x:o},backend:t,attrs:{begin:c,size:f}});return c[a]+=m,d})}var N1={kernelName:Ra,backendName:"webgl",kernelFunc:Q4};var E1="return sqrt(x);",Z4=X({opSnippet:E1,packedOpSnippet:E1,cpuKernelImpl:ZS}),A1={kernelName:Nn,backendName:"webgl",kernelFunc:Z4};var eV="return x * x;",tV=X({opSnippet:eV}),R1={kernelName:xc,backendName:"webgl",kernelFunc:tV};var $1="return (a - b) * (a - b);",rV=fe({opSnippet:$1,packedOpSnippet:$1}),D1={kernelName:En,backendName:"webgl",kernelFunc:rV};function nV({inputs:r,attrs:e,backend:t}){let{x:n}=r,o=Je+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new St(n.shape,o);return t.runWebGLProgram(s,[n],n.dtype)}var O1={kernelName:Jo,backendName:"webgl",kernelFunc:nV};var L_=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let o=n.length,s=oe(n.length),i=oe(n.length),a="";if(o===1)a="coords * strides + begin";else{let u=0;a=n.map((l,c)=>(u++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${u-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function oV(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n,{nonStrided:f,$begin:d,$strides:h,size:g,newShape:y,outShape:I}=st.sliceInfo(o.shape,s,i,a,u,l,c,p,m),_=V({inputs:{x:o},backend:t,attrs:{shape:y}}),N;if(f){let F=ar({inputs:{x:_},backend:t,attrs:{begin:d,size:g}});N=V({inputs:{x:F},backend:t,attrs:{shape:I}}),t.disposeIntermediateTensorInfo(F)}else if(I.some(F=>F===0))N=t.makeTensorInfo(I,o.dtype,[]);else if(t.shouldExecuteOnCPU([_])){let O=t.texData.get(_.dataId).values,U=ye(_.shape,_.dtype,O),M=ek(I,U,h,d);N=t.makeTensorInfo(I,_.dtype,M.values)}else{let D=new L_(d,h,I);N=t.runWebGLProgram(D,[_],_.dtype)}let R=V({inputs:{x:N},backend:t,attrs:{shape:I}});return t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(N),R}var F1={kernelName:qo,backendName:"webgl",kernelFunc:oV};function sV(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:c,dataSplits:p}=e,m=t.readSync(c.dataId),f=t.readSync(p.dataId),[d,h]=tk(m,f,o,s,i,a,u,l);return[t.makeTensorInfo([d.length],"string",d),t.makeTensorInfo(p.shape,"int32",h)]}var P1={kernelName:_c,backendName:"webgl",kernelFunc:sV};function aV(r){let{inputs:e,backend:t,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=t.readSync(s.dataId),u=t.readSync(i.dataId)[0],[l,c,p]=rk(a,u,o),m=c.length;return[t.makeTensorInfo([m,2],"int32",l),t.makeTensorInfo([m],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(p))]}var L1={kernelName:yc,backendName:"webgl",kernelFunc:aV};function iV(r){let{inputs:e,backend:t,attrs:n}=r,{numBuckets:o}=n,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=t.readSync(s.dataId),a=nk(i,o);return t.makeTensorInfo(s.shape,"int32",a)}var M1={kernelName:bc,backendName:"webgl",kernelFunc:iV};var uV="return tan(x);",lV=X({opSnippet:uV}),B1={kernelName:$a,backendName:"webgl",kernelFunc:lV};var cV=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,pV=X({opSnippet:cV}),U1={kernelName:Da,backendName:"webgl",kernelFunc:pV};var M_=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.rank=n.length;let o=oe(this.rank),s=mV(e);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function mV(r){let e=r.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${r[0]})`;let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<r.length;o++)n.push(`imod(${t[o]}, ${r[o]})`);return n.join()}function B_(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let u=t.readSync(o.dataId),l=o.dtype==="string"?u.map(m=>w.decodeString(m)):u,c=ye(o.shape,o.dtype,l),p=sk(c,s);return t.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new M_(o.shape,s);return t.runWebGLProgram(i,[o],o.dtype)}var W1={kernelName:Ur,backendName:"webgl",kernelFunc:B_};var U_=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},W_=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Ms(r,e){e!==null&&r.disposeIntermediateTensorInfo(e)}function V1(r){let e=1;for(;e<r;)e*=2;return e}function fV(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:i}=n,a=$().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=$().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=o.shape,c=l[l.length-1];if(t.shouldExecuteOnCPU([o])||c<a||s>u){let M=t.readSync(o.dataId),[G,j]=ak(M,l,o.dtype,s,i);return[t.makeTensorInfo(G.shape,G.dtype,G.values),t.makeTensorInfo(j.shape,j.dtype,j.values)]}if(s===0)return l[l.length-1]=0,[t.makeTensorInfo(l,o.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(c===1)return[o,Xr({attrs:{shape:l,dtype:"int32",value:0},backend:t})];let p=t.texData.get(o.dataId),m=p!==null&&p.isPacked,f=m?t.unpackTensor(o):o,h=w.sizeFromShape(l)/c,g=V({inputs:{x:f},attrs:{shape:[h,c]},backend:t});m&&Ms(t,f);let y=V1(s),I=V1(c),_=null,N=()=>_===null?[g,g]:[g,_],R=(M,G,j)=>{let ee=N(),Q=new U_(j),le=[[c],[_===null?1:0],[Number.NEGATIVE_INFINITY],[M],[G]],Ce=_;_=t.runWebGLProgram(Q,ee,"int32",le),Ms(t,Ce)};for(let M=1;M<y;M*=2){let G=M*2;for(let j=M;j>=1;j/=2)R(G,j,[h,I])}for(let M=I;M>y;M/=2){let G=N(),j=new W_([h,M/2]),Q=[[c],[_===null?1:0],[y]],ie=_;_=t.runWebGLProgram(j,G,"int32",Q),Ms(t,ie);let le=y/2,Ce=le*2;for(let de=le;de>=1;de/=2)R(Ce,de,_.shape)}let F=_;_=ar({inputs:{x:_},backend:t,attrs:{begin:0,size:[h,s]}}),Ms(t,F);let D=l_({inputs:{x:g,indices:_},backend:t,attrs:{axis:1,batchDims:1}});Ms(t,g);let O=l.slice(0,-1);O.push(s),F=_,_=V({inputs:{x:_},attrs:{shape:O},backend:t}),Ms(t,F);let U=D;return D=V({inputs:{x:D},attrs:{shape:O},backend:t}),Ms(t,U),[D,_]}var G1={kernelName:Ko,backendName:"webgl",kernelFunc:fV};var V_=class{constructor(e,t,n,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=n==="nearest"?1:2,u;switch(o){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function dV(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,p,m,f]=o.shape,[d,h]=l??[p,m],g=[c,d,h,f],y=new V_(p,m,i,a,u,g);return t.runWebGLProgram(y,[o,s],"float32")}var z1={kernelName:Xo,backendName:"webgl",kernelFunc:dV};function hV(r){let{inputs:e,attrs:t,backend:n}=r,{axis:o}=t,{x:s}=e;Cr(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=n.readSync(s.dataId),{outputValues:a,outputShape:u,indices:l}=ik(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var H1={kernelName:wc,backendName:"webgl",kernelFunc:hV};function gV(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,u=o.shape[s],l=new Array(a-1),c=0;for(let h=0;h<a;h++)h!==s&&(l[c++]=i.shape[h]);let p=[],m=new Array(a).fill(0),f=i.shape.slice();f[s]=1;let d=new Array(u);for(let h=0;h<d.length;h++){m[s]=h;let g=ar({inputs:{x:i},backend:t,attrs:{begin:m,size:f}}),y=V({inputs:{x:g},backend:t,attrs:{shape:l}});d[h]=y,p.push(g)}return p.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}var j1={kernelName:Oa,backendName:"webgl",kernelFunc:gV};var G_=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,o=e.batchSize,s=e.inSize,i=e.numSegments,a=i*Math.ceil(s/n);this.outputShape=[o,a];let u="0.0",l="sumValue",c=Math.floor(n/4)*4,p=n%4,m=`
        sumValue += dot(values, segFilter);
    `,f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${d}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function xV(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,segmentIds:s}=e,{numSegments:i}=n,a=o.shape.length,u=[],l=0,c=k.getAxesPermutation([l],a),p=o;c!=null&&(p=Ne({inputs:{x:o},backend:t,attrs:{perm:c}}),u.push(p),l=k.getInnerMostAxes(1,a)[0]);let m=k.segment_util.computeOutShape(p.shape,l,i),f=w.sizeFromShape([p.shape[l]]),d=V({inputs:{x:p},backend:t,attrs:{shape:[-1,f]}});u.push(d);let h=ss(o.dtype),g=(N,R,F,D,O)=>{let U=N.shape[0],M=N.shape[1],G=k.segment_util.segOpComputeOptimalWindowSize(M,O),j={windowSize:G,inSize:M,batchSize:U,numSegments:O},ee=new G_(j,R),Q=t.compileAndRun(ee,[N,F],D);if(u.push(Q),Q.shape[1]===O)return Q;let ie=S_({backend:t,attrs:{start:0,stop:O,step:1,dtype:"float32"}}),le=B_({inputs:{x:ie},backend:t,attrs:{reps:[M/G]}});return u.push(ie),u.push(le),g(Q,R,le,D,O)},y=g(d,"unsortedSegmentSum",s,h,i),I=V({inputs:{x:y},backend:t,attrs:{shape:m}}),_=I;if(c!=null){u.push(I);let N=k.getUndoAxesPermutation(c);_=Ne({inputs:{x:_},backend:t,attrs:{perm:N}})}return u.forEach(N=>t.disposeIntermediateTensorInfo(N)),_}var q1={kernelName:Bb,backendName:"webgl",kernelFunc:xV};var _V=[bE,wE,Fk,Lk,Mk,Bk,Wk,Vk,Gk,zk,qk,Kk,Xk,Yk,Qk,Jk,Zk,tN,eN,rN,nN,oN,sN,iN,uN,mN,dN,hN,xN,Ik,yN,wN,vN,bN,CN,TN,IN,SN,kN,NN,RN,$N,DN,FN,PN,ON,LN,MN,BN,UN,WN,VN,GN,HN,jN,KN,XN,YN,JN,ZN,eE,tE,rE,nE,oE,sE,aE,iE,vk,uE,_N,lE,cE,pE,Ck,mE,fE,dE,gE,hE,xE,_E,yE,IE,SE,TE,kE,NE,AE,CE,$E,DE,OE,FE,PE,WE,Ek,GE,zE,HE,jE,lN,qE,YE,JE,QE,ZE,Tk,e1,t1,cN,LE,r1,o1,n1,Rk,s1,a1,i1,u1,l1,c1,p1,m1,f1,d1,h1,x1,_1,y1,b1,aN,UE,w1,v1,I1,C1,T1,S1,k1,N1,A1,R1,D1,O1,F1,P1,L1,M1,BE,Dk,B1,U1,W1,G1,z1,Ok,H1,j1,q1,KE];for(let r of _V)Ic(r);function Ou(){return!!document.createElement("canvas").getContext("webgl2")}function Dp(){return!!document.createElement("canvas").getContext("webgl")}function fi(r,e){if(Array.isArray(r)){if(!Array.isArray(e)||r.length!==e.length)return!1;for(let t=0;t<r.length;++t)if(!fi(r[t],e[t]))return!1;return!0}else{if(typeof r=="string")return typeof e!="string"?!1:r===e;if(typeof e=="number")return typeof e!="number"?!1:r===e;if(typeof r=="boolean")return typeof e!="boolean"?!1:r===e;if(r===null||e===null)return r===null&&e===null;if(r===void 0||e===void 0)return r===void 0&&e===void 0;if(typeof r=="object"){if(typeof e!="object")return!1;let t=Object.keys(r),n=new Set(Object.keys(e));if(t.length!==n.size)return!1;for(let o=0;o<t.length;++o)if(!n.has(t[o])||!fi(r[t[o]],e[t[o]]))return!1;return!0}else if(typeof r=="function")return typeof e!="function"?!1:r===e}throw"unhandled type "+typeof r}var yV={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0,powerPreference:"default"};async function bV(r){if($().set("HAS_WEBGL",!0),Ou())$().set("WEBGL_VERSION",2);else if(Dp())$().set("WEBGL_VERSION",1);else throw"No webgl available.";let e=JSON.parse(JSON.stringify(yV));e.failIfMajorPerformanceCaveat=!1,e.powerPreference="high-performance",pv("webgl"),qa("webgl",()=>{let t;r?(console.warn("Using experimental offscreen canvas"),t=new OffscreenCanvas(2e3,2e3)):t=document.createElement("canvas");let n;return Ou()?n=t.getContext("webgl2",e):n=t.getContext("webgl",e),new qr(new pi(n))},999),Uc("webgl"),await cv()}var K1=null;async function X1(r){if(!(Un()==="webgl"&&fi(K1,r))&&(console.log("Setting up webgl backend."),K1=r,await bV(r.offscreen),Un()!=="webgl"))throw"Failed to initialize webgl backend"}var ct={TFJS_WEBGL:"TFJS_WEBGL",TFJS_WASM:"TFJS_WASM"};async function Qn(r,e){r.type===ct.TFJS_WASM?await N0(r,e):r.type===ct.TFJS_WEBGL&&await X1(r)}var z_=class{Init(e,t,n,o,s){this.preproc_=new Fr,this.preproc_.Init(e,t,n,o,s),this.originalWidth_=e,this.originalHeight_=t,this.resizeWidth_=n,this.resizeHeight_=o,this.pad_=s,this.prof_=new Lr(100),this.debug_=!1}async Preprocess(e,t){this.backendInit_||(this.backendInit_=!0,await Qn({type:ct.TFJS_WEBGL,offscreen:!1}));let n=await this.preproc_.Preprocess(e,t);this.debug_&&this.prof_.Start("FromPixels");let o=cs.fromPixels(n.canvas);this.debug_&&this.prof_.End("FromPixels"),this.debug_&&this.prof_.Start("Tensor.array");let s=await o.array();return this.debug_&&this.prof_.End("Tensor.array"),o.dispose(),this.debug_&&this.prof_.Start(Un()),this.debug_&&this.prof_.End(Un()),{type:je.ARRAY,data:s,shape:[this.resizeWidth_,this.resizeHeight_,3],dtype:"int32"}}};function H_(r){let e=[];for(let t of r)e.push([1-t[0],t[1]]);return e}function wV(r){let e=H_(r.coords),t=e[2];e[2]=e[3],e[3]=t,r.coords=e}function Y1(r,e,t){let n=new $i(e.rotationCenter,e.rotationInRadians,t);r.coords=cb([e.topLeft,e.bottomRight],r.coords),r.coords=n.ApplyReverse(r.coords)}function J1(r,e,t){return r.flip&&wV(r),vV(r,e,t)}function vV(r,e,t){let n=r.coords;if(n.length!==6)throw"wrong num coords";let s=new j_(n[0],n[1],e).GetRotationInRadians(),i=[n[2],n[3],n[4],n[5]],a=vl(Lf(n[0],n[1]),[2,2]),l=new $i(a,s,e).Apply(i),c=Q1(l);return c=IV(n,c,e,t),{topLeft:c[0],bottomRight:c[1],rotationInRadians:s,rotationCenter:a,flip:r.flip}}function IV(r,e,t,n){let o=yl(r,t.width,t.height),s=Pr(o[0],o[1])*n;return e=JSON.parse(JSON.stringify(e)),e[0][0]-=s/t.width,e[1][0]+=s/t.width,e[0][1]-=s/t.height,e[1][1]+=s/t.height,e}function Z1(r,e,t,n){let o=r.coords[20],s=r.coords[5],i=vl(Lf(o,s),[2,2]),u=new j_(o,s,e).GetRotationInRadians(),c=new $i(i,u,e).Apply(r.coords),p=mb(c),m=[p.minX,p.maxX,p.minY,p.maxY],f=Q1(m);return f=CV(f,e,t,r.coords),{topLeft:f[0],bottomRight:f[1],rotationInRadians:u,rotationCenter:i,flip:n}}function CV(r,e,t,n){let o=[],s=yl(n,e.width,e.height);o.push(Pr(s[20],s[16])),o.push(Pr(s[20],s[1])),o.push(Pr(s[20],s[5])),o.push(Pr(s[20],s[9])),o.push(Pr(s[20],s[13])),o.push(Pr(s[13],s[1]));let i=-1;for(let u of o)i=Math.max(i,u);let a=t*i;return r=JSON.parse(JSON.stringify(r)),r[0][0]-=a/e.width,r[1][0]+=a/e.width,r[0][1]-=a/e.height,r[1][1]+=a/e.height,r}function Q1(r){let e=[r[0][0],r[2][1]],t=[r[1][0],r[3][1]];return[e,t]}var j_=class{constructor(e,t,n){this.palmBottom_=e,this.palmTop_=t,this.aspectRatio_=n,this.palmLine_=null,this.normalizedPalmLine_=null,this.mainJointLine_=null,this.rotationInRadians_=null,this.Initialize_()}GetRotationInRadians(){return this.rotationInRadians_}Initialize_(){this.AdjustForAspectRatio_(),this.ComputePalmLine_(),this.ComputeMainJointLine_(),this.ComputeRotation_()}AdjustForAspectRatio_(){let e=this.aspectRatio_.width/this.aspectRatio_.height;this.palmTop_=wl(this.palmTop_,[e,1]),this.palmBottom_=wl(this.palmBottom_,[e,1])}ComputePalmLine_(){this.palmLine_=bl(this.palmTop_,this.palmBottom_),this.normalizedPalmLine_=ib(this.palmLine_)}ComputeMainJointLine_(){this.mainJointLine_=[-this.normalizedPalmLine_[1],this.normalizedPalmLine_[0]]}ComputeRotation_(){let e=[this.mainJointLine_[0],-this.mainJointLine_[1]];this.rotationInRadians_=Math.atan2(e[1],e[0])}};var TV=!1,eA=class{constructor(e,t){this.p_=e,this.nodeId_=t}async Start(e){return this.p_.StartNode_(this.nodeId_,e)}},tA;typeof window!="undefined"&&(tA=document.createElement("div"),document.body.appendChild(tA));var q_=class{constructor(){this.nodes_=[],this.taskCounter_=0,this.tasks_=new Map,this.debug_=TV}RegisterTask(){let e=this.CreateTaskId_(),t=[],n=[];for(let o=0;o<this.nodes_.length;++o)n.push(new Promise(s=>{t.push(s)}));return this.tasks_.set(e,{promises:n,resolves:t}),e}AddNode(e){let t=this.nodes_.length,n=new eA(this,t);return this.nodes_.push({externalNode:n,tasks:[],config:e}),n}CancelTask(e){this.debug_&&console.log("del task ",e);for(let t=0;t<this.nodes_.length;++t){let n=this.FindTaskIndexAtNode_(t,e);typeof n=="number"&&this.nodes_[t].tasks.splice(n)}this.FreeTaskResources_(e),this.PipelineFlow_()}async StartNode_(e,t){if(this.debug_&&console.log("beg t/n",t,e),!this.tasks_.has(t))return console.warn("Deleted task which never started on any node, this is likely not intended"),!1;e===0?(this.debug_&&this.TaskIsWaiting_()&&console.log("drop ",this.waitingTaskId_),this.SignalTaskDropForWaitingTask_(),this.FreeTaskResources_(this.waitingTaskId_),this.waitingTaskId_=t):this.MarkTaskCompleteAtNode_(e-1,t);let n=this.tasks_.get(t).promises[e];return this.PipelineFlow_(),n}SignalTaskDropForWaitingTask_(){this.TaskIsWaiting_()&&this.tasks_.get(this.waitingTaskId_).resolves[0](!1)}TaskIsWaiting_(){return this.waitingTaskId_===0||this.waitingTaskId_}FreeTaskResources_(e){this.tasks_.delete(e)}PipelineFlow_(){for(let e=this.nodes_.length-1;e>=0;--e)e===this.nodes_.length-1&&this.nodes_[e].config.capacity!==-1&&console.error("Last node should have capacity -1"),this.AdvanceTasksAtNode_(e),this.NodeStillHasCapacity_(0)&&this.TaskIsWaiting_()&&(this.nodes_[0].tasks.push({taskId:this.waitingTaskId_,completed:!1}),this.EnqueueResolveTaskAtNodeMicroTask_(0,this.waitingTaskId_),this.waitingTaskId_=null)}AdvanceTasksAtNode_(e){let t=this.nodes_[e];if(e===this.nodes_.length-1){for(let u of t.tasks)this.FreeTaskResources_(u.taskId);t.tasks=[];return}let o=e+1,s=this.nodes_[o],i=[],a=!1;for(let u=0;u<t.tasks.length;++u){let l=t.tasks[u];l.completed&&this.NodeStillHasCapacity_(o)&&!a?(s.tasks.push({taskId:l.taskId,completed:!1}),this.EnqueueResolveTaskAtNodeMicroTask_(o,l.taskId)):(a=!0,i.push(l))}t.tasks=i}EnqueueResolveTaskAtNodeMicroTask_(e,t){Promise.resolve().then(()=>{this.tasks_.get(t).resolves[e](!0)})}NodeStillHasCapacity_(e){let t=this.nodes_[e].config.capacity;return this.nodes_[e].tasks.length<t||t===-1}CreateTaskId_(){return this.taskCounter_++}MarkTaskCompleteAtNode_(e,t){let n=this.FindTaskIndexAtNode_(e,t);this.nodes_[e].tasks[n].completed=!0}FindTaskIndexAtNode_(e,t){let n=this.nodes_[e].tasks;for(let o=0;o<n.length;++o)if(n[o].taskId===t)return o;return null}ToString(){let e="",t=0;for(let n of this.nodes_)e+="[c:"+n.config.capacity+",u:"+n.tasks.length+"]",t!==this.nodes_.length-1&&(e+="-"),++t;return e}};var rA=[17,16,18,19,1,0,2,3,5,4,6,7,9,8,10,11,13,12,14,15,20];var Bs={PAD:"PAD",SCALE:"SCALE"},Zn={BOX:"BOX",LAN:"LAN",__NONE:"__NONE"},SV={detected:!1,lanTransformInfo:null,stage:Zn.BOX,initLanGoodFrames:0,initBoxGoodFrames:0},kV=[];if(typeof window!="undefined")for(let r=0;r<10;++r){let e=document.createElement("div");kV.push(e),document.body.appendChild(e)}var Fu=class{constructor(){this.canvasProc_=[],this.pipeline_=new q_,this.prof_=new Lr(100),this.processing_=!1}Initialize(e,t,n,o,s){this.config_=e,this.boxCb_=t,this.lanCb_=n,this.resCb_=o,this.latencyCb_=s,this.s_=JSON.parse(JSON.stringify(SV)),this.minBorderDistancePx_=this.config_.minBorderDistance*Math.min(this.config_.origDimensions.width,this.config_.origDimensions.height);let i=[this.config_.boxTargetDimensions,this.config_.lanTargetDimensions];for(let a=0;a<2;++a){let u=this.config_.origDimensions.width,l=this.config_.origDimensions.height,c=i[a].width,p=i[a].height,m=a===0?this.config_.boxResizeMode===Bs.PAD:this.config_.lanResizeMode===Bs.PAD,f;if(this.config_.preprocType===Jt.CANVAS_API)f=new Fr;else if(this.config_.preprocType===Jt.NATIVE_WEBGL)f=new Bf;else if(this.config_.preprocType===Jt.TF)f=new z_;else if(this.config_.preprocType===Jt.CANVAS_API_TO_TYPED)f=new Uf;else throw"unknown type";f.Init(u,l,c,p,m),this.canvasProc_.push(f)}this.SetupPipeline_()}async Reset(){await this.Stop(),this.Start(this.src_)}Start(e){this.RestartDetection_(),this.src_=e,requestAnimationFrame(()=>{this.Loop_()})}async Stop(){let e=new Promise(t=>{this.stopPromiseResolve_=t});return this.stopPromise_=e,e}async Loop_(){this.PerformStopIfNecessary_()||((!this.config_.waitForPreviousTask||!this.processing_)&&(this.config_.usePostInterval?setTimeout(async()=>{this.LoopIteration_()},0):this.LoopIteration_()),requestAnimationFrame(()=>{this.Loop_()}))}PerformStopIfNecessary_(){if(this.stopPromise_){let e=this.stopPromiseResolve_;return this.stopPromiseResolve_=null,this.stopPromise_=null,e(),!0}return!1}async LoopIteration_(){this.processing_=this.config_.waitForPreviousTask;let e=this.Process_();this.config_.waitForPreviousTask&&await e,this.processing_=!1}async Process_(){let e=new Date;await this.ProcessStage_()&&this.latencyCb_(+new Date-+e)}async ProcessStage_(){let e=this.pipeline_.RegisterTask(),t=await this.preprocNode_.Start(e);if(!t)return t;if(this.s_.stage===Zn.LAN)return await this.ProcessLan_(e);if(this.s_.stage===Zn.BOX)return await this.ProcessBox_(e);throw"s"}SetupPipeline_(){this.preprocNode_=this.pipeline_.AddNode({capacity:1}),this.config_.singlePipelineNode||(this.nnNode_=this.pipeline_.AddNode({capacity:1})),this.finishNode_=this.pipeline_.AddNode({capacity:-1})}RestartDetection_(){this.s_.initLanGoodFrames=0,this.s_.initBoxGoodFrames=0,this.s_.detected=!1,this.s_.stage=Zn.BOX}async ProcessLan_(e){let t=this.s_.lanTransformInfo,n=!0,o=+new Date,s=await this.canvasProc_[1].Preprocess(this.src_,t);if(!this.config_.singlePipelineNode&&(n=await this.nnNode_.Start(e),!n))return n;let i=await this.lanCb_(s);await this.finishNode_.Start(e),this.config_.lanResizeMode===Bs.PAD&&Pf(this.config_.origDimensions.width,this.config_.origDimensions.height,t,i.coords);let a=sb(this.config_.lanThresholds,i);Y1(a,t,this.GetAspectRatio_());let u=0;for(let m of a.coords)m[0]>=0&&m[0]<=1&&m[1]>=0&&m[1]<=1&&(u+=1);let l=u>=this.config_.minVisibleLanCoordinates,c=this.CoordIsBelowMinBorderDistance_(a.coords);if(this.s_.detected){let m=a.confidence>=this.config_.minLanHeatmapConfidence;if(this.config_.useLanHeatmapConfidence&&!m||!this.config_.useLanHeatmapConfidence&&!a.containsHand||c)return this.resCb_({type:Le.LOST,score:a.confidence,reason:rb.CONFIDENCE}),this.RestartDetection_(),!0}else{let m=a.confidence>=this.config_.initialLanHeatmapConfidence;if((this.config_.useLanHeatmapConfidence&&m||a.containsHand)&&l&&!c){if(this.s_.initLanGoodFrames+=1,this.s_.initLanGoodFrames>=this.config_.initialLanGoodFrames&&(this.s_.detected=!0),!this.s_.detected)return!0}else return this.RestartDetection_(),!0}let p=a.coords;return this.s_.lanTransformInfo=Z1(a,this.GetAspectRatio_(),this.config_.slack,!1),this.resCb_({type:Le.RESULT,coordinates:this.PostProcessCoords_(p),isLeftHand:a.flip,poses:a.poses,__timestamp:o}),!0}async ProcessBox_(e){let t={topLeft:[0,0],bottomRight:[1,1],flip:!1,rotationCenter:[.5,.5],rotationInRadians:0},n=!0,o=await this.canvasProc_[0].Preprocess(this.src_,t);if(this.s_.stage===Zn.LAN)return this.pipeline_.CancelTask(e),!1;if(!this.config_.singlePipelineNode&&(n=await this.nnNode_.Start(e),!n))return n;if(this.s_.stage===Zn.LAN)return this.pipeline_.CancelTask(e),!1;let s=await this.boxCb_(o);if(await this.finishNode_.Start(e),this.s_.stage===Zn.LAN)return this.pipeline_.CancelTask(e),!1;this.config_.boxResizeMode===Bs.PAD&&Pf(this.config_.origDimensions.width,this.config_.origDimensions.height,t,s.coords);let i=ob(this.config_.boxThresholds,s);if(this.config_.useBoxHeatmapConfidence)if(i.confidence>=this.config_.initialBoxHeatmapConfidence){if(this.s_.initBoxGoodFrames+=1,this.s_.initBoxGoodFrames<this.config_.initialBoxGoodFrames)return!0}else return this.s_.initBoxGoodFrames=0,!0;else if(!i.containsHand)return this.s_.initBoxGoodFrames=0,!0;i.flip=!1;let a=J1(i,this.GetAspectRatio_(),this.config_.slack);return this.s_.lanTransformInfo=a,this.s_.stage=Zn.LAN,!0}GetAspectRatio_(){return{width:this.config_.origDimensions.width,height:this.config_.origDimensions.height}}PostProcessCoords_(e){let t=this.config_.postProcessing;if(e=t.flipX?H_(e):e,"customCoordinateSytem"in t&&t.customCoordinateSytem){let n,o,s=this.GetAspectRatio_().width,i=this.GetAspectRatio_().height;if(typeof t.customCoordinateSytem=="number"){let a=t.customCoordinateSytem;n=[a,a],o=[1-a,1-a]}else n=[t.customCoordinateSytem.topLeftPx[0]/s,t.customCoordinateSytem.topLeftPx[1]/i],o=[t.customCoordinateSytem.bottomRightPx[0]/s,t.customCoordinateSytem.bottomRightPx[1]/i];e=pb([n,o],e)}return e=this.MakeCoordOrderUserFriendly_(e),e}MakeCoordOrderUserFriendly_(e){let t=[];for(let n of rA)t.push(e[n]);return t}CoordIsBelowMinBorderDistance_(e){for(let t of e){let n=t[0]*this.config_.origDimensions.width,o=t[1]*this.config_.origDimensions.height;if(n<this.minBorderDistancePx_||this.config_.origDimensions.width-n<this.minBorderDistancePx_||o<this.minBorderDistancePx_||this.config_.origDimensions.height-o<this.minBorderDistancePx_)return!0}return!1}};var Xt;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"})(Xt||(Xt={}));var nA;(function(r){let e;(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e=r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(nA||(nA={}));var NV={};function Op(r){return NV[r]}function x(r,e,t,n,o){let s=e.inputParams[r];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd;if(s.type==="tensor")return qe(e.inputNames[s.inputIndexStart],t,n,o);if(s.type==="tensors")return e.inputNames.slice(a,u).map(m=>qe(m,t,n,o));let l=qe(e.inputNames.slice(a)[0],t,n,o),c=l.dataSync();return s.type==="number"?c[0]:w.toNestedArray(l.shape,c)}let i=e.attrParams[r];return i&&i.value}function qe(r,e,t,n){let[o,s]=xt(r);if(n!=null){let a=n.getHashTableHandleByName(o);if(a!=null)return a}let i=t.currentContextIds.find(a=>!!e[Fp(o,a)]);return i!==void 0?e[Fp(o,i)][s]:void 0}function oA(r,e,t){return e[Fp(r,t.currentContextId)]}function ir(r,e){let[t,n,o]=xt(r);return[Fp(t,e&&e.currentContextId),n,o]}function Fp(r,e){return e?`${r}-${e}`:r}function xt(r){let e=r.split(":");if(e.length===1)return[r,0,void 0];let t=e[0],n=e.length===3?e[1]:void 0,o=Number(e[e.length-1]);return[t,o,n]}function Pu(r,e,t){let n=x("pad",r,e,t);if(n==="explicit"){n=x("explicitPaddings",r,e,t);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=n[s*2],o[s][1]=n[s*2+1];return o}return n}function ur(r){return r.kept?r:zr(r)}var K_={};Ie(K_,{json:()=>EV});var EV=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var X_={};Ie(X_,{json:()=>AV});var AV=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Y_={};Ie(Y_,{json:()=>RV});var RV=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}];var J_={};Ie(J_,{json:()=>$V});var $V=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var Q_={};Ie(Q_,{json:()=>DV});var DV=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var Z_={};Ie(Z_,{json:()=>OV});var OV=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var ey={};Ie(ey,{json:()=>FV});var FV=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var ty={};Ie(ty,{json:()=>PV});var PV=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var ry={};Ie(ry,{json:()=>LV});var LV=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var ny={};Ie(ny,{json:()=>MV});var MV=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}];var oy={};Ie(oy,{json:()=>BV});var BV=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var sy={};Ie(sy,{json:()=>UV});var UV=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var ay={};Ie(ay,{json:()=>WV});var WV=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var iy={};Ie(iy,{json:()=>VV});var VV=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var uy={};Ie(uy,{json:()=>GV});var GV=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var ly={};Ie(ly,{json:()=>zV});var zV=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var cy={};Ie(cy,{json:()=>HV});var HV=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var py={};Ie(py,{json:()=>jV});var jV=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var my={};Ie(my,{json:()=>qV});var qV=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var Pp=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[K_,X_,Y_,J_,Q_,Z_,ey,ty,ry,ny,oy,sy,ay,iy,uy,ly,cy,py,my],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,o)=>(n[o.tfOpName]=o,n),{})}transformGraph(e,t={}){let n=e.node,o=[],s=[],i=[],a=n.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&i.push(h[g.name]),h),{}),u=[],l=[],c={},p={};t!=null&&(c=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));let m=Object.keys(a);m.forEach(h=>{let g=a[h];g.inputNames.forEach((y,I)=>{let[_,,N]=ir(y),R=a[_];if(R.outputs!=null){let F=R.outputs.indexOf(N);if(F!==-1){let D=`${_}:${F}`;g.inputNames[I]=D}}g.inputs.push(R),R.children.push(g)})}),Object.keys(p).length===0?m.forEach(h=>{let g=a[h];g.children.length===0&&l.push(g)}):Object.keys(p).forEach(h=>{let[g]=ir(h),y=a[g];y!=null&&(y.signatureKey=p[h],l.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(h=>{let[g]=ir(h),y=a[g];y&&(y.signatureKey=c[h],u.push(y))}):u=o;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let d={nodes:a,inputs:u,outputs:l,weights:s,placeholders:o,signature:t,functions:f};return i.length>0&&(d.initNodes=i),d}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=Op(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(o=>o.startsWith("^")?o.substr(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=Lp(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Lp(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=zp(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=zp(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=Bp(e.attr,s.tfName,s.defaultValue||0),a===void 0&&!!s.tfDeprecatedName&&(a=Bp(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=Gp(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Gp(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=Mp(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Mp(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=jp(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=jp(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=Vp(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Vp(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=Hp(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Hp(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=Up(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Up(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=Wp(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Wp(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=sA(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=sA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return o[s.name]={value:a,type:i},o},{})),n}mapFunction(e){let t=e.nodeDef,n=[],o=[],s={};t!=null&&(s=t.reduce((p,m)=>(p[m.name]=this.mapNode(m),m.op==="Const"&&o.push(p[m.name]),p),{}));let i=[],a=[];e.signature.inputArg.forEach(p=>{let[m]=ir(p.name),f={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:fy(p.type),type:"dtype"}},children:[]};f.signatureKey=p.name,i.push(f),s[m]=f}),Object.keys(s).forEach(p=>{let m=s[p];m.inputNames.forEach((f,d)=>{let[h,,g]=ir(f),y=s[h];if(y.outputs!=null){let I=y.outputs.indexOf(g);if(I!==-1){let _=`${h}:${I}`;m.inputNames[d]=_}}m.inputs.push(y),y.children.push(m)})});let l=e.ret;e.signature.outputArg.forEach(p=>{let[m,f]=ir(l[p.name]),d=s[m];d!=null&&(d.defaultOutput=f,a.push(d))});let c=this.mapArgsToSignature(e);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:n,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function KV(r){let e=$().global;if(typeof e.atob!="undefined")return e.atob(r);if(typeof Buffer!="undefined")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function aA(r,e){let t=Array.isArray(r)?String.fromCharCode.apply(null,r):KV(r);return e?t:t.toLowerCase()}function Lp(r,e,t,n=!1){let o=r[e];return o!=null?aA(o.s,n):t}function Mp(r,e,t){let n=r[e];return n?n.b:t}function Bp(r,e,t){let n=r[e]||{},o=n.i!=null?n.i:n.f!=null?n.f:t;return typeof o=="number"?o:parseInt(o,10)}function fy(r){switch(typeof r=="string"&&(r=Xt[r]),r){case Xt.DT_FLOAT:return"float32";case Xt.DT_INT32:case Xt.DT_INT64:case Xt.DT_INT8:case Xt.DT_UINT8:return"int32";case Xt.DT_BOOL:return"bool";case Xt.DT_DOUBLE:return"float32";case Xt.DT_STRING:return"string";default:return null}}function sA(r,e,t){let n=r[e];return n&&n.func?n.func.name:t}function Up(r,e,t){let n=r[e];return n&&n.type?fy(n.type):t}function Wp(r,e,t){let n=r[e];return n&&n.list&&n.list.type?n.list.type.map(o=>fy(o)):t}function iA(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Vp(r,e,t){let n=r[e];return n&&n.shape?iA(n.shape):t}function Gp(r,e,t){let n=r[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):t}function zp(r,e,t,n=!1){let o=r[e];return o&&o.list&&o.list.s?o.list.s.map(s=>aA(s,n)):t}function Hp(r,e,t){let n=r[e];return n&&n.list&&n.list.shape?n.list.shape.map(o=>iA(o)):t}function jp(r,e,t){let n=r[e];return n&&n.list&&n.list.b?n.list.b:t}var dy=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(o=>this.getInput(o)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(e){return qe(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return qe(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return Bp(this.node.rawAttrs,e,t);if(n.s!=null)return Lp(this.node.rawAttrs,e,t);if(n.b!=null)return Mp(this.node.rawAttrs,e,t);if(n.shape!=null)return Vp(this.node.rawAttrs,e,t);if(n.type!=null)return Up(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return Gp(this.node.rawAttrs,e,t);if(n.list.s!=null)return zp(this.node.rawAttrs,e,t);if(n.list.shape!=null)return Hp(this.node.rawAttrs,e,t);if(n.list.b!=null)return jp(this.node.rawAttrs,e,t);if(n.list.type!=null)return Wp(this.node.rawAttrs,e,t)}return t}};var uA=(r,e,t)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[Lt(x("a",r,e,t),x("b",r,e,t))];case"AddN":return[Nd(x("tensors",r,e,t))];case"FloorMod":case"Mod":return[Ah(x("a",r,e,t),x("b",r,e,t))];case"Mul":return[Ye(x("a",r,e,t),x("b",r,e,t))];case"RealDiv":case"Div":return[xr(x("a",r,e,t),x("b",r,e,t))];case"DivNoNan":return[nh(x("a",r,e,t),x("b",r,e,t))];case"FloorDiv":return[qi(x("a",r,e,t),x("b",r,e,t))];case"Sub":return[_r(x("a",r,e,t),x("b",r,e,t))];case"Minimum":return[Nh(x("a",r,e,t),x("b",r,e,t))];case"Maximum":return[Th(x("a",r,e,t),x("b",r,e,t))];case"Pow":return[Lh(x("a",r,e,t),x("b",r,e,t))];case"SquaredDifference":return[sg(x("a",r,e,t),x("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var lA=(r,e,t)=>{switch(r.op){case"Abs":case"ComplexAbs":return[Td(x("x",r,e,t))];case"Acos":return[Sd(x("x",r,e,t))];case"Acosh":return[kd(x("x",r,e,t))];case"Asin":return[Dd(x("x",r,e,t))];case"Asinh":return[Od(x("x",r,e,t))];case"Atan":return[Fd(x("x",r,e,t))];case"Atan2":return[Pd(x("x",r,e,t),x("y",r,e,t))];case"Atanh":return[Ld(x("x",r,e,t))];case"Ceil":return[Hd(x("x",r,e,t))];case"Complex":return[Dt(x("real",r,e,t),x("imag",r,e,t))];case"Cos":return[Yd(x("x",r,e,t))];case"Cosh":return[Jd(x("x",r,e,t))];case"Elu":return[Qi(x("x",r,e,t))];case"Erf":return[sh(x("x",r,e,t))];case"Exp":return[Xa(x("x",r,e,t))];case"Expm1":return[ih(x("x",r,e,t))];case"Floor":return[uh(x("x",r,e,t))];case"Log":return[nu(x("x",r,e,t))];case"Log1p":return[dh(x("x",r,e,t))];case"Imag":return[xs(x("x",r,e,t))];case"Neg":return[hh(x("x",r,e,t))];case"Reciprocal":return[Kh(x("x",r,e,t))];case"Real":return[Vn(x("x",r,e,t))];case"Relu":return[iu(x("x",r,e,t))];case"Round":return[lu(x("x",r,e,t))];case"Selu":return[Yh(x("x",r,e,t))];case"Sigmoid":return[Ki(x("x",r,e,t))];case"Sin":return[Zh(x("x",r,e,t))];case"Sign":return[Qh(x("x",r,e,t))];case"Sinh":return[eg(x("x",r,e,t))];case"Softplus":return[gh(x("x",r,e,t))];case"Sqrt":return[og(x("x",r,e,t))];case"Square":return[Rh(x("x",r,e,t))];case"Tanh":return[Vd(x("x",r,e,t))];case"Tan":return[ig(x("x",r,e,t))];case"ClipByValue":return[jd(x("x",r,e,t),x("clipValueMin",r,e,t),x("clipValueMax",r,e,t))];case"Relu6":return[uu(x("x",r,e,t))];case"Rsqrt":return[Xh(qe(r.inputNames[0],e,t))];case"Prod":return[au(x("x",r,e,t),x("axes",r,e,t))];case"LeakyRelu":return[tu(x("x",r,e,t),x("alpha",r,e,t))];case"Prelu":return[su(x("x",r,e,t),x("alpha",r,e,t))];case"IsNan":return[ch(qe(r.inputNames[0],e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Ft(r,e,t=""){if(!(typeof r=="number"||typeof e=="number")){w.assert(r.length===e.length,()=>t+` Shapes ${r} and ${e} must match`);for(let n=0;n<r.length;n++){let o=r[n],s=e[n];w.assert(o<0||s<0||o===s,()=>t+` Shapes ${r} and ${e} must match`)}}}function cA(r){return!(typeof r=="number"||r.some(e=>e<0))}function di(r,e,t){let n=qp(r,t),o=!cA(n);if(o&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(o&&e.forEach(s=>{n=qp(s.shape,n)}),!cA(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function qp(r,e){if(typeof r=="number")return e;if(typeof e=="number")return r;if(r.length!==e.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${e}`);let t=[];for(let n=0;n<r.length;++n){let o=r[n],s=e[n];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${e}`);t[n]=o>=0?o:s}return t}var hy=class{constructor(e,t,n,o,s,i,a){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=He(0),er(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ft(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,er(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,o)=>this.write(n,t[o]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let o=0;o<this.size();o++)e.push(o)}if(e.length===0)return vt([],[0].concat(this.elementShape));let n=this.readMany(e);return Ft(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),yr(n,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return vt([],[0].concat(this.elementShape));let t=[];for(let o=0;o<this.size();o++)t.push(o);let n=this.readMany(t);return Ft(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Ht(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,br(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,o=e.map(u=>(n+=u,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,i=[];xe(()=>{t=W(t,[1,n,s]);for(let u=0;u<e.length;++u){let l=u===0?0:o[u-1],c=[0,l,0],p=[1,e[u],s];i[u]=W(Ct(t,c,p),this.elementShape)}return i});let a=[];for(let u=0;u<e.length;u++)a[u]=u;this.writeMany(a,i)}};var Us=class{constructor(e,t,n,o=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e!=null&&e.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Ft(t,s.shape,"TensorList shape mismatch: "),er(s)}),this.idTensor=He(0),this.maxNumElements=o,er(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Us([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Ft(e,this.elementShape,"TensorList shape mismatch: ");let o=di(this.elementShape,this.tensors,e);return xe(()=>{let s=this.tensors.map(i=>W(i,o));return yr(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=di(this.elementShape,this.tensors,e),o=this.tensors.pop();return Ft(o.shape,e,"TensorList shape mismatch: "),W(o,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Ft(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");er(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Ft(this.tensors[e].shape,t,"TensorList shape mismatch: ");let o=di(this.elementShape,this.tensors,t);return W(this.tensors[e],o)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Ft(this.elementShape,t.shape,"TensorList shape mismatch: "),er(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Ft(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let o=di(this.elementShape,this.tensors,n);return e.length===0?vt([],[0].concat(o)):xe(()=>{let s=e.map(i=>W(this.tensors[i],o));return yr(s,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Ft(this.elementShape,t,"TensorList shape mismatch: ");let n=di(this.elementShape,this.tensors,t);return this.size()===0?vt([],[0].concat(n)):xe(()=>{let o=this.tensors.map(s=>W(s,n));return Ht(o,0)})}};function pA(r,e,t){let n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==t)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${t}`);let o=r.shape.slice(1);Ft(o,e,"TensorList shape mismatch: ");let s=br(r);return new Us(s,e,n)}function mA(r,e,t){return new Us([],r,e,t)}function fA(r,e,t,n){if(e.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${r.shape[0]}`);let o=Math.max(...e);if(n!=null&&n!==-1&&o>=n)throw new Error(`Max index must be < array size (${o}  vs. ${n})`);let s=new Us([],t,r.dtype,n),i=br(r,0);return e.forEach((a,u)=>{s.setItem(a,i[u])}),s}function dA(r,e,t){let n=0,o=e.map(c=>(n+=c,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),i=qp(s,t),a=n===0?0:r.size/n,u=xe(()=>{let c=[];r=W(r,[1,n,a]);for(let p=0;p<e.length;++p){let m=p===0?0:o[p-1],f=[0,m,0],d=[1,e[p],a];c[p]=W(Ct(r,f,d),i)}return r.dispose(),c}),l=new Us([],t,r.dtype,e.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}var hA=async(r,e,t)=>{switch(r.op){case"If":case"StatelessIf":{let n=x("thenBranch",r,e,t),o=x("elseBranch",r,e,t),s=x("cond",r,e,t),i=x("args",r,e,t);return(await s.data())[0]?t.functionMap[n].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap):t.functionMap[o].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{let n=x("body",r,e,t),o=x("cond",r,e,t),s=x("args",r,e,t),i=await t.functionMap[o].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),a=s.map(c=>c.id),u=await i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let l=s;for(;u[0];){let c=l;l=await t.functionMap[n].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);let p=l.map(f=>f.id);c.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()});let m=await t.functionMap[o].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);u=await m[0].data(),m.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()})}return l}case"LoopCond":{let n=x("pred",r,e,t);return[ur(n)]}case"Switch":{let n=x("pred",r,e,t),o=x("data",r,e,t);return o.kept||(o=ur(o)),(await n.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let n=r.inputNames.find(o=>qe(o,e,t)!==void 0);if(n){let o=qe(n,e,t);return[ur(o)]}return}case"Enter":{let n=x("frameName",r,e,t),o=x("tensor",r,e,t);return t.enterFrame(n),[ur(o)]}case"Exit":{let n=x("tensor",r,e,t);return t.exitFrame(),[ur(n)]}case"NextIteration":{let n=x("tensor",r,e,t);return t.nextIteration(),[ur(n)]}case"TensorArrayV3":{let n=x("size",r,e,t),o=x("dtype",r,e,t),s=x("elementShape",r,e,t),i=x("dynamicSize",r,e,t),a=x("clearAfterRead",r,e,t),u=x("identicalElementShapes",r,e,t),l=x("name",r,e,t),c=new hy(l,o,n,s,u,i,a);return t.addTensorArray(c),[c.idTensor,He(1)]}case"TensorArrayWriteV3":{let n=x("tensorArrayId",r,e,t),o=x("index",r,e,t),s=x("tensor",r,e,t),i=t.getTensorArray(n.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let n=x("tensorArrayId",r,e,t),o=x("index",r,e,t);return[t.getTensorArray(n.id).read(o)]}case"TensorArrayGatherV3":{let n=x("tensorArrayId",r,e,t),o=x("indices",r,e,t),s=x("dtype",r,e,t);return[t.getTensorArray(n.id).gather(o,s)]}case"TensorArrayScatterV3":{let n=x("tensorArrayId",r,e,t),o=x("indices",r,e,t),s=x("tensor",r,e,t),i=t.getTensorArray(n.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let n=x("tensorArrayId",r,e,t),o=t.getTensorArray(n.id),s=x("dtype",r,e,t);return[o.concat(s)]}case"TensorArraySplitV3":{let n=x("tensorArrayId",r,e,t),o=x("tensor",r,e,t),s=x("lengths",r,e,t),i=t.getTensorArray(n.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let n=x("tensorArrayId",r,e,t),o=t.getTensorArray(n.id);return[He(o.size(),"int32")]}case"TensorArrayCloseV3":{let n=x("tensorArrayId",r,e,t),o=t.getTensorArray(n.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let n=x("tensorListId",r,e,t),o=x("index",r,e,t),s=x("tensor",r,e,t),i=t.getTensorList(n.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let n=x("tensorListId",r,e,t),o=x("index",r,e,t),s=x("elementShape",r,e,t),i=x("elementDType",r,e,t);return[t.getTensorList(n.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let n=x("indices",r,e,t),o=x("tensor",r,e,t),s=x("elementShape",r,e,t),i=x("numElements",r,e,t),a=fA(o,n,s,i);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=x("elementShape",r,e,t),o=x("elementDType",r,e,t),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=x(s,r,e,t),a=mA(n,o,i);return t.addTensorList(a),[a.idTensor]}case"TensorListGather":{let n=x("tensorListId",r,e,t),o=x("indices",r,e,t),s=x("elementShape",r,e,t),i=x("elementDType",r,e,t);return[t.getTensorList(n.id).gather(o,i,s)]}case"TensorListStack":{let n=x("tensorListId",r,e,t),o=x("elementShape",r,e,t),s=x("elementDType",r,e,t),i=x("numElements",r,e,t);return[t.getTensorList(n.id).stack(o,s,i)]}case"TensorListFromTensor":{let n=x("tensor",r,e,t),o=x("elementShape",r,e,t),s=x("elementDType",r,e,t),i=pA(n,o,s);return t.addTensorList(i),[i.idTensor]}case"TensorListConcat":{let n=x("tensorListId",r,e,t),o=t.getTensorList(n.id),s=x("dtype",r,e,t),i=x("elementShape",r,e,t);return[o.concat(s,i)]}case"TensorListPushBack":{let n=x("tensorListId",r,e,t),o=x("tensor",r,e,t),s=t.getTensorList(n.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let n=x("tensorListId",r,e,t),o=x("elementShape",r,e,t),s=x("elementDType",r,e,t);return[t.getTensorList(n.id).popBack(o,s)]}case"TensorListSplit":{let n=x("tensor",r,e,t),o=x("elementShape",r,e,t),s=x("lengths",r,e,t),i=dA(n,s,o);return t.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function gA(r,e,t){let[n,o]=x("fusedOps",r,e,t),s=n==="biasadd",i=!s,a=o==="prelu",u=n==="fusedbatchnorm",l=x("numArgs",r,e,t);if(s){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=x("strides",r,e,t),p=Pu(r,e,t),m=x("dataFormat",r,e,t).toUpperCase(),f=x("dilations",r,e,t),[d,h]=x("args",r,e,t);i&&(h=d,d=void 0);let g=x("leakyreluAlpha",r,e,t);return{stride:c,pad:p,dataFormat:m,dilations:f,biasArg:d,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var xA=(r,e,t)=>{switch(r.op){case"Conv1D":{let n=x("stride",r,e,t),o=x("pad",r,e,t),s=x("dataFormat",r,e,t).toUpperCase(),i=x("dilation",r,e,t);return[qd(x("x",r,e,t),x("filter",r,e,t),n,o,s,i)]}case"Conv2D":{let n=x("strides",r,e,t),o=Pu(r,e,t),s=x("dataFormat",r,e,t).toUpperCase(),i=x("dilations",r,e,t);return[hs(x("x",r,e,t),x("filter",r,e,t),[n[1],n[2]],o,s,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:n,pad:o,dataFormat:s,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=gA(r,e,t);return[Cs.conv2d({x:x("x",r,e,t),filter:x("filter",r,e,t),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:n,pad:o,dataFormat:s,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=gA(r,e,t);return[Cs.depthwiseConv2d({x:x("x",r,e,t),filter:x("filter",r,e,t),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let n=x("outputShape",r,e,t),o=x("strides",r,e,t),s=Pu(r,e,t);return[Kd(x("x",r,e,t),x("filter",r,e,t),n,[o[1],o[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let n=x("strides",r,e,t),o=Pu(r,e,t),s=x("dilations",r,e,t),i=x("dataFormat",r,e,t).toUpperCase();return[Yi(x("input",r,e,t),x("filter",r,e,t),[n[1],n[2]],o,i,[s[1],s[2]])]}case"Conv3D":{let n=x("strides",r,e,t),o=x("pad",r,e,t),s=x("dataFormat",r,e,t).toUpperCase(),i=x("dilations",r,e,t);return[Xd(x("x",r,e,t),x("filter",r,e,t),[n[1],n[2],n[3]],o,s,[i[1],i[2],i[3]])]}case"AvgPool":{let n=x("strides",r,e,t),o=x("pad",r,e,t),s=x("kernelSize",r,e,t);return[Ud(x("x",r,e,t),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPool":{let n=x("strides",r,e,t),o=x("pad",r,e,t),s=x("kernelSize",r,e,t);return[vh(x("x",r,e,t),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPoolWithArgmax":{let n=x("strides",r,e,t),o=x("pad",r,e,t),s=x("kernelSize",r,e,t),i=x("includeBatchInIndex",r,e,t),{result:a,indexes:u}=Ch(x("x",r,e,t),[s[1],s[2]],[n[1],n[2]],o,i);return[a,u]}case"AvgPool3D":{let n=x("strides",r,e,t),o=x("pad",r,e,t),s=x("kernelSize",r,e,t);return[Wd(x("x",r,e,t),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"MaxPool3D":{let n=x("strides",r,e,t),o=x("pad",r,e,t),s=x("kernelSize",r,e,t);return[Ih(x("x",r,e,t),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"Dilation2D":{let n=x("strides",r,e,t),o=x("pad",r,e,t),s=x("dilations",r,e,t),i=n[1],a=n[2],u=s[1],l=s[2];return[th(x("x",r,e,t),x("filter",r,e,t),[i,a],o,[u,l],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var _A=(r,e,t)=>{switch(r.op){case"Fill":{let n=x("shape",r,e,t),o=x("dtype",r,e,t),s=x("value",r,e,t);return[eu(n,s,o)]}case"LinSpace":{let n=x("start",r,e,t),o=x("stop",r,e,t),s=x("num",r,e,t);return[mh(n,o,s)]}case"Multinomial":{let n=x("logits",r,e,t),o=x("numSamples",r,e,t),s=x("seed",r,e,t);return[$h(n,o,s)]}case"OneHot":{let n=x("indices",r,e,t),o=x("depth",r,e,t),s=x("onValue",r,e,t),i=x("offValue",r,e,t);return[Id(n,o,s,i)]}case"Ones":return[Hc(x("shape",r,e,t),x("dtype",r,e,t))];case"OnesLike":return[Oh(x("x",r,e,t))];case"RandomUniform":return[qh(x("shape",r,e,t),x("minval",r,e,t),x("maxval",r,e,t),x("dtype",r,e,t))];case"Range":{let n=x("start",r,e,t),o=x("stop",r,e,t),s=x("step",r,e,t);return[Ja(n,o,s,x("dtype",r,e,t))]}case"TruncatedNormal":{let n=x("shape",r,e,t),o=x("mean",r,e,t),s=x("stdDev",r,e,t),i=x("seed",r,e,t);return[lg(n,o,s,x("dtype",r,e,t),i)]}case"Zeros":return[rr(x("shape",r,e,t),x("dtype",r,e,t))];case"ZerosLike":return[gs(x("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function gy(r,e,t){let n=x("boxes",r,e,t),o=x("scores",r,e,t),s=x("maxOutputSize",r,e,t),i=x("iouThreshold",r,e,t),a=x("scoreThreshold",r,e,t),u=x("softNmsSigma",r,e,t);return{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}}var yA=async(r,e,t)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}=gy(r,e,t),l=await zn.nonMaxSuppressionWithScoreAsync(n,o,s,i,a,u);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a}=gy(r,e,t),u=x("padToMaxOutputSize",r,e,t),l=await zn.nonMaxSuppressionPaddedAsync(n,o,s,i,a,u);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a}=gy(r,e,t);return[await zn.nonMaxSuppressionAsync(n,o,s,i,a)]}case"Where":{let n=ge(x("condition",r,e,t),"bool"),o=[await cg(n)];return n.dispose(),o}case"ListDiff":return Jh(x("x",r,e,t),x("y",r,e,t));default:throw TypeError(`Node type ${r.op} is not implemented`)}};var bA=(r,e,t)=>{switch(r.op){case"TopKV2":{let n=x("x",r,e,t),o=x("k",r,e,t),s=x("sorted",r,e,t),i=ug(n,o,s);return[i.values,i.indices]}case"Unique":{let n=x("x",r,e,t),o=qc(n);return[o.values,o.indices]}case"UniqueV2":{let n=x("x",r,e,t),o=x("axis",r,e,t),s=qc(n,o);return[s.values,s.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var wA=(r,e,t)=>{switch(r.op){case"Const":return e[r.name];case"PlaceholderWithDefault":let n=x("default",r,e,t);return[qe(r.name,e,t)||n];case"Placeholder":return[qe(r.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let l=x("x",r,e,t);return[ur(l)]}case"IdentityN":return x("x",r,e,t).map(l=>ur(l));case"Snapshot":let o=x("x",r,e,t);return[ur(o)];case"Shape":return[lt(x("x",r,e,t).shape,"int32")];case"ShapeN":return x("x",r,e,t).map(l=>lt(l.shape));case"Size":return[He(x("x",r,e,t).size,"int32")];case"Rank":return[He(x("x",r,e,t).rank,"int32")];case"NoOp":return[He(1)];case"Print":let s=x("x",r,e,t),i=x("data",r,e,t),a=x("message",r,e,t),u=x("summarize",r,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let l=0;l<i.length;l++)console.log(Array.prototype.slice.call(i[l].dataSync()).slice(0,u));return[s];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var xy=class{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=He(0),this.tensorMap=new Map,er(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return He(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),xe(()=>{let o=br(t),s=n.length,i=o.length;w.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let u=n[a],l=o[a];er(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return xe(()=>{let o=[];for(let s=0;s<n.length;s++){let i=n[s],a=this.findWithDefault(i,t);o.push(a)}return yr(o)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}};var vA=async(r,e,t,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{let o=x("keyDType",r,e,t),s=x("valueDType",r,e,t),i=new xy(o,s);return n.addHashTable(r.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{let o=x("tableHandle",r,e,t,n),s=x("keys",r,e,t),i=x("values",r,e,t);return[await n.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=x("tableHandle",r,e,t,n),s=x("keys",r,e,t),i=x("defaultValue",r,e,t);return[await n.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=x("tableHandle",r,e,t,n);return[n.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var IA=(r,e,t)=>{switch(r.op){case"ResizeBilinear":{let n=x("images",r,e,t),o=x("size",r,e,t),s=x("alignCorners",r,e,t),i=x("halfPixelCenters",r,e,t);return[zn.resizeBilinear(n,[o[0],o[1]],s,i)]}case"ResizeNearestNeighbor":{let n=x("images",r,e,t),o=x("size",r,e,t),s=x("alignCorners",r,e,t),i=x("halfPixelCenters",r,e,t);return[zn.resizeNearestNeighbor(n,[o[0],o[1]],s,i)]}case"CropAndResize":{let n=x("image",r,e,t),o=x("boxes",r,e,t),s=x("boxInd",r,e,t),i=x("cropSize",r,e,t),a=x("method",r,e,t),u=x("extrapolationValue",r,e,t);return[zn.cropAndResize(n,o,s,i,a,u)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var CA=(r,e,t)=>{switch(r.op){case"Equal":return[Ji(x("a",r,e,t),x("b",r,e,t))];case"NotEqual":return[Dh(x("a",r,e,t),x("b",r,e,t))];case"Greater":return[Ya(x("a",r,e,t),x("b",r,e,t))];case"GreaterEqual":return[lh(x("a",r,e,t),x("b",r,e,t))];case"Less":return[ph(x("a",r,e,t),x("b",r,e,t))];case"LessEqual":return[ru(x("a",r,e,t),x("b",r,e,t))];case"LogicalAnd":return[yh(x("a",r,e,t),x("b",r,e,t))];case"LogicalNot":return[bh(x("a",r,e,t))];case"LogicalOr":return[wh(x("a",r,e,t),x("b",r,e,t))];case"Select":case"SelectV2":return[Wn(x("condition",r,e,t),x("a",r,e,t),x("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var TA=(r,e,t)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Pt(x("a",r,e,t),x("b",r,e,t),x("transposeA",r,e,t),x("transposeB",r,e,t))];case"Einsum":return[oh(x("equation",r,e,t),...x("tensors",r,e,t))];case"Transpose":return[Kw(x("x",r,e,t),x("perm",r,e,t))];case"_FusedMatMul":let[n,o]=x("fusedOps",r,e,t),s=n==="biasadd",i=o==="prelu",a=x("numArgs",r,e,t),u=x("leakyreluAlpha",r,e,t);if(s){if(i&&a!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[l,c]=x("args",r,e,t);return[Cs.matMul({a:x("a",r,e,t),b:x("b",r,e,t),transposeA:x("transposeA",r,e,t),transposeB:x("transposeB",r,e,t),bias:l,activation:o,preluActivationWeights:c,leakyreluAlpha:u})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var SA=(r,e,t)=>{switch(r.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Vc(x("x",r,e,t),x("mean",r,e,t),x("variance",r,e,t),x("offset",r,e,t),x("scale",r,e,t),x("epsilon",r,e,t))];case"FusedBatchNormV3":return[Vc(x("x",r,e,t),x("mean",r,e,t),x("variance",r,e,t),x("offset",r,e,t),x("scale",r,e,t),x("epsilon",r,e,t))];case"LRN":return[fh(x("x",r,e,t),x("radius",r,e,t),x("bias",r,e,t),x("alpha",r,e,t),x("beta",r,e,t))];case"Softmax":return[tg(x("x",r,e,t))];case"LogSoftmax":return[xh(x("x",r,e,t))];case"SparseToDense":return[Xc(x("sparseIndices",r,e,t),x("outputShape",r,e,t),x("sparseValues",r,e,t),x("defaultValue",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var kA=(r,e,t)=>{switch(r.op){case"Max":{let i=x("axis",r,e,t),a=x("keepDims",r,e,t);return[ou(x("x",r,e,t),i,a)]}case"Mean":{let i=x("axis",r,e,t),a=x("keepDims",r,e,t);return[Sh(x("x",r,e,t),i,a)]}case"Min":{let i=x("axis",r,e,t),a=x("keepDims",r,e,t);return[kh(x("x",r,e,t),i,a)]}case"Sum":{let i=x("axis",r,e,t),a=x("keepDims",r,e,t);return[Tt(x("x",r,e,t),i,a)]}case"All":{let i=x("axis",r,e,t),a=x("keepDims",r,e,t);return[Ed(x("x",r,e,t),i,a)]}case"Any":{let i=x("axis",r,e,t),a=x("keepDims",r,e,t);return[Ad(x("x",r,e,t),i,a)]}case"ArgMax":{let i=x("axis",r,e,t);return[Rd(x("x",r,e,t),i)]}case"ArgMin":{let i=x("axis",r,e,t);return[$d(x("x",r,e,t),i)]}case"Prod":{let i=x("axis",r,e,t),a=x("keepDims",r,e,t);return[au(x("x",r,e,t),i,a)]}case"Cumsum":{let i=x("axis",r,e,t),a=x("exclusive",r,e,t),u=x("reverse",r,e,t);return[Qd(x("x",r,e,t),i,a,u)]}case"Bincount":let n=x("x",r,e,t),o=x("weights",r,e,t),s=x("size",r,e,t);return[Xi(n,o,s)];case"DenseBincount":{let i=x("x",r,e,t),a=x("weights",r,e,t),u=x("size",r,e,t),l=x("binaryOutput",r,e,t);return[Zd(i,a,u,l)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var NA=(r,e,t)=>{switch(r.op){case"ConcatV2":case"Concat":{let n=x("n",r,e,t),o=x("axis",r,e,t),s=x("tensors",r,e,t);return s=s.slice(0,n),[Ht(s,o)]}case"Gather":{let n=x("x",r,e,t),o=x("indices",r,e,t);return[zc(n,ge(o,"int32"),0)]}case"GatherV2":{let n=x("axis",r,e,t),o=x("batchDims",r,e,t),s=x("x",r,e,t),i=x("indices",r,e,t);return[zc(s,ge(i,"int32"),n,o)]}case"Reverse":{let n=x("dims",r,e,t),o=[];for(let i=0;i<n.length;i++)n[i]&&o.push(i);let s=x("x",r,e,t);return[ys(s,o)]}case"ReverseV2":{let n=x("axis",r,e,t),o=x("x",r,e,t);return[ys(o,n)]}case"Slice":{let n=x("begin",r,e,t),o=x("size",r,e,t);return[Ct(x("x",r,e,t),n,o)]}case"StridedSlice":{let n=x("begin",r,e,t),o=x("end",r,e,t),s=x("strides",r,e,t),i=x("beginMask",r,e,t),a=x("endMask",r,e,t),u=x("ellipsisMask",r,e,t),l=x("newAxisMask",r,e,t),c=x("shrinkAxisMask",r,e,t),p=x("x",r,e,t);return[ag(p,n,o,s,i,a,u,l,c)]}case"Pack":return xe(()=>{let n=x("axis",r,e,t),o=x("tensors",r,e,t),s=o[0].shape,i=Za(o[0]).shape,a=o.map(u=>{let l=w.arraysEqual(u.shape,s);if(!l&&!w.arraysEqual(Za(u).shape,i))throw new Error("the input tensors shape does not match");return l?u:W(u,s)});return[yr(a,n)]});case"Unpack":{let n=x("axis",r,e,t),o=x("tensor",r,e,t);return br(o,n)}case"Tile":{let n=x("reps",r,e,t);return[Zi(x("x",r,e,t),n)]}case"Split":case"SplitV":{let n=x("axis",r,e,t),o=x("numOrSizeSplits",r,e,t),s=x("x",r,e,t);return Gn(s,o,n)}case"ScatterNd":{let n=x("indices",r,e,t),o=x("values",r,e,t),s=x("shape",r,e,t);return[Dv(n,o,s)]}case"GatherNd":{let n=x("x",r,e,t),o=x("indices",r,e,t);return[Fv(n,o)]}case"SparseToDense":{let n=x("sparseIndices",r,e,t),o=x("outputShape",r,e,t),s=x("sparseValues",r,e,t),i=x("defaultValue",r,e,t);return[Xc(n,s,o,s.dtype===i.dtype?i:ge(i,s.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var EA=(r,e,t)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:n,outputValues:o,emptyRowIndicator:s,reverseIndexMap:i}=pu.sparseFillEmptyRows(x("indices",r,e,t),x("values",r,e,t),x("denseShape",r,e,t),x("defaultValue",r,e,t));return[n,o,s,i]}case"SparseReshape":{let{outputIndices:n,outputShape:o}=pu.sparseReshape(x("inputIndices",r,e,t),x("inputShape",r,e,t),x("newShape",r,e,t));return[n,o]}case"SparseSegmentMean":return[pu.sparseSegmentMean(x("data",r,e,t),x("indices",r,e,t),x("segmentIds",r,e,t))];case"SparseSegmentSum":return[pu.sparseSegmentSum(x("data",r,e,t),x("indices",r,e,t),x("segmentIds",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var AA=(r,e,t)=>{switch(r.op){case"FFT":return[cu(x("x",r,e,t))];case"IFFT":return[Qa(x("x",r,e,t))];case"RFFT":return[ng(x("x",r,e,t))];case"IRFFT":return[rg(x("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var RA=(r,e,t)=>{switch(r.op){case"StringNGrams":{let{nGrams:n,nGramsSplits:o}=Zc.stringNGrams(x("data",r,e,t),x("dataSplits",r,e,t),x("separator",r,e,t),x("nGramWidths",r,e,t),x("leftPad",r,e,t),x("rightPad",r,e,t),x("padWidth",r,e,t),x("preserveShortSequences",r,e,t));return[n,o]}case"StringSplit":{let{indices:n,values:o,shape:s}=Zc.stringSplit(x("input",r,e,t),x("delimiter",r,e,t),x("skipEmpty",r,e,t));return[n,o,s]}case"StringToHashBucketFast":return[Zc.stringToHashBucketFast(x("input",r,e,t),x("numBuckets",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var $A=(r,e,t)=>{switch(r.op){case"Cast":return[ge(x("x",r,e,t),x("dtype",r,e,t))];case"ExpandDims":{let n=x("axis",r,e,t);return[ah(x("x",r,e,t),n)]}case"Squeeze":{let n=x("axis",r,e,t);return[Za(x("x",r,e,t),n)]}case"Reshape":return[W(x("x",r,e,t),x("shape",r,e,t))];case"MirrorPad":return[Eh(x("x",r,e,t),x("padding",r,e,t),x("mode",r,e,t))];case"PadV2":case"Pad":return[Fh(x("x",r,e,t),x("padding",r,e,t),x("constantValue",r,e,t))];case"SpaceToBatchND":{let n=x("blockShape",r,e,t),o=x("paddings",r,e,t);return[Ph(x("x",r,e,t),n,o)]}case"BatchToSpaceND":{let n=x("blockShape",r,e,t),o=x("crops",r,e,t);return[Gd(x("x",r,e,t),n,o)]}case"DepthToSpace":{let n=x("blockSize",r,e,t),o=x("dataFormat",r,e,t).toUpperCase();return[eh(x("x",r,e,t),n,o)]}case"BroadcastTo":return[ds(x("x",r,e,t),x("shape",r,e,t))];case"BroadcastArgs":return[zd(x("s0",r,e,t),x("s1",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function _y(r,e,t,n){let o=((s,i,a)=>{switch(s.category){case"arithmetic":return xe(()=>uA(s,i,a));case"basic_math":return xe(()=>lA(s,i,a));case"control":return hA(s,i,a);case"convolution":return xe(()=>xA(s,i,a));case"creation":return xe(()=>_A(s,i,a));case"dynamic":return yA(s,i,a);case"evaluation":return xe(()=>bA(s,i,a));case"image":return xe(()=>IA(s,i,a));case"graph":return xe(()=>wA(s,i,a));case"logical":return xe(()=>CA(s,i,a));case"matrices":return xe(()=>TA(s,i,a));case"normalization":return xe(()=>SA(s,i,a));case"reduction":return xe(()=>kA(s,i,a));case"slice_join":return xe(()=>NA(s,i,a));case"sparse":return xe(()=>EA(s,i,a));case"spectral":return xe(()=>AA(s,i,a));case"string":return xe(()=>RA(s,i,a));case"transformation":return xe(()=>$A(s,i,a));case"hash_table":return vA(s,i,a,n);case"custom":let u=Op(s.op);if(u&&u.customExecutor)return u.customExecutor(new dy(s,i,a));throw TypeError(`Custom op ${s.op} is not registered.`);default:throw TypeError(`Unknown op '${s.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,e,t);return w.isPromise(o)?o.then(s=>[].concat(s)):[].concat(o)}var Kp=class{constructor(e={},t={},n={},o={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function by(r,e,t,n){let o=new Set,s=[],i=null,a=null,u=new Set,l=Object.keys(r).map(m=>xt(m)[0]),c=[];n!=null&&(c=n.map(m=>xt(m.name)[0]));let p=[...e];for(;p.length>0;){let m=p.pop();if((yy(m)||XV(m)||YV(m))&&i==null&&(i=m,a=i.children.map(f=>f.name).filter(f=>o.has(f))),o.add(m.name),t[m.name]==null&&l.indexOf(m.name)===-1&&c.indexOf(m.name)===-1){if(m.inputs.length===0){s.push(m.name);continue}m.inputs.forEach(f=>{u.has(f.name)||(u.add(f.name),p.push(f))})}}return{inputs:r,outputs:e,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function DA(r,e,t){let{usedNodes:n,inputs:o}=t,s=[],i=Object.keys(o).map(c=>xt(c)[0]).map(c=>r.nodes[c]),a=r.initNodes;i.forEach(c=>{n.has(c.name)&&s.push(c)}),r.weights.forEach(c=>{n.has(c.name)&&s.push(c)}),a!=null&&a.forEach(c=>{n.has(c.name)&&s.push(c)});let u=new Set,l=[];for(;s.length>0;){let c=s.pop();u.add(c.name),e[c.name]||l.push(c),c.children.forEach(p=>{!u.has(p.name)&&n.has(p.name)&&p.inputs.every(m=>u.has(m.name))&&s.push(p)})}return l}var JV=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],QV=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],ZV=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function yy(r){return JV.indexOf(r.op)>=0}function XV(r){return QV.indexOf(r.op)>=0}function YV(r){return ZV.indexOf(r.op)>=0}var hi=class{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new hi(e.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(n=>e[n].map(o=>o.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){let n=e.map(s=>s.name).sort(),o=t.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(e,t){let n=by(e,t,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let a=t.map(l=>l.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}return DA(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let o=n.map(p=>this.graph.nodes[xt(p)[0]]),s=t.map(p=>xt(p)[0]),i=s.map(p=>this.graph.nodes[p]);i.length===0&&(i=this._outputs);let a=this.getCompilationKey(o,i),u=this.compiledMap.get(a);u==null&&(u=this.compile(e,i),this.compiledMap.set(a,u));let l={},c={};return xe(()=>{let p=new Kp(this.weightMap,l,c,this.functionExecutorMap),m=Object.assign({},this.weightMap);Object.keys(e).forEach(h=>{let[g,y]=xt(h),I=[];I[y]=e[h],m[g]=I});let f=this.getFrozenTensorIds(m),d={};for(let h=0;h<u.length;h++){let g=u[h];if(!m[g.name]){let y=_y(g,m,p,this._resourceManager);if(w.isPromise(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);m[g.name]=y,this.checkTensorForDisposal(g.name,g,m,p,f,s,d)}}return this.parent==null&&p.dispose(f),t.map(h=>qe(h,m,p))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(o=>o.id)));return new Set(t)}checkTensorForDisposal(e,t,n,o,s,i,a){t.category==="control"||i.indexOf(e)!==-1||(n[e].forEach(u=>{u!=null&&(a[u.id]=(a[u.id]||0)+t.children.length)}),t.inputs.forEach(u=>{if(u.category!=="control"){let l=oA(u.name,n,o);l!=null&&l.forEach(c=>{if(c&&!c.kept&&!s.has(c.id)){let p=a[c.id];p===1?(c.dispose(),delete a[c.id]):p!=null&&a[c.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,n=!1,o={},s={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));let i=new Kp(this.weightMap,o,s,this.functionExecutorMap),a=await this.executeWithControlFlow(e,i,t,n),u=t.map(m=>qe(m,a,i)),l=u.map(m=>m.id),c=Object.keys(e).map(m=>e[m].id),p=new Set([...l,...c,...this.weightIds]);return Object.keys(a).forEach(m=>{a[m].forEach(d=>{d&&!d.kept&&!d.isDisposed&&!p.has(d.id)&&d.dispose()})}),this.parent==null&&i.dispose(p),u}async executeFunctionAsync(e,t,n){let o=e.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,o){let s=Object.keys(e),i=s.map(_=>this.graph.nodes[xt(_)[0]]),a=n.map(_=>xt(_)[0]),u=a.map(_=>this.graph.nodes[_]);u.length===0&&(u=this._outputs);let{usedNodes:l,missingInputs:c,dynamicNode:p,syncInputs:m}=by(e,u,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(_=>({node:_,contexts:t.currentContext})),d=Object.assign({},this.weightMap);Object.keys(e).forEach(_=>{let[N,R]=xt(_),F=[];F[R]=e[_],d[N]=F});let h={},g=this.getFrozenTensorIds(d),y={};for(;f.length>0;){let _=this.processStack(i,f,t,d,y,g,a,h,l);await Promise.all(_)}p==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let I=u.filter(_=>!yy(_)&&!qe(_.name,d,t)).map(_=>_.name);if(I.length>0){let _="";throw p!=null&&(_=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${I}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${_}`)}return d}processStack(e,t,n,o,s,i,a,u,l){let c=[];for(;t.length>0;){let p=t.pop();n.currentContext=p.contexts;let m="";if(p.node.op==="Enter"&&x("isConstant",p.node,o,n)&&([m]=ir(p.node.name,n)),o[p.node.name]==null){let f=_y(p.node,o,n,this._resourceManager);m||([m]=ir(p.node.name,n));let d=n.currentContext;w.isPromise(f)?c.push(f.then(h=>(o[m]=h,n.currentContext=d,this.checkTensorForDisposal(m,p.node,o,n,i,a,u),this.processChildNodes(p.node,t,n,o,s,l),h))):(o[m]=f,this.checkTensorForDisposal(m,p.node,o,n,i,a,u),this.processChildNodes(p.node,t,n,o,s,l))}else this.processChildNodes(p.node,t,n,o,s,l)}return c}processChildNodes(e,t,n,o,s,i){e.children.forEach(a=>{let[u]=ir(a.name,n);s[u]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!qe(l,o,n))&&(s[u]=!0,t.push({contexts:n.currentContext,node:a})):a.inputNames.every(l=>!!qe(l,o,n))&&(s[u]=!0,t.push({contexts:n.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[o]=xt(t),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===n.shape.length&&n.shape.every((u,l)=>i[l]===-1||i[l]===u);w.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&w.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){let t={};for(let n in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){let o=this._signature.inputs[n];t[o.name]=e[n]}else t[n]=e[n];return t}checkInputs(e){let t=Object.keys(e).filter(n=>{let[o]=xt(n);return this.graph.nodes[o]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{let[n]=xt(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}};var wy=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}};var eG="?tfjs-format=file",tG="model.json",vy=class{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new wy}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=Mn.browserHTTPRequest(e,this.loadOptions);else{let t=Mn.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(Mn.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?n=this.artifacts.userDefinedMetadata.signature:n=this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let o=Mn.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new hi(Pp.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=Pp.Instance.transformGraph(e.modelInitializer);this.initializer=new hi(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){let n=Mn.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof ze)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,n,o)=>(t[n]=e[o],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function Iy(r,e={}){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&r.load==null&&(r.endsWith("/")||(r=r+"/"),r=`${r}${tG}${eG}`);let t=new vy(r,e);return await t.load(),t}var Xp=!0;function rG(r,e,t,n,o,s,i,a,u,l){let c=o[s],p=c*Yr(u),m=c,f=m*Yr(l),d=Cy(o),h=d*Yr(a),g=d*Yr(i),y=new DataView(r,e,f),I=[];if(l==="int64"){y.getBigInt64||console.log("Note: Falling back from getBigInt64 to getInt32. This is usually no problem.");for(let O=0;O<m;++O)y.getBigInt64?I.push(Number(y.getBigInt64(O*Yr(l),Xp))):I.push(Number(y.getInt32(O*Yr(l),Xp)))}else throw"not supported";e+=f;let _=new DataView(r,e,p),N=[];if(u==="float64")for(let O=0;O<c;++O)N.push(_.getFloat64(O*Yr(u),Xp));else throw"not supported";e+=p;let R=1;for(let O=o.length-1;O>s;--O)R*=o[O];let F=new DataView(r,e,h),D=new DataView(t,n,g);if(a==="int8"&&i==="float32")for(let O=0;O<d;++O){let U=Math.floor(O/R)%c,M=N[U],G=I[U],ee=(F.getInt8(O)-G)*M;D.setFloat32(O*4,ee,Xp)}else throw"not supported";return e+=h,n+=g,[e,n]}function nG(r,e,t,n,o){let s=new Int8Array(r,e,o),i=new Int8Array(t,n,o);for(let a=0;a<o;++a)i[a]=s[a];return[e+o,n+o]}async function OA(r,e){if(e.length!==1)throw"Unexpected number of shards.";let t=oG(r),n=e[0].buffer,o=new ArrayBuffer(t),s=0,i=0;for(let a of r)if(a.quant_type===0){let u=Yr(a.dtype),l=Cy(a.shape);[s,i]=nG(n,s,o,i,u*l)}else if(a.quant_type===1)[s,i]=rG(n,s,o,i,a.shape,a.quant_dim,a.dtype,a.qdtype,a.scale_dtype,a.offset_dtype);else throw"Unknown qtype "+a.quant_type;if(s!==n.byteLength)throw console.log(s,n.byteLength),"should not happen 1";if(i!==o.byteLength)throw"should not happen 2";return[new Uint8Array(o)]}function Cy(r){let e=1;for(let t of r)e*=t;return e}function Yr(r){let e=-1;if(r==="int32")e=4;else if(r==="float32")e=4;else if(r==="float64")e=8;else if(r==="int64")e=8;else if(r==="int8")e=1;else throw"Unknown type "+r;return e}function oG(r){let e=0;for(let t of r)e+=Yr(t.dtype)*Cy(t.shape);return e}var Sr;(function(r){r.TFJS_TFLITE="TFJS_TFLITE",r.TFJS_NATIVE="TFJS_NATIVE"})(Sr||(Sr={}));var Jr;(function(r){r.EXPRESS="EXPRESS",r.ADVANCED="ADVANCED"})(Jr||(Jr={}));var Qr;(function(r){r.RESTRICTED="RESTRICTED",r.UNRESTRICTED="UNRESTRICTED"})(Qr||(Qr={}));var Ws;(function(r){r.QAT="QAT",r.NO_QAT="NO_QAT"})(Ws||(Ws={}));var Zr;(function(r){r.BITS_8="BITS_8",r.BITS_16="BITS_16",r.BITS_32="BITS_32"})(Zr||(Zr={}));var Vs;(function(r){r.COMPACT="COMPACT",r.NORMAL="NORMAL"})(Vs||(Vs={}));var en;(function(r){r.BEST="BEST",r.LAST="LAST",r.CUSTOM="CUSTOM"})(en||(en={}));function sG(r){if(r===Zr.BITS_8)return 8;if(r===Zr.BITS_16)return 16;if(r===Zr.BITS_32)return 32;throw"should not happen"}function Ty(r){return r.url+="/lanmodel",FA(r)}function Sy(r){return r.url+="/boxmodel",FA(r)}function PA(r){return r.indexOf("tflite")!==-1}function FA(r){let e;if(r.format===Jr.EXPRESS)e=r.url+"/model.json";else if(r.format===Jr.ADVANCED)e=aG(r);else throw"Unknown url spec.";return e}function aG(r){let e=r.url,{qat:t,outputFormat:n,restriction:o,checkpoint:s}=r,i=r.modelType===Sr.TFJS_NATIVE?r.quantization:null;if(t===Ws.QAT)i===Zr.BITS_8&&(e+="/qat");else if(t!==Ws.NO_QAT)throw"Unknown qat mode "+t;if(s!==en.BEST&&console.warn("Using non-best checkpoint."),s===en.BEST)e+="/best";else if(s===en.LAST)e+="/last";else if(s===en.CUSTOM)e+="/custom";else throw"Unknown ckp selection "+s;if(n===Vs.NORMAL)e+="/normal";else if(n===Vs.COMPACT)e+="/compact";else throw"Unknown packing "+n;if(o===Qr.RESTRICTED)e+="_r";else if(o!==Qr.UNRESTRICTED)throw"Unknown restriction "+o;return r.modelType===Sr.TFJS_TFLITE?e+"/tflite":(e+="/tfjs/quant_",e+=sG(i),e+"/model.json")}async function iG(r,e){let t=0,n=[];for(;;){let{done:i,value:a}=await r.read();if(i)break;n.push(a),t+=a.length,e(a.length)}let o=new Uint8Array(t),s=0;for(let i of n)o.set(i,s),s+=i.length;return o}var LA=class{constructor(){this.cache_={},this.loadPromises_={},this.progressCbs_={}}async DownloadAndCreateModel(e,t){return await this.DownloadModel(e,t),await this.LoadFromCache_(e)}async DownloadModel(e,t){if(t&&this.SubscribeProgress_(e,t),e in this.loadPromises_&&await this.loadPromises_[e],e in this.cache_)return;let n=this.LoadAndCache_(e);return this.loadPromises_[e]=n,n}SubscribeProgress_(e,t){e in this.progressCbs_||(this.progressCbs_[e]=[]),this.progressCbs_[e].push(t)}PublishProgress_(e,t,n){if(!(e in this.progressCbs_))return;let o=this.progressCbs_[e];for(let s of o)s(t,n)}async LoadFromCache_(e){let t=async n=>{let o=n.toString();if(!(e in this.cache_)||!(o in this.cache_[e]))throw"Model cache miss.";return new Response(this.cache_[e][o],{status:200})};return PA(e)?null:{model:await Iy(e,{fetchFunc:t}),modelType:Sr.TFJS_NATIVE}}GetCacheForModel(e){if(!(e in this.cache_))throw"Model cache miss";let t={};return t[e]=this.cache_[e],t}FromModelsCache(e){this.cache_=e}async LoadAndCache_(e){this.cache_[e]={};let t=$().platform.fetch;if(PA(e)){let n=await t(e);this.cache_[e][e]=await n.blob()}else{let n=await t(e);this.cache_[e][e]=await n.blob();let o=await this.cache_[e][e].text(),s=JSON.parse(o),i=s.weightsManifest[0].paths,a=e.substr(0,e.lastIndexOf("/")+1),u=i.map(h=>a+h),l=u.map(h=>t(h)),c=await Promise.all(l),p=c.map(h=>+h.headers.get("Content-Length")),m=p.reduce((h,g)=>h+g),f=[];this.PublishProgress_(e,m,0);for(let h=0;h<p.length;++h)f.push(iG(c[h].body.getReader(),g=>{this.PublishProgress_(e,m,g)}));let d=await Promise.all(f);s.weightsManifest[0].__proxied&&(d=await OA(s.weightsManifest[0].weights,d));for(let h=0;h<p.length;++h)this.cache_[e][u[h]]=new Blob([d[h]])}}},kr=new LA;var MA="coords",BA="confidence",ky="classes",UA="compact",WA=[MA,BA,ky];function VA(r){let e=uG(r);return lG(e)}function uG(r){let e;if(GA(r))e=cG(r);else{let t=zA(r);e={coords:mG(gi(MA,r)),confidence:pG(gi(BA,r)),classes:[],restricted:t},gi(ky,r)&&(e.classes=fG(gi(ky,r)))}return e}function GA(r){return!!gi(UA,r)}function cG(r){if(!GA(r))throw"y0";let e=gi(UA,r);if(!Array.isArray(e))throw"y1";let t=e[0];if(t!==WA.length)throw"y3";if(typeof t!="number")throw"y5";let n=[],o=1;for(let u=0;u<t;++u){let l=e[o++];if(typeof l!="number")throw"y6";let c=[];for(let p=0;p<l;++p){let m=e[o++];if(typeof m!="number")throw"y7";c.push(m)}n.push(c)}let s=[];for(let u of n){s.push(HA(e,o,u));let l=1;for(let c of u)l*=c;o+=l}if(o!==e.length)throw"y10";let i={coords:[],confidence:-1,classes:[],restricted:zA(r)},a=WA;for(let u=0;u<a.length;++u){let l=a[u],c=s[u];i[l]=c}return i}function HA(r,e,t){if(t.length===3&&t[0]===1)return HA(r,e,[t[1],t[2]]);if(t.length>2)throw"Not yet implemented.";if(t.length===0)return r[e];if(t.length===1){let n=[];for(let o=0;o<t[0];++o)n.push(r[e+o]);return n}else if(t.length===2){let n=[];for(let o=0;o<t[0];++o){n.push([]);for(let s=0;s<t[1];++s)n[o].push(r[e+o*t[1]+s])}return n}else throw"zqq"}function pG(r){if(!Array.isArray(r))throw"h1";if(r=r[0],Array.isArray(r))throw"h2";return r}function mG(r){if(!Array.isArray(r))throw"g1";if(r=r[0],!Array.isArray(r))throw"g2";let e=[];for(let t=0;t<r.length;++t){let n=r[t];if(!Array.isArray(n))throw"g3";if(n.length!==2)throw"g4";let o=n[0],s=n[1];if(Array.isArray(o))throw"g5";if(Array.isArray(s))throw"g6";e.push([o,s])}return e}function dG(r){return[(r[0]+1)/2,(r[1]+1)/2]}function fG(r){if(!Array.isArray(r))throw"f1";if(r=r[0],!Array.isArray(r))throw"f2";let e=[];for(let t=0;t<r.length;++t){let n=r[t];if(!Array.isArray(n))throw"f3";if(n.length!==2)throw"f4";if(typeof n[0]!="number")throw"f5";if(typeof n[1]!="number")throw"f6";e.push([n[0],n[1]])}return e}function lG(r){return r=hG(r),gG(r)}function hG(r){let e=[];for(let t of r.coords)e.push(dG(t));return r.coords=e,r}function gG(r){let e=[];for(let t of r.classes)e.push(t[1]);return{coords:r.coords,confidence:r.confidence,classes:e,restricted:r.restricted}}function zA(r){for(let e of Object.keys(r))if(e.lastIndexOf("_r")===e.length-2)return!0;return!1}function gi(r,e){let t=["","_r"],n=["",":0"];for(let o of t)for(let s of n){let i=r+o+s;if(i in e)return e[i]}return null}var Lu=class{constructor(e,t){this.model_=e,this.blocking_=t}async Analyze(e){if(e.type===je.CANVAS)return this.AnalyzeTensor_(cs.fromPixels(e.canvas));if(e.type===je.TYPED_ARRAY||e.type===je.ARRAY)return this.AnalyzeTensor_(vt(e.data,e.shape,e.dtype));if(e.type===je.BITMAP)return this.AnalyzeTensor_(cs.fromPixels(e.data));throw"unknown type ";return null}async AnalyzeTensor_(e){let t=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]),n=this.ExtractAvailableKeys_(),o;if(this.model_.modelType===Sr.TFJS_NATIVE)o=this.EnsureResultIsArray_(this.model_.model.execute(t,n));else{let l=this.model_.model.predict(t);if(!("array"in l)&&!Array.isArray(l)){o=[];for(let c of n)o.push(l[c])}else o=this.EnsureResultIsArray_(l)}let s=[],i=[];if(this.blocking_)for(let l=0;l<o.length;++l)s.push(o[l].arraySync());else{for(let l=0;l<o.length;++l)i.push(o[l].array());s=await Promise.all(i)}let a=this.ConvertToNamedTensors_(s,n),u=VA(a);for(let l=0;l<o.length;++l)o[l].dispose(),e.dispose(),t.dispose();return u}ExtractAvailableKeys_(){let e=[];for(let t of this.model_.model.outputs)e.push(t.name);return e}ConvertToNamedTensors_(e,t){let n={};for(let o=0;o<e.length;++o)n[t[o]]=e[o];return n}EnsureResultIsArray_(e){return Array.isArray(e)?e:[e]}};var tn={DOWNLOAD:"DONE_DOWNLOAD",PROCESS:"DONE_PROCESS",UPDATE_COMP:"UPDATE_COMP",REQUEST_WASM_BINARY:"REQUEST_WASM_BINARY"},Nr={DOWNLOAD:"DOWNLOAD",PROCESS:"PROCESS",UPDATE_COMP:"UPDATE_COMP",WASM_BINARY_RESULT:"WASM_BINARY_RESULT"},Yp="NN_WORKER";var Ny=typeof window=="object"?document.currentScript:null;var jA=class{constructor(){this.workers_=new Map,this.MaybeRegisterWorkerFlagsHook_(),this.MaybeRegisterWorkerExecHook_()}RegisterWorker(e,t){this.workers_.set(e,t)}ExecuteWorker(e){let t=Ny.getAttribute("src"),n;if(t&&t.indexOf("http")===-1)t=window.location.origin+""+"/"+t,n='importScripts("'+t+'")';else if(n=Ny.innerHTML,!n)throw"Should not happen";let o=new Blob([n],{type:"application/javascript"}),s=new Worker(URL.createObjectURL(o));return s.postMessage({isFlagsMessage:!0,flags:Xe()}),s.postMessage({name:e,isWorkerNameMessage:!0}),s}MaybeRegisterWorkerFlagsHook_(){Yt()&&self.addEventListener("message",async e=>{let t=e.data;t.isFlagsMessage&&Ai(t.flags)})}MaybeRegisterWorkerExecHook_(){Yt()&&self.addEventListener("message",async e=>{let t=e.data;t.isWorkerNameMessage&&this.workers_.get(t.name)()})}},Jp=new jA;var qA=class{async Initialize(e,t,n){await this.UpdateComp(n),kr.FromModelsCache(e),this.model_=await kr.DownloadAndCreateModel(t),this.inf_=new Lu(this.model_,!0)}async Process(e){return await Qn(this.compConfig_),await this.inf_.Analyze(e)}async UpdateComp(e){this.compConfig_=e;let t;this.compConfig_.type===ct.TFJS_WASM&&(t=()=>this.wasmBinaryPromise_?this.wasmBinaryPromise_:this.wasmBinaryPromise_=new Promise(n=>{self.postMessage({type:tn.REQUEST_WASM_BINARY}),this.wasmBinaryPromiseResolve_=n})),await Qn(e,t)}DeliverWasmBinary(e){this.wasmBinaryPromiseResolve_(e)}};Yt()&&Jp.RegisterWorker(Yp,()=>{let r=new qA,e=self;e.addEventListener("message",async t=>{let n=t.data;if(n.type===Nr.DOWNLOAD){await r.Initialize(n.cache,n.url,n.compConfig);let o={type:tn.DOWNLOAD,id:n.id};e.postMessage(o)}else if(n.type===Nr.PROCESS){let o=await r.Process(n.data),s={type:tn.PROCESS,data:o,id:n.id};e.postMessage(s)}else if(n.type===Nr.UPDATE_COMP)await r.UpdateComp(n.compConf),e.postMessage({type:tn.UPDATE_COMP,id:n.id});else if(n.type===Nr.WASM_BINARY_RESULT)r.DeliverWasmBinary(n.blob);else throw"n1p"})});var Ey=class{constructor(e){this.config_=e,this.taskId_=0,this.pendingDownloadPromises_=new Map,this.pendingNNPromises_=new Map,this.initialized_=!1}async Initialize(){if(this.initialized_)return;this.initialized_=!0,this.worker_=Jp.ExecuteWorker(Yp),this.worker_.onmessage=s=>{this.ProcessWorkerResult_(s.data)},await kr.DownloadModel(this.config_.url);let e=kr.GetCacheForModel(this.config_.url),t=this.GetTaskId_(),n={type:Nr.DOWNLOAD,cache:e,url:this.config_.url,compConfig:this.config_.compConfig,id:t};return this.worker_.postMessage(n),new Promise(s=>{this.pendingDownloadPromises_.set(t,s)})}async Analyze(e){if(e.type!==je.TYPED_ARRAY&&e.type!==je.ARRAY&&e.type!==je.BITMAP)throw"not supported";let t=this.GetTaskId_(),n={type:Nr.PROCESS,data:e,id:t};return this.worker_.postMessage(n),new Promise(s=>{this.pendingNNPromises_.set(t,s)})}async UpdateComp(e){let t=this.GetTaskId_(),n={type:Nr.UPDATE_COMP,compConf:e,id:t};return this.worker_.postMessage(n),new Promise(s=>{this.pendingDownloadPromises_.set(t,s)})}GetCacheKey(){return"tfjs/"+this.config_.threadType+"/"+this.config_.url}async ProcessWorkerResult_(e){if(e.type===tn.DOWNLOAD){if(!this.pendingDownloadPromises_.has(e.id))throw"Worker result cache miss.";this.pendingDownloadPromises_.get(e.id)(),this.pendingDownloadPromises_.delete(e.id)}else if(e.type===tn.PROCESS){if(!this.pendingNNPromises_.has(e.id))throw"Worker result cache miss.";this.pendingNNPromises_.get(e.id)(e.data),this.pendingNNPromises_.delete(e.id)}else if(e.type===tn.REQUEST_WASM_BINARY){let t=await jg.FetchBestBinary();this.worker_.postMessage({type:Nr.WASM_BINARY_RESULT,blob:t})}else throw"should not happen"}GetTaskId_(){return this.taskId_++}};var Ay=class{constructor(e){this.config_=e,this.initialized_=!1}async Initialize(){if(this.initialized_)return;this.initialized_=!0,await this.UpdateComp(this.config_.compConfig);let e=await kr.DownloadAndCreateModel(this.config_.url);this.inf_=new Lu(e,this.config_.blocking)}async Analyze(e){return await Qn(this.config_.compConfig),await this.inf_.Analyze(e)}async UpdateComp(e){this.config_.compConfig=e,await Qn(e)}GetCacheKey(){return"tfjs/"+this.config_.threadType+"/"+this.config_.url}};var Gs={MAIN_THREAD:"MAIN_THREAD",WORKER_THREAD:"WORKER_THREAD"};function KA(r){if(r.threadType===Gs.MAIN_THREAD)return new Ay(r);if(r.threadType===Gs.WORKER_THREAD)return new Ey(r);throw"p"}var XA=null,Ry={};function xG(r){let e=YA(r).GetCacheKey();if(e in Ry){let t=Ry[e];if(!fi(t.config,r))throw"Configs must be identical";return t.backend}return null}function YA(r){if("tfjs"in r)return KA(r);throw"q"}function _G(r,e){Ry[r.GetCacheKey()]={backend:r,config:e}}function JA(r){if(XA)return XA(r);let e=xG(r);if(e)return e;let t=YA(r);return _G(t,r),t}var QA=[[16,16],[32,32],[40,30],[42,11],[42,32],[48,32],[60,40],[64,64],[72,64],[75,64],[84,48],[96,64],[96,64],[96,65],[96,96],[101,80],[102,64],[128,36],[128,48],[128,128],[140,192],[144,168],[150,40],[160,102],[160,120],[160,144],[160,152],[160,160],[160,200],[160,256],[208,176],[208,208],[220,176],[224,144],[240,64],[240,160],[240,240],[256,192],[256,212],[256,224],[256,256],[256,256],[272,340],[280,192],[312,390],[320,192],[320,200],[320,208],[320,224],[320,240],[320,256],[320,320],[320,400],[376,240],[384,288],[400,240],[400,270],[400,300],[416,352],[432,128],[432,240],[480,234],[480,250],[480,272],[480,320],[480,500],[512,192],[512,212],[512,256],[512,256],[512,342],[512,384],[560,192],[600,480],[640,200],[640,240],[640,256],[640,320],[640,350],[640,360],[640,400],[640,480],[640,512],[720,348],[720,350],[720,364],[768,480],[800,240],[800,352],[800,480],[800,600],[832,624],[848,480],[854,480],[960,540],[960,544],[960,640],[960,720],[1024,576],[1024,600],[1024,640],[1024,768],[1024,800],[1024,1024],[1080,1200],[1120,832],[1136,640],[1138,640],[1152,720],[1152,768],[1152,864],[1152,900],[1280,720],[1280,768],[1280,800],[1280,854],[1280,960],[1280,1024],[1334,750],[1366,768],[1400,1050],[1440,900],[1440,900],[1440,960],[1440,1024],[1440,1080],[1440,1440],[1600,768],[1600,900],[1600,1024],[1600,1200],[1600,1280],[1680,1050],[1776,1e3],[1792,1344],[1800,1440],[1856,1392],[1920,1080],[1920,1200],[1920,1280],[1920,1400],[1920,1440],[2048,1080],[2048,1152],[2048,1280],[2048,1536],[2160,1200],[2160,1440],[2256,1504],[2280,1080],[2304,1440],[2304,1728],[2436,1125],[2538,1080],[2560,1080],[2560,1440],[2560,1600],[2560,1700],[2560,1800],[2560,1920],[2560,2048],[2732,2048],[2736,1824],[2800,2100],[2880,900],[2880,1440],[2880,1620],[2880,1800],[2960,1440],[3e3,2e3],[3200,1800],[3200,2048],[3200,2400],[3240,2160],[3440,1440],[3840,1600],[3840,2160],[3840,2400],[4096,2160],[4096,2304],[4096,3072],[4480,2520],[4500,3e3],[5120,2160],[5120,2880],[5120,3200],[5120,4096],[6016,3384],[6400,4096],[6400,4800],[6480,3240],[7680,4320],[7680,4800],[8192,4320],[8192,4608],[8192,8192],[10240,4320],[15360,8640]];function ZA(r,e){let t=1e-6,n=r/e,o=[];for(let s=QA.length-1;s>=0;--s){let i=QA[s],a=i[0]/i[1];Math.abs(n-a)>t||i[0]>r||o.push(i)}return o}function Dy(r){let e=document.createElement("video"),{width:t,height:n}=$y(r);return e.srcObject=r,e.width=t,e.height=n,e.setAttribute("autoplay",""),e.setAttribute("playsinline","true"),e}function $y(r){return{width:r.getVideoTracks()[0].getSettings().width,height:r.getVideoTracks()[0].getSettings().height}}var Oy={ABORT_ERROR:"AbortError",NOT_ALLOWED_ERROR:"NotAllowedError",NOT_FOUND_ERROR:"NotFoundError",NOT_READABLE_ERROR:"NotReadableError",OVERCONSTRAINTED_ERROR:"OverconstrainedError",SECURITY_ERROR:"SecurityError",TYPE_ERROR:"TypeError"},yG=new Set(Object.values(Oy));async function eR(r){try{return{stream:await navigator.mediaDevices.getUserMedia(r)}}catch(e){if(yG.has(e.name))return{stream:null,error:e.name};throw e}}async function tR(r,e,t){let n=window.screen.width,o=window.screen.height,s=ZA(n,o),i=n*r,a=o*r;s=s.filter(u=>u[0]>=e*n&&u[0]<=t*n),s.sort((u,l)=>{let c=Math.abs(u[0]-i),p=Math.abs(l[0]-i);return c===p?u[0]<l[0]?1:-1:c<p?-1:1});for(let u of s){let l=await eR({audio:!1,video:{facingMode:"user",width:{exact:u[0]},height:{exact:u[1]},frameRate:{ideal:60}}});if(l.error!==Oy.OVERCONSTRAINTED_ERROR)return l}return eR({audio:!1,video:{facingMode:"user",width:{ideal:i},height:{ideal:a},frameRate:{ideal:60}}})}function rR(r,e){if(typeof r!="object")throw"s";let t=null;for(let n of e){if(!(n in r))throw n+" not found in target.";let o=r[n].bind(r);r[n]=(...s)=>{if(t)throw"Call to "+t+" has not yet finished, yet "+n+" was called.";t=n;let i=o(...s);return i!=null&&typeof i=="object"&&"then"in i?i.then(()=>{t=null}):t=null,i}}}var Mu={AUTO:"AUTO",WASM:"WASM",WEBGL:"WEBGL"},ne={NUM_WARMUP_FRAMES:20,WARMUP_CANVAS_WIDTH:640,WARMUP_CANVAS_HEIGHT:360,WARMUP_TIMEOUT_MS:1e4,NUM_ASSESSMENT_FRAMES:10,ASSESSMENT_TIMEOUT_MS:1e4,MIN_FPS_FOR_INSTANT_COMP_SELECTION:15,HIGH_LATENCY_NUM_FRAMES:10,HIGH_LATENCY_THRESHOLD_MS:300,LOW_THROUGHPUT_NUM_FRAMES:0,LOW_THROUGHPUT_THRESHOLD_MS:99999999,ANALYSIS_SLACK:.75,ANALYSIS_USE_LAN_HEATMAP_CONFIDENCE:!1,ANALYSIS_USE_BOX_HEATMAP_CONFIDENCE:!1,ANALYSIS_MIN_LAN_CONFIDENCE:.35,ANALYSIS_INITIAL_MIN_LAN_CONFIDENCE:.35,ANALYSIS_INITIAL_MIN_BOX_CONFIDENCE:.38,ANALYSIS_INITIAL_BOX_GOOD_FRAMES:1,ANALYSIS_INITIAL_LAN_GOOD_FRAMES:1,ANALYSIS_BOX_RESIZE_MODE:Bs.SCALE,ANALYSIS_LAN_RESIZE_MODE:Bs.SCALE,ANALYSIS_MIN_VISIBLE_LAN_COORDINATES:5,ANALYSIS_USE_POST_INTERVAL:!1,ANALYSIS_BOX_HAND_THRESHOLD:.5,ANALYSIS_BOX_FLIP_THRESHOLD:.5,ANALYSIS_LAN_HAND_THRESHOLD:.75,ANALYSIS_LAN_PINCH_THRESHOLD:.2,ANALYSIS_LAN_FIST_THRESHOLD:.5,ANALYSIS_LAN_FLIP_THRESHOLD:.5,ANALYSIS_MIN_REQ_BORDER_DISTANCE:-1,LAN_NN_WIDTH:224,LAN_NN_HEIGHT:224,BOX_NN_WIDTH:128,BOX_NN_HEIGHT:128,BOX_MODEL_RESTRICTION:Qr.UNRESTRICTED,BOX_MODEL_8BIT_QAT:Ws.QAT,BOX_MODEL_QUANTIZATION:Zr.BITS_8,BOX_MODEL_OUTPUT_FORMAT:Vs.NORMAL,BOX_MODEL_CHECKPOINT_SELECTION:en.BEST,LAN_MODEL_RESTRICTION:Qr.UNRESTRICTED,LAN_MODEL_8BIT_QAT:Ws.QAT,LAN_MODEL_QUANTIZATION:Zr.BITS_8,LAN_MODEL_OUTPUT_FORMAT:Vs.NORMAL,LAN_MODEL_CHECKPOINT_SELECTION:en.BEST,BACKEND_SELECTION:Mu.AUTO,BACKEND_COMP_AUTO_SELECTION_ORDER:[ct.TFJS_WEBGL,ct.TFJS_WASM],LAST_RESORT_BACKEND_COMP:ct.TFJS_WEBGL,CAMERA_TRACK_SOURCE_TARGET_RES_FACTOR:.5,CAMERA_TRACK_SOURCE_MIN_RES_FACTOR:.3,CAMERA_TRACK_SOURCE_MAX_RES_FACTOR:.7};function bG(r){if(r===ct.TFJS_WEBGL)return Jt.CANVAS_API;if(r===ct.TFJS_WASM){if(Ou())return Jt.NATIVE_WEBGL;if(Dp())return Jt.CANVAS_API_TO_TYPED;throw"No webgl available."}else throw"unknown type"}function wG(r){if(r===ct.TFJS_WEBGL)return Gs.MAIN_THREAD;if(r===ct.TFJS_WASM)return Zy()?Gs.WORKER_THREAD:Gs.MAIN_THREAD;throw"unknown type"}var vG={flipX:!1,padding:null},Fy=null,Py=class{constructor(){this.firstStart_=!0,this.dispatcher_=new Of,this.InitializeEventEmitters_(),this.backends_=[],this.stopped_=!1,this.started_=!1,this.focusChecker_=new Ri,rR(this,["Warmup","Start","Stop","Configure","SetUpCustomTrackSource","SetUpCameraTrackSource","DownloadModel"])}InitializeEventEmitters_(){let e={n:ne.NUM_WARMUP_FRAMES};new Af(this.dispatcher_,t=>{this.dispatcher_.Publish(t)},t=>{this.dispatcher_.Publish(t)}),new $f(this.dispatcher_),new Rf(this.dispatcher_,t=>{this.dispatcher_.Publish(t)}),new Df(this.dispatcher_,e,t=>{this.dispatcher_.Publish(t)})}SetUpCustomTrackSource(e){this.src_=e}async SetUpCameraTrackSource(){let e=await tR(ne.CAMERA_TRACK_SOURCE_TARGET_RES_FACTOR,ne.CAMERA_TRACK_SOURCE_MIN_RES_FACTOR,ne.CAMERA_TRACK_SOURCE_MAX_RES_FACTOR);if(!e.stream)return{error:e.error};let t=Dy(e.stream);return this.src_=t,{stream:e.stream,video:t}}async Warmup(){let e;if(this.AssertConfigured_(),ne.BACKEND_SELECTION===Mu.AUTO){let t=null;for(let n of ne.BACKEND_COMP_AUTO_SELECTION_ORDER){t=n;let o=await this.WarmupAndScoreBackendWithCompType_(n);if(o.warmupTimeout||(!e||o.avgLatency<e.avgLatency)&&(e=o),console.log("Auto backend selection: Checked "+n+" got avg latency of "+o.avgLatency+"ms"),!o.warmupTimeout&&o.avgLatency<=1e3/ne.MIN_FPS_FOR_INSTANT_COMP_SELECTION)break}this.compType_=e?e.compType:ne.LAST_RESORT_BACKEND_COMP,this.compType_!==t&&await this.WarmupBackendWithCompType_(this.compType_),console.log("Automatic backend selection selected "+this.compType_)}else ne.BACKEND_SELECTION===Mu.WASM?e=await this.WarmupAndScoreBackendWithCompType_(ct.TFJS_WASM):ne.BACKEND_SELECTION===Mu.WEBGL&&(e=await this.WarmupAndScoreBackendWithCompType_(ct.TFJS_WEBGL));return!e||e.warmupTimeout?{maxFpsEstimate:0,avgFpsEstimate:0}:{maxFpsEstimate:1e3/e.minLatency,avgFpsEstimate:1e3/e.avgLatency}}async DownloadModel(e){let t=this.GetModelUrls_(),n=[],o=0,s=0,i=0;for(let a=0;a<t.length;++a){let u=t[a],l=!0;n.push(kr.DownloadModel(u,(c,p)=>{l&&(l=!1,o+=1,s+=c),i+=p,o===t.length&&e&&e(i/s)}))}await Promise.all(n)}Configure(e){if(this.config_)throw"Engine already configured.";e||(e={}),this.config_=e,this.ApplyDefaultsToConfig_()}async Start(e){if(!this.started_){if(this.AssertTrackSource_(),this.AssertConfigured_(),this.CheckAndDetermineCompType_(),this.stopped_=!1,await this.MaybeWaitForVideoToStart_(),Fy)throw new Ff;Fy=this,this.started_=!0,this.eventCb_=e,this.firstStart_&&(await this.PrestartInit_(),this.firstStart_=!1),this.analysis_.Start(this.src_),this.dispatcher_.Publish({type:Le.INITIALIZATION_COMPLETE})}}async Stop(){!this.started_||this.stopped_||(await this.analysis_.Stop(),Fy=null,this.stopped_=!0,this.started_=!1)}GetEnabledFeatures(){if(Xe().RESTRICTION_MODE===Or.ENGINE_FLAGS)throw"Not supported.";let e=Xe().RESTRICTION_MODE===Or.RESTRICTED;return{coords:!0,poses:{pinch:!e,fist:!e}}}async MaybeWaitForVideoToStart_(){}async PrestartInit_(){await this.InitializeBackend_(),this.dispatcher_.Subscribe(t=>{if(!this.stopped_){if("rtc"in t)throw"should not happen";tb(t)&&this.eventCb_(t)}}),this.analysis_=new Fu;let e=this.GetInternalAnalysisConfig_(this.src_);this.analysis_.Initialize(e,async t=>await this.backends_[0].Analyze(t),async t=>{let n=new Date;return await this.backends_[1].Analyze(t)},t=>{this.dispatcher_.Publish({...t})},t=>{this.dispatcher_.Publish({type:Le.LATENCY,latencyMs:t})})}async WarmupAndScoreBackendWithCompType_(e){this.compType_=e;let t=document.createElement("canvas");return t.width=ne.WARMUP_CANVAS_WIDTH,t.height=ne.WARMUP_CANVAS_HEIGHT,this.WarmupAndScoreBackend_(t)}async WarmupBackendWithCompType_(e){this.compType_=e;let t=document.createElement("canvas");return t.width=ne.WARMUP_CANVAS_WIDTH,t.height=ne.WARMUP_CANVAS_HEIGHT,this.WarmupBackend_(t)}async WarmupBackend_(e){await this.InitializeBackend_();let t=new Fu,n=this.GetInternalAnalysisConfig_(e),o=0,s,i=new Promise(c=>{s=c}),a=this.focusChecker_.IsVisible()?new Date:null,u=this.focusChecker_.SubscribeVisibilityChange(c=>{a=c?new Date:null,o=0}),l=!1;return t.Initialize(n,c=>this.backends_[0].Analyze(c),c=>this.backends_[1].Analyze(c),()=>{},c=>{++o,o>=ne.NUM_WARMUP_FRAMES?s():a&&+new Date-+a>ne.ASSESSMENT_TIMEOUT_MS&&(l=!0,s())}),t.Start(e),await i,await t.Stop(),this.focusChecker_.Unsubscribe(u),l}async WarmupAndScoreBackend_(e){let t=e.getContext("2d");await this.InitializeBackend_();let n=new Fu,o=this.GetRelaxedInternalAnalysisConfig_(e),s,i=new Promise(h=>{s=h}),a=null,u=[],l=this.focusChecker_.SubscribeVisibilityChange(h=>{a=h?new Date:null,u=h?[]:null,m=h?ne.NUM_WARMUP_FRAMES:null}),c=!1,p=!1,m=ne.NUM_WARMUP_FRAMES;n.Initialize(o,h=>this.backends_[0].Analyze(h),h=>this.backends_[1].Analyze(h),h=>{p=!0},h=>{m===0&&!a&&(a=new Date),t.fillStyle="rgba("+Math.random()*255+"0",t.fillRect(0,0,1,1),m===0&&u&&u.push(h),u&&u.length>=ne.NUM_ASSESSMENT_FRAMES?s():a&&+new Date-+a>ne.ASSESSMENT_TIMEOUT_MS&&(c=!0,s()),m&&(m-=1)}),n.Start(e),await i,await n.Stop(),this.focusChecker_.Unsubscribe(l),!c&&!p&&console.warn("Something weird happened");let f=99999,d=0;for(let h=0;h<u.length;++h)d+=u[h],f=Math.min(u[h],f);return{compType:this.compType_,minLatency:f,avgLatency:d/u.length,warmupTimeout:c}}GetInternalAnalysisConfig_(e){return{origDimensions:{width:e.width,height:e.height},lanTargetDimensions:{width:ne.LAN_NN_WIDTH,height:ne.LAN_NN_HEIGHT},boxTargetDimensions:{width:ne.BOX_NN_WIDTH,height:ne.BOX_NN_HEIGHT},slack:ne.ANALYSIS_SLACK,minLanHeatmapConfidence:ne.ANALYSIS_MIN_LAN_CONFIDENCE,useBoxHeatmapConfidence:ne.ANALYSIS_USE_BOX_HEATMAP_CONFIDENCE,useLanHeatmapConfidence:ne.ANALYSIS_USE_LAN_HEATMAP_CONFIDENCE,initialLanHeatmapConfidence:ne.ANALYSIS_INITIAL_MIN_LAN_CONFIDENCE,initialBoxHeatmapConfidence:ne.ANALYSIS_INITIAL_MIN_BOX_CONFIDENCE,initialLanGoodFrames:ne.ANALYSIS_INITIAL_LAN_GOOD_FRAMES,initialBoxGoodFrames:ne.ANALYSIS_INITIAL_BOX_GOOD_FRAMES,lanResizeMode:ne.ANALYSIS_LAN_RESIZE_MODE,boxResizeMode:ne.ANALYSIS_BOX_RESIZE_MODE,postProcessing:{flipX:this.config_.flipX,customCoordinateSytem:this.config_.padding},minVisibleLanCoordinates:ne.ANALYSIS_MIN_VISIBLE_LAN_COORDINATES,preprocType:bG(this.compType_),usePostInterval:ne.ANALYSIS_USE_POST_INTERVAL,waitForPreviousTask:!0,singlePipelineNode:!1,boxThresholds:{flipProb:ne.ANALYSIS_BOX_FLIP_THRESHOLD,containsHandProb:ne.ANALYSIS_BOX_HAND_THRESHOLD},lanThresholds:{containsHandProb:ne.ANALYSIS_LAN_HAND_THRESHOLD,pinchClosedProb:ne.ANALYSIS_LAN_PINCH_THRESHOLD,fistProb:ne.ANALYSIS_LAN_FIST_THRESHOLD,flipProb:ne.ANALYSIS_LAN_FLIP_THRESHOLD},minBorderDistance:ne.ANALYSIS_MIN_REQ_BORDER_DISTANCE}}GetRelaxedInternalAnalysisConfig_(e){let t=this.GetInternalAnalysisConfig_(e);return t.lanThresholds.containsHandProb=0,t.boxThresholds.containsHandProb=0,t.minVisibleLanCoordinates=0,t.useLanHeatmapConfidence=!1,t.useBoxHeatmapConfidence=!1,t.initialBoxGoodFrames=0,t.initialLanGoodFrames=0,t}async InitializeBackend_(){this.backends_=[];let e=this.GetModelUrls_();for(let t=0;t<e.length;++t){let n=e[t],o=wG(this.compType_),s=JA({tfjs:!0,compConfig:{type:this.compType_,offscreen:!1},blocking:!1,url:n,threadType:o});await s.Initialize(),this.backends_.push(s)}}AssertConfigured_(){if(!this.config_)throw"Engine not configured. Did you forget to call Configure()?"}AssertTrackSource_(){if(!this.src_)throw"No track source set. Did you forget to call SetUpCameraTrackSource/SetUpCustomTrackSource?"}CheckAndDetermineCompType_(){ne.BACKEND_SELECTION===Mu.AUTO&&!this.compType_&&(console.warn("It is recommended to first call Warmup() for optimal engine configuration and performance."),console.log("Defaulting to webgl backend."),this.compType_=ne.LAST_RESORT_BACKEND_COMP)}ApplyDefaultsToConfig_(){typeof this.config_.flipX=="undefined"&&(this.config_.flipX=vG.flipX)}GetModelUrls_(){return IG()}};function IG(){let r=[],e=[null,null];if(Xe().RESTRICTION_MODE==="RESTRICTED")e[0]=e[1]=Qr.RESTRICTED;else if(Xe().RESTRICTION_MODE==="UNRESTRICTED")e[0]=e[1]=Qr.UNRESTRICTED;else if(Xe().RESTRICTION_MODE==="ENGINE_FLAGS")e[0]=ne.BOX_MODEL_RESTRICTION,e[1]=ne.LAN_MODEL_RESTRICTION;else throw"unknown restriction "+Xe().RESTRICTION_MODE;return Xe().EXPRESS_MODEL_URL?r.push(Sy({url:Xe().MODEL_URL,format:Jr.EXPRESS})):r.push(Sy({url:Xe().MODEL_URL,format:Jr.ADVANCED,qat:ne.BOX_MODEL_8BIT_QAT,checkpoint:ne.BOX_MODEL_CHECKPOINT_SELECTION,restriction:e[0],outputFormat:ne.BOX_MODEL_OUTPUT_FORMAT,quantization:ne.BOX_MODEL_QUANTIZATION,modelType:Sr.TFJS_NATIVE})),Xe().EXPRESS_MODEL_URL?r.push(Ty({url:Xe().MODEL_URL,format:Jr.EXPRESS})):r.push(Ty({url:Xe().MODEL_URL,format:Jr.ADVANCED,qat:ne.LAN_MODEL_8BIT_QAT,checkpoint:ne.LAN_MODEL_CHECKPOINT_SELECTION,restriction:e[1],outputFormat:ne.LAN_MODEL_OUTPUT_FORMAT,quantization:ne.LAN_MODEL_QUANTIZATION,modelType:Sr.TFJS_NATIVE})),r}if(_l()){let r={CreateEngine(){return new Py}},e=window;e.HandTrackingApi=r,e.__q2_VERSION=Xe().VERSION,e.__q2_RESTRICTION_MODE=Xe().RESTRICTION_MODE,e.__q2_HandTrackingApiLoaded&&e.__q2_HandTrackingApiLoaded()}})();
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/** @license See the LICENSE file. */
